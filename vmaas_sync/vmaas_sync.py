"""VMaaS websocket listener module."""

import os

from prometheus_client import Counter, start_http_server
from psycopg2.extras import execute_values
import requests
from tornado.ioloop import IOLoop, PeriodicCallback
from tornado.web import Application, RequestHandler
from tornado.websocket import websocket_connect

from common.database_handler import DatabaseHandler, init_db
from common.logging import init_logging, get_logger
from common import mqueue
from common.utils import vmaas_post_request

WEBSOCKET_RECONNECT_INTERVAL = 60
LOGGER = get_logger(__name__)

PROMETHEUS_PORT = os.getenv('PROMETHEUS_PORT', '8086')

CANNOT_CNX = Counter('ve_listener_vmaas_cannot_cnx', '# of times failed to connect to VMaaS')
REFRESH = Counter('ve_listener_vmaas_webscan_refreshes', '# of times VMaaS told us it had new data')
CNX_FAIL = Counter('ve_listener_vmaas_websocket_failures', '# of times VMaaS websocket closed on us')
CNX_RECONNECT = Counter('ve_listener_vmaas_websocket_recnx', '# of times attempted VMaaS websocket reconnect')

VMAAS_HOST = os.getenv('VMAAS_HOST', 'http://vmaas_webapp:8080')
VMAAS_CVES_ENDPOINT = "%s/api/v1/cves" % VMAAS_HOST


def sync_cve_md(page_size=5000):
    """Sync all CVE metadata from VMaaS"""
    LOGGER.info('Syncing CVE metadata')
    conn = DatabaseHandler.get_connection()
    cur = conn.cursor()
    impact_id_map = {}
    cur.execute("select name, id from cve_impact")
    for impact_name, impact_id in cur.fetchall():
        impact_id_map[impact_name] = impact_id
    cur.execute('select cve from cve_metadata')
    cves_in_db = []
    for cve_tuple in cur.fetchall():
        cves_in_db.append(cve_tuple[0])
    cve_list = [".*"]
    success = True
    page = 1
    session = requests.Session()
    while True:
        cve_request = {'cve_list' : cve_list, 'page_size' : page_size, 'page': page, 'rh_only' : True}
        LOGGER.info('Downloading CVE metadata (page: %s, page_size: %s)', page, page_size)
        r_json = vmaas_post_request(VMAAS_CVES_ENDPOINT, cve_request, session=session)
        if r_json is None:
            success = False
            break
        LOGGER.info('Importing CVE metadata (page: %s, page_size: %s, pages: %s)',
                    page, page_size, r_json['pages'])
        cves = r_json['cve_list']
        to_insert = []
        to_update = []
        for cve in cves:
            description = cves[cve]['description']
            impact_id = impact_id_map[cves[cve]['impact']]
            public_date = cves[cve]['public_date'] or None
            modified_date = cves[cve]['modified_date'] or None
            cvss3_score = float(cves[cve]['cvss3_score']) if cves[cve].get('cvss3_score') else None
            cvss3_metrics = cves[cve].get('cvss3_metrics')
            cvss2_score = float(cves[cve]['cvss2_score']) if cves[cve].get('cvss2_score') else None
            cvss2_metrics = cves[cve].get('cvss2_metrics')
            row = (cve, description, impact_id, public_date, modified_date, cvss3_score, cvss3_metrics,
                   cvss2_score, cvss2_metrics)
            if cve not in cves_in_db:
                to_insert.append(row)
            else:
                to_update.append(row)
        if to_insert:
            execute_values(cur, """insert into cve_metadata
                           (cve, description, impact_id, public_date, modified_date,
                           cvss3_score, cvss3_metrics, cvss2_score, cvss2_metrics)
                           values %s""", to_insert, page_size=len(to_insert))
        if to_update:
            execute_values(cur, """update cve_metadata set description = data.description,
                           impact_id = data.impact_id,
                           public_date = cast(data.public_date as timestamp with time zone),
                           modified_date = cast(data.modified_date as timestamp with time zone),
                           cvss3_score = cast(data.cvss3_score as numeric),
                           cvss3_metrics = data.cvss3_metrics,
                           cvss2_score = cast(data.cvss2_score as numeric),
                           cvss2_metrics = data.cvss2_metrics
                           from (values %s) as data (cve, description, impact_id, public_date, modified_date,
                           cvss3_score, cvss3_metrics, cvss2_score, cvss2_metrics)
                           where cve_metadata.cve = data.cve""",
                           to_update, page_size=len(to_update))
        LOGGER.info('Finished importing CVE metadata (page: %s, page_size: %s, pages: %s)',
                    page, page_size, r_json['pages'])
        if page >= r_json['pages']:
            break
        page += 1
    cur.close()
    conn.commit()
    session.close()
    LOGGER.info('Finished syncing CVE metadata')
    return success


class HealthHandler(RequestHandler):
    """Handler class providing health status."""
    def data_received(self, chunk):
        pass

    def get(self):
        """Answer GET request."""
        self.finish()


class SyncHandler(RequestHandler):
    """Convenient API performing sync on demand."""
    def data_received(self, chunk):
        pass

    def put(self):
        """Answer PUT request."""
        sync_cve_md()
        self.finish()


class ReEvaluateHandler(RequestHandler):
    """Convenient API to schedule re-evaluation for all systems."""
    def data_received(self, chunk):
        pass

    def put(self):
        """Answer PUT request."""
        self.application.re_evaluate_systems()
        self.finish()


class ServerApplication(Application):
    """Websocket client application."""
    def __init__(self):
        handlers = [
            (r"/api/v1/monitoring/health/?", HealthHandler),
            (r"/api/v1/sync/?", SyncHandler),
            (r"/api/v1/re-evaluate/?", ReEvaluateHandler),
        ]
        Application.__init__(self, handlers)
        self.instance = IOLoop.instance()
        self.vmaas_websocket_url = "ws://%s/" % os.getenv("VMAAS_WEBSOCKET_HOST", "vmaas_websocket:8082")
        self.vmaas_websocket = None
        self.reconnect_callback = None
        self.evaluator_queue = None

    def start(self):
        """Start websocket server."""
        # Sync CVEs always when app starts
        sync_cve_md()
        self._websocket_reconnect()
        self.reconnect_callback = PeriodicCallback(self._websocket_reconnect,
                                                   WEBSOCKET_RECONNECT_INTERVAL * 1000)
        self.reconnect_callback.start()
        self.evaluator_queue = mqueue.MQWriter(mqueue.EVALUATOR_TOPIC)
        self.instance.start()

    def _websocket_reconnect(self):
        """Connect to given websocket, set message handler and callback."""
        if self.vmaas_websocket is None:
            CNX_RECONNECT.inc()
            websocket_connect(self.vmaas_websocket_url,
                              on_message_callback=self._read_websocket_message,
                              callback=self._websocket_connect_status)

    def _websocket_connect_status(self, future):
        """Check if connection attempt succeeded."""
        try:
            result = future.result()
        except: # pylint: disable=bare-except
            result = None

        if result is None:
            # TODO: print the traceback as debug message when we use logging module instead of prints here
            CNX_FAIL.inc()
            LOGGER.warning("Unable to connect to: %s", self.vmaas_websocket_url)
        else:
            LOGGER.info("Connected to: %s", self.vmaas_websocket_url)
            result.write_message("subscribe-listener")

        self.vmaas_websocket = result

    def re_evaluate_systems(self):
        """Schedule re-evaluation for all systems in DB."""
        LOGGER.info("Re-evaluating all systems")
        conn = DatabaseHandler.get_connection()
        cur = conn.cursor()
        cur.execute("select inventory_id from system_platform")
        # reevaluate updates for every system in the DB
        for inventory_id, in cur.fetchall():
            self.evaluator_queue.send({"type": "re-evaluate_system", "system_id": inventory_id})
        cur.close()
        conn.commit()

    def _read_websocket_message(self, message):
        """Read incoming websocket messages."""
        if message is not None:
            if message == "webapps-refreshed":
                REFRESH.inc()
                LOGGER.info("VMaaS cache refreshed")
                sync_cve_md()
                self.re_evaluate_systems()
        else:
            CNX_FAIL.inc()
            LOGGER.warning("Connection to %s closed: %s (%s)", self.vmaas_websocket_url,
                           self.vmaas_websocket.close_reason, self.vmaas_websocket.close_code)
            self.vmaas_websocket = None

def main():
    """Main VMaaS listener entrypoint."""
    start_http_server(int(PROMETHEUS_PORT))
    init_logging()
    init_db()
    LOGGER.info("Starting VMaaS sync service.")
    app = ServerApplication()
    app.listen(8000)
    app.start()


if __name__ == '__main__':
    main()
