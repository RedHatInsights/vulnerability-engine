"""
Module handling page separation
"""

import requests

from psycopg2.extras import execute_values
from common.logging import get_logger
from common import utils

LOGGER = get_logger(__name__)


def delete_cves(cur, cves_in_db, all_rh_cves):
    """Delete cves from ve_engine db"""
    to_delete = [(cve,) for cve in cves_in_db if cve not in all_rh_cves]
    if to_delete:
        LOGGER.info("Deleting %s unnecessary CVE metadata", len(to_delete))
        execute_values(cur, """select cm.cve from cve_metadata cm
                               where not exists(select sv.cve_id from system_vulnerabilities sv
                               where cm.id = sv.cve_id)
                               and cm.cve in (%s)""",
                       to_delete, page_size=len(to_delete))
        safety_delete = [cve_name_tuple[0] for cve_name_tuple in cur.fetchall()]
        unable_to_delete = [cve for cve in zip(*to_delete).__next__() if cve not in safety_delete]
        if safety_delete:
            execute_values(cur, """delete from cve_affected_systems_cache
                                   where cve_id in (select cve_id from cve_metadata
                                   where cve in (%s))""",
                           [i for i in zip(*safety_delete)], page_size=len(safety_delete))
            execute_values(cur, """delete from cve_metadata where cve in (%s)""",
                           [i for i in zip(*safety_delete)], page_size=len(safety_delete))
            LOGGER.info('Finished deleting unnecessary CVE metadata')
        if unable_to_delete:
            LOGGER.warning('Unable to delete %s cves (still referenced from system_vulnerabilities table): %s',
                           len(unable_to_delete), str(unable_to_delete))
    del all_rh_cves


def paging(endpoint, request_json, cves_in_db, cur) -> tuple:
    """Split input list into pages"""
    result_pages = {}
    session = requests.Session()
    success = True
    split = []
    all_rh_cves = set()
    while True:
        r_json = utils.vmaas_post_request(endpoint, request_json, session)
        if r_json is None:
            LOGGER.info("Downloading ERROR.")
            success = False
            break
        split = [(k, v) for k, v in r_json.items()]
        result_pages[split[0][0]] = split[0][1]
        LOGGER.info("Downloading CVE/REPOs metadata (page: %s, page_size: %s, pages: %s)",
                    request_json['page'], r_json["page_size"], r_json['pages'])
        all_rh_cves.update(result_pages["cve_list"])
        if request_json['page'] >= r_json['pages']:
            delete_cves(cur, cves_in_db, all_rh_cves)
            break
        request_json['page'] += 1
    session.close()

    if success:
        result_pages.update({"page": r_json["page"], "page_size": r_json["page_size"], "pages": r_json["pages"]})
    return (success, result_pages)
