"""Module with classes for work with Kafka Message queue."""

import asyncio
import json
import hashlib

from aiokafka import AIOKafkaConsumer, AIOKafkaProducer
from kafka.errors import KafkaError
from kafka.partitioner.default import DefaultPartitioner

from common.config import Config
from common.logging import get_logger

LOGGER = get_logger(__name__)

CFG = Config()


class Partitioners:
    """
    Class providing Kafka partitioners
    """
    fallback_partitioner = DefaultPartitioner()

    @classmethod
    def org_id_partitioner(cls, key: str, all_partitions: [], available_partitions: []):
        # pylint: disable=broad-except
        """Kafka producer partitioner, expects org_id as a key and selects partition by modulo."""
        org_id_hash = None
        try:
            org_id_hash = int(hashlib.sha1(key).hexdigest(), 16)
        except Exception as exc:
            LOGGER.error("Kafka org_id partitioner error: %s", exc)
            return cls.fallback_partitioner(key, all_partitions, available_partitions)

        partition = all_partitions[org_id_hash % len(all_partitions)]
        LOGGER.debug("Redirecting kafka message with key: %s, to partition: %s", key, partition)
        return partition


class MQClient:
    """Message queue client wrapper around AIOKafka"""

    def __init__(self, client, name):
        self.client = client
        self.name = name
        self.connected = False
        self.connect_lock = asyncio.Lock()

    async def start(self):
        """Starts the kafka consumer/producer"""
        if not self.connected:
            await self.connect_lock.acquire()
            while not self.connected:
                try:
                    LOGGER.info("Attempting to connect %s client.", self.name)
                    await self.client.start()
                    LOGGER.info("%s client connected successfully.", self.name)
                    self.connected = True
                except KafkaError:
                    LOGGER.exception("Failed to connect %s client, retrying in %d seconds.", self.name, CFG.retry_interval)
                    await asyncio.sleep(CFG.retry_interval)
            self.connect_lock.release()

    async def stop(self):
        """Stops the kafka consumer/producer"""
        try:
            LOGGER.info("Attempting to stop %s client.", self.name)
            await self.client.stop()
            LOGGER.info("%s client stopped successfully.", self.name)
            self.connected = False
        except KafkaError:
            LOGGER.exception("Failed to stop %s client.", self.name)

    def _serialize_key(self, key):
        # pylint: disable=no-self-use
        """Serializes key to bytes"""
        if key:
            return key.encode("utf-8")
        return None


class MQReader(MQClient):
    """Wrapper around AIOKafka consumer"""

    def __init__(self, topic, group_id=CFG.kafka_group_id, bootstrap_servers=CFG.bootstrap_servers, **kwargs):
        self.loop = asyncio.get_event_loop()
        if isinstance(topic, str):
            topic = [topic]
        consumer = AIOKafkaConsumer(*topic, loop=self.loop, bootstrap_servers=bootstrap_servers, group_id=group_id,
                                    auto_offset_reset='latest', session_timeout_ms=30000, security_protocol=CFG.security_protocol,
                                    ssl_context=CFG.ssl_context, sasl_mechanism=CFG.sasl_mechanism, sasl_plain_username=CFG.sasl_plain_username,
                                    sasl_plain_password=CFG.sasl_plain_password, **kwargs)
        super().__init__(consumer, 'AIOKafka Consumer')

    async def consume(self, func):
        """Consumes messages coming from Kafka"""
        await self.start()
        try:
            async for msg in self.client:
                func(msg)
        except KafkaError:
            self.connected = False

    def listen(self, func):
        """Starts the listener"""
        self.loop.run_until_complete(self.consume(func))


class MQWriter(MQClient):
    """Wrapper around AIOKafka producer"""

    def __init__(self, topic, bootstrap_servers=CFG.bootstrap_servers, **kwargs):
        self.loop = asyncio.get_event_loop()
        producer = AIOKafkaProducer(loop=self.loop, bootstrap_servers=bootstrap_servers, security_protocol=CFG.security_protocol,
                                    ssl_context=CFG.ssl_context, sasl_mechanism=CFG.sasl_mechanism, sasl_plain_username=CFG.sasl_plain_username,
                                    sasl_plain_password=CFG.sasl_plain_password, **kwargs)
        self.topic = topic
        super().__init__(producer, 'AIOKafka Producer')

    async def send_one(self, msg, key=None):
        """Logic around message sending"""
        await self.start()
        try:
            data = bytes(json.dumps(msg).encode('utf-8'))
            res = await self.client.send_and_wait(self.topic, value=data, key=self._serialize_key(key))
            LOGGER.debug(res)
        except KafkaError:
            self.connected = False

    async def send_many(self, msg_list, key=None):
        """Send list of messages"""
        await self.start()
        try:
            for msg in msg_list:
                data = bytes(json.dumps(msg).encode('utf-8'))
                res = await self.client.send_and_wait(self.topic, value=data, key=self._serialize_key(key))
                LOGGER.debug(res)
        except KafkaError:
            self.connected = False

    async def send_raw(self, msg: bytes, key=None):
        """Logic around sending raw message"""
        await self.start()
        try:
            res = await self.client.send_and_wait(self.topic, value=msg, key=self._serialize_key(key))
            LOGGER.debug(res)
        except KafkaError:
            self.connected = False

    def send(self, msg, key=None, loop=None):
        """Sends a message"""
        return asyncio.ensure_future(self.send_one(msg, key=key), loop=loop)

    def send_list(self, msgs, key=None, loop=None):
        """Sends list of messages"""
        return asyncio.ensure_future(self.send_many(msgs, key=key), loop=loop)

    def send_bytes(self, msg: bytes, key=None, loop=None):
        """Sends a message, where message is already encoded to bytes"""
        return asyncio.ensure_future(self.send_raw(msg, key=key), loop=loop)
