"""
Use Clowder config or env vars config.
"""
import os
import tempfile

import app_common_python
from aiokafka.helpers import create_ssl_context
from app_common_python.types import BrokerConfigAuthtypeEnum

from common.strtobool import strtobool


class Singleton(type):
    """Singleton object."""

    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

    def delete(cls):
        """Delete instances"""
        del Singleton._instances[cls]


class ConfigException(Exception):
    """Exception for config"""


# pylint: disable=too-many-instance-attributes
class BaseConfig:
    """Base configuration, same for clowder and non-clowder."""

    # pylint: disable=too-many-statements
    def __init__(self):
        self.db_host_read_replica = os.getenv("POSTGRES_HOST_READ_REPLICA", "")
        self.db_port_read_replica = int(os.getenv("POSTGRES_PORT_READ_REPLICA", "0"))
        self.db_read_replica_enabled = strtobool(os.getenv("POSTGRES_READ_REPLICA_ENABLED", "TRUE"))

        self.ve_db_user_manager_pwd = os.getenv("VE_DB_USER_MANAGER_PASSWORD", "ve_db_user_manager_pwd")
        self.ve_db_user_evaluator_pwd = os.getenv("VE_DB_USER_EVALUATOR_PASSWORD", "ve_db_user_evaluator_pwd")
        self.ve_db_user_listener_pwd = os.getenv("VE_DB_USER_LISTENER_PASSWORD", "ve_db_user_listener_pwd")
        self.ve_db_user_vmaas_sync_pwd = os.getenv("VE_DB_USER_VMAAS_SYNC_PASSWORD", "ve_db_user_vmaas_sync_pwd")
        self.ve_db_user_taskomatic_pwd = os.getenv("VE_DB_USER_TASKOMATIC_PASSWORD", "ve_db_user_taskomatic_pwd")
        self.ve_db_user_advisor_listener_pwd = os.getenv("VE_DB_USER_ADVISOR_LISTENER_PASSWORD", "ve_db_user_advisor_listener_pwd")
        self.ve_db_user_notificator_pwd = os.getenv("VE_DB_USER_NOTIFICATOR_PASSWORD", "ve_db_user_notificator_pwd")

        self.hostname = os.environ.get("HOSTNAME", "vulnerability-engine")
        self.group_id = self.hostname
        self.cw_enabled = strtobool(os.getenv("CW_ENABLED", "FALSE"))
        self.logging_type = os.getenv("LOGGING_TYPE", "DEVEL")
        self.logging_level_app = os.getenv("LOGGING_LEVEL_APP", "INFO")
        self.logging_level_libs = os.getenv("LOGGING_LEVEL_LIBS", "WARNING")

        self.request_retries = int(os.getenv("REQUEST_RETRIES", "3"))
        self.vulnerability_env = os.getenv("VULNERABILITY_ENV", "dev")
        self.minimal_schema = int(os.getenv("MINIMAL_SCHEMA", "0"))

        self.retry_interval = int(os.getenv("RETRY_INTERVAL", "5"))
        self.kafka_group_id = os.getenv("KAFKA_GROUP_ID", "vulnerability")

        # Feature Flags with Unleash
        self.unleash_url = os.getenv("UNLEASH_URL", "")
        self.unleash_token = os.getenv("UNLEASH_TOKEN", "")
        self.unleash_cache_dir = os.getenv("UNLEASH_CACHE_DIR", "/tmp/unleash_cache")
        self.unleash_bootstrap_file = os.environ.get("UNLEASH_BOOTSTRAP_FILE")

        self.vmaas_vulnerabilities_api = os.getenv("VMAAS_VULNERABILITIES_API", "/api/vmaas/v3/vulnerabilities")

        self.evaluator_prometheus_port = 8085
        self.taskomatic_prometheus_port = 8085
        self.listener_prometheus_port = 8086
        self.adv_listener_prometheus_port = 8086
        self.vmaas_sync_prometheus_port = 8087

        self.db_min_pool_size = int(os.getenv("DB_MIN_POOL_SIZE", "10"))
        self.db_max_pool_size = int(os.getenv("DB_MAX_POOL_SIZE", "30"))

        self.db_pool_timeout_sec = float(os.getenv("DB_POOL_TIMEOUT", "300"))

        self.max_queue_size = int(os.getenv("MAX_QUEUE_SIZE", "30"))
        self.disable_optimisation = strtobool(os.getenv("DISABLE_OPTIMISATION", "False"))

        self.timeout_secs = int(os.getenv("STATUS_TIMEOUT", "10"))

        self.default_route = f"{os.getenv('PATH_PREFIX', '/api')}/{os.getenv('APP_NAME', 'vulnerability')}/{os.getenv('API_VERSION', 'v1')}"
        self.read_only_mode = strtobool(os.environ.get("READ_ONLY_MODE", "FALSE"))

        self.db_upgrade_scripts_dir = os.getenv("DB_UPGRADE_SCRIPTS_DIR", "./database/schema/upgrade_scripts")
        self.gunicorn_workers = int(os.getenv("GUNICORN_WORKERS", "4"))

        self.max_loaded_listener_msgs = int(os.getenv("MAX_LOADED_LISTENER_MSGS", "50"))
        self.max_loaded_grouper_msgs = int(os.getenv("MAX_LOADED_GROUPER_MSGS", "100"))
        self.max_loaded_evaluator_msgs = int(os.getenv("MAX_LOADED_EVALUATOR_MSGS", "30"))

        self.tls_ca_path = None
        self.public_port = 8000
        self.private_port = 8000

        self.is_fedramp = strtobool(os.getenv("IS_FEDRAMP", "FALSE"))

        # taskomatic jobs
        self.system_deletion_threshold = int(os.getenv("SYSTEM_DELETION_THRESHOLD", "24"))  # 24 hours
        self.content_git_repo = os.getenv("CONTENT_GIT_REPO", "")
        self.playbooks_git_repo = os.getenv("PLAYBOOKS_GIT_REPO", "")
        self.git_token = os.getenv("GIT_TOKEN", "")  # used also by exploit-sync
        self.jobs = os.getenv("JOBS", "").split(",")
        self.jobs_startup = os.getenv("JOBS_STARTUP", "").split(",")
        self.accounts_blacklist = os.getenv("ACCOUNTS_BLACKLIST", "")
        self.cve_freshness_threshold = int(os.getenv("CVE_FRESHNESS_THRESHOLD_DAYS", "3"))

        # exploit-sync job
        self.exploit_file_url = os.getenv("EXPLOIT_FILE_URL", "")

        # vmaas_sync
        self.enable_re_evaluation = strtobool(os.getenv("ENABLE_RE_EVALUATION", "YES"))
        self.enable_repo_based_re_evaluation = strtobool(os.getenv("ENABLE_REPO_BASED_RE_EVALUATION", "NO"))
        self.default_page_size = int(os.getenv("DEFAULT_PAGE_SIZE", "5000"))

        # how many systems to select in one batch and send to kafka
        self.re_evaluation_kafka_batch_size = int(os.getenv("RE_EVALUATION_KAFKA_BATCH_SIZE", "10000"))
        # how many batches to create at the same time
        self.re_evaluation_kafka_batches = int(os.getenv("RE_EVALUATION_KAFKA_BATCHES", "10"))

        self.dashboard_rules_age = int(os.getenv("DASHBOARD_RULES_AGE", "30"))

        # RBAC request timeout in seconds
        self.rbac_timeout = int(os.getenv("RBAC_TIMEOUT", "15"))
        self.disable_rbac = strtobool(os.getenv("DISABLE_RBAC", "FALSE"))
        # Granular RBAC feature-flag
        self.granular_rbac = strtobool(os.getenv("GRANULAR_RBAC", "FALSE"))

        # Minimal systems in account to enable cache
        self.cache_minimal_account_systems = int(os.getenv("CACHE_MINIMAL_ACCOUNT_SYSTEMS", "1000"))

        # Kafka SSL settings
        self.kafka_ssl_enabled = strtobool(os.getenv("KAFKA_SSL_ENABLED", "FALSE"))
        self.security_protocol = "PLAINTEXT"
        self.ssl_context = None
        self.sasl_mechanism = "PLAIN"
        self.sasl_plain_username = None
        self.sasl_plain_password = None

        # Listener
        self.listeners_valid_system_sec = int(os.getenv("LISTENERS_VALID_SYSTEM_SECONDS", "300"))

        # Grouper
        self.grouper_messages_timeout_sec = int(os.getenv("GROUPER_MESSAGES_TIMEOUT_SECS", "10"))

        # Cluster job
        self.cluster_system_vulnerabilities = strtobool(os.getenv("CLUSTER_SYSTEM_VULNERABILITIES", "TRUE"))
        self.cluster_system_vulnerable_package = strtobool(os.getenv("CLUSTER_SYSTEM_VULNERABLE_PACKAGE", "TRUE"))

        # Reporters
        self.allowed_reporters = os.getenv("ALLOWED_REPORTERS", "puptoo,rhsm-system-profile-bridge").split(",")

        # OSes
        self.allowed_oses = set(os.getenv("ALLOWED_OSES", "RHEL").split(","))


# pylint: disable=too-many-instance-attributes
class Config(BaseConfig, metaclass=Singleton):
    """VMaaS configuration singleton."""

    def __init__(self):
        super().__init__()
        self._cfg = None
        if app_common_python.isClowderEnabled():
            self._cfg = app_common_python.LoadedConfig
            self.clowder()
        else:
            self.legacy()
        self.other()

    def _set_kafka_ssl_legacy(self):
        self.security_protocol = "SASL_SSL"
        self.ssl_context = create_ssl_context(cafile=os.getenv("KAFKA_CA_CERT", "/opt/certs/kafka-cacert"))
        self.sasl_mechanism = "SCRAM-SHA-512"
        self.sasl_plain_username = os.getenv("KAFKA_USERNAME", "")
        self.sasl_plain_password = os.getenv("KAFKA_PASSWORD", "")

    def clowder(self):  # pylint: disable=too-many-statements,too-many-branches
        """ "Configuration from Clowder."""
        self.tls_ca_path = self._cfg.tlsCAPath
        self.public_port = self._cfg.publicPort
        self.private_port = self._cfg.privatePort
        self.prometheus_port = self._cfg.metricsPort

        self.db_name = os.getenv("POSTGRES_DB", self._cfg.database.name)
        self.db_user = os.getenv("POSTGRES_USER", self._cfg.database.username)
        self.db_pass = os.getenv("POSTGRES_PASSWORD", self._cfg.database.password)
        self.db_host = os.getenv("POSTGRES_HOST", self._cfg.database.hostname)
        self.db_port = int(os.getenv("POSTGRES_PORT", self._cfg.database.port))
        self.db_ssl_mode = self._cfg.database.sslMode or "prefer"
        self.db_ssl_root_cert_path = self._cfg.rds_ca() if self._cfg.database.rdsCa else "/opt/rds-ca/rds-cacert"

        self.cw_aws_access_key_id = self._cfg.logging.cloudwatch.accessKeyId
        self.cw_aws_secret_access_key = self._cfg.logging.cloudwatch.secretAccessKey
        self.cw_aws_region = self._cfg.logging.cloudwatch.region
        self.cw_aws_log_group = self._cfg.logging.cloudwatch.logGroup

        def get_topic(name):
            return app_common_python.KafkaTopics[name].name

        broker_cfg = self._cfg.kafka.brokers[0]
        self.bootstrap_servers = f"{broker_cfg.hostname}:{broker_cfg.port}"
        self.events_topic = get_topic("platform.inventory.events")
        self.evaluator_upload_topic = get_topic("vulnerability.evaluator.upload")
        self.evaluator_recalc_topic = get_topic("vulnerability.evaluator.recalc")
        self.evaluator_topics = [
            get_topic(topic)
            for topic in os.getenv("EVALUATOR_TOPIC", "vulnerability.evaluator.upload,vulnerability.evaluator.recalc").split(",")
        ]
        self.grouper_inventory_topic = get_topic("vulnerability.grouper.inventory.upload")
        self.grouper_advisor_topic = get_topic("vulnerability.grouper.advisor.upload")
        self.payload_tracker_topic = get_topic("platform.payload-status")
        self.advisor_results_topic = get_topic("platform.engine.results")
        self.remediation_updates_topic = get_topic("platform.remediation-updates.vulnerability")
        self.notifications_topic = get_topic("platform.notifications.ingress")
        self.evaluator_results_topic = get_topic("vulnerability.evaluator.results")

        def format_uri_scheme_kafka(authtype):
            """Return protocol uri scheme"""
            if authtype in [BrokerConfigAuthtypeEnum.SASL]:
                return "SASL_SSL"
            raise ConfigException("Unknown auth method for kafka")

        def format_ca_cert_kafka(cert):
            """Dump certificate into file, return name"""
            if cert:
                with tempfile.NamedTemporaryFile(delete=False) as cert_f:
                    cert_f.write(cert.encode("utf-8"))
                    return cert_f.name
            return None

        if broker_cfg.authtype:
            self.security_protocol = format_uri_scheme_kafka(broker_cfg.authtype)
            self.kafka_ca_cert = format_ca_cert_kafka(broker_cfg.cacert)
            self.ssl_context = create_ssl_context(cafile=self.kafka_ca_cert)
            mechanism = broker_cfg.sasl.saslMechanism.lower()
            if mechanism == "scram-sha-512":
                self.sasl_mechanism = "SCRAM-SHA-512"
            elif mechanism == "scram-sha-256":
                self.sasl_mechanism = "SCRAM-SHA-256"
            elif mechanism == "plain":
                self.sasl_mechanism = "PLAIN"
            else:
                raise ConfigException("Unknown SASL mechanism for kafka")
            self.sasl_plain_username = broker_cfg.sasl.username
            self.sasl_plain_password = broker_cfg.sasl.password

        self.rbac_url = ""
        self.taskomatic_host = ""
        self.notificator_host = ""
        self.vmaas_host = ""
        use_vmaas_go = strtobool(os.getenv("USE_VMAAS_GO", "true"))
        webapp_name = "webapp-service"
        if use_vmaas_go:
            webapp_name = "webapp-go"
        for endpoint in self._cfg.endpoints:
            if endpoint.app == "rbac":
                self.rbac_url = self._build_url(endpoint)
            elif endpoint.app == "vmaas" and webapp_name in endpoint.name:
                self.vmaas_host = self._build_url(endpoint)
        for endpoint in self._cfg.privateEndpoints:
            if endpoint.app == "vulnerability-engine":
                if "taskomatic" in endpoint.name:
                    self.taskomatic_host = self._build_url(endpoint)
                elif "notificator" in endpoint.name:
                    self.notificator_host = self._build_url(endpoint)

        if self._cfg.featureFlags and not self.unleash_bootstrap_file:
            ffconf = self._cfg.featureFlags
            if all((ffconf.scheme, ffconf.hostname, ffconf.port)):
                self.unleash_url = f"{ffconf.scheme.value}://{ffconf.hostname}:{ffconf.port}/api/"
                self.unleash_token = ffconf.clientAccessToken

    def legacy(self):
        """Configuration from environment variables."""
        self.db_name = os.getenv("POSTGRES_DB", "vulnerability").strip()
        self.db_user = os.getenv("POSTGRES_USER", "ve_db_user_unknown").strip()
        self.db_pass = os.getenv("POSTGRES_PASSWORD", "ve_db_user_unknown_pwd").strip()
        self.db_host = os.getenv("POSTGRES_HOST", "ve_database").strip()
        self.db_port = int(os.getenv("POSTGRES_PORT", "5432").strip())
        self.db_ssl_mode = os.getenv("POSTGRES_SSL_MODE", "prefer")
        self.db_ssl_root_cert_path = os.getenv("POSTGRES_SSL_ROOT_CERT_PATH", "/opt/rds-ca/rds-cacert")

        self.cw_aws_access_key_id = os.environ.get("CW_AWS_ACCESS_KEY_ID")
        self.cw_aws_secret_access_key = os.environ.get("CW_AWS_SECRET_ACCESS_KEY")
        self.cw_aws_region = os.environ.get("AWS_REGION", "us-east-1")
        self.cw_aws_log_group = os.environ.get("CW_LOG_GROUP", "platform-dev")

        self.bootstrap_servers = f"{os.getenv('KAFKA_HOST', 've_kafka')}:{os.getenv('KAFKA_PORT', '9092')}"
        self.events_topic = os.getenv("EVENTS_TOPIC", "platform.inventory.events")
        self.evaluator_upload_topic = os.getenv("MESSAGE_TOPIC", "vulnerability.evaluator.upload")
        self.evaluator_recalc_topic = os.getenv("MESSAGE_TOPIC", "vulnerability.evaluator.recalc")
        self.evaluator_topics = os.getenv("EVALUATOR_TOPIC", "vulnerability.evaluator.upload,vulnerability.evaluator.recalc").split(",")
        self.grouper_inventory_topic = os.getenv("GROUPER_INVENTORY_TOPIC", "vulnerability.grouper.inventory.upload")
        self.grouper_advisor_topic = os.getenv("GROUPER_ADVISOR_TOPIC", "vulnerability.grouper.advisor.upload")
        self.payload_tracker_topic = os.getenv("PAYLOAD_TRACKER_TOPIC", "platform.payload-status")
        self.advisor_results_topic = os.getenv("ADVISOR_RESULTS_TOPIC", "platform.engine.results")
        self.remediation_updates_topic = os.getenv("REMEDIATION_UPDATES_TOPIC", "platform.remediation-updates.vulnerability")
        self.notifications_topic = os.getenv("NOTIFICATIONS_TOPIC", "platform.notifications.ingress")
        self.evaluator_results_topic = os.getenv("EVALUATOR_RESULTS_TOPIC", "vulnerability.evaluator.results")

        self.rbac_url = os.environ.get("RBAC_URL")
        self.vmaas_host = os.getenv("VMAAS_HOST", "http://vmaas_webapp:8000")
        self.taskomatic_host = os.getenv("TASKOMATIC_HOST", "http://ve_taskomatic:8000")
        self.notificator_host = os.getenv("NOTIFICATOR_HOST", "http://ve_notificator:8000")

        self.prometheus_port = os.getenv("PROMETHEUS_PORT", "")

        # SSL settings
        if self.kafka_ssl_enabled:
            self._set_kafka_ssl_legacy()

    def other(self):
        """Configuration which depend on clowder/legacy setting."""
        self.vmaas_vulnerabilities_endpoint = f"{self.vmaas_host}{self.vmaas_vulnerabilities_api}"

    def _build_url(self, endpoint):
        if not self._cfg:
            raise ConfigException("Clowder not configured.")

        scheme = "https" if self.tls_ca_path else "http"
        port = endpoint.tlsPort if self.tls_ca_path else endpoint.port
        return f"{scheme}://{endpoint.hostname}:{port}"
