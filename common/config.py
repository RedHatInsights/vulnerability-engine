"""
Use Clowder config or env vars config.
"""
import os
import tempfile

import app_common_python
from app_common_python.types import BrokerConfigAuthtypeEnum
from aiokafka.helpers import create_ssl_context

from common.strtobool import strtobool


class Singleton(type):
    """Singleton object."""

    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

    def delete(cls):
        """Delete instances"""
        del Singleton._instances[cls]


class ConfigException(Exception):
    """Exception for config"""


# pylint: disable=too-many-instance-attributes
class BaseConfig:
    """Base configuration, same for clowder and non-clowder."""

    # pylint: disable=too-many-statements
    def __init__(self):
        self.skip_entitlement_check = strtobool(os.getenv("SKIP_ENTITLEMENT_CHECK", "FALSE"))

        self.db_host_read_replica = os.getenv("POSTGRESQL_HOST_READ_REPLICA", "")
        self.db_port_read_replica = int(os.getenv("POSTGRESQL_PORT_READ_REPLICA", "0"))
        self.db_read_replica_enabled = strtobool(os.getenv("POSTGRESQL_READ_REPLICA_ENABLED", "TRUE"))

        self.ve_db_user_manager_pwd = os.getenv("VE_DB_USER_MANAGER_PASSWORD", "ve_db_user_manager_pwd")
        self.ve_db_user_evaluator_pwd = os.getenv("VE_DB_USER_EVALUATOR_PASSWORD", "ve_db_user_evaluator_pwd")
        self.ve_db_user_listener_pwd = os.getenv("VE_DB_USER_LISTENER_PASSWORD", "ve_db_user_listener_pwd")
        self.ve_db_user_vmaas_sync_pwd = os.getenv("VE_DB_USER_VMAAS_SYNC_PASSWORD", "ve_db_user_vmaas_sync_pwd")
        self.ve_db_user_taskomatic_pwd = os.getenv("VE_DB_USER_TASKOMATIC_PASSWORD", "ve_db_user_taskomatic_pwd")
        self.ve_db_user_advisor_listener_pwd = os.getenv("VE_DB_USER_ADVISOR_LISTENER_PASSWORD", "ve_db_user_advisor_listener_pwd")
        self.ve_db_user_notificator_pwd = os.getenv("VE_DB_USER_NOTIFICATOR_PASSWORD", "ve_db_user_notificator_pwd")

        self.hostname = os.environ.get("HOSTNAME", "vulnerability-engine")
        self.group_id = self.hostname
        self.cw_enabled = strtobool(os.getenv("CW_ENABLED", "FALSE"))
        self.logging_type = os.getenv("LOGGING_TYPE", "DEVEL")
        self.logging_level_app = os.getenv("LOGGING_LEVEL_APP", "INFO")
        self.logging_level_libs = os.getenv("LOGGING_LEVEL_LIBS", "WARNING")

        self.request_retries = int(os.getenv("REQUEST_RETRIES", "3"))
        self.slack_webhook = os.getenv("SLACK_WEBHOOK")
        self.vulnerability_env = os.getenv("VULNERABILITY_ENV", "dev")
        self.minimal_schema = int(os.getenv("MINIMAL_SCHEMA", "0"))

        self.retry_interval = int(os.getenv("RETRY_INTERVAL", "5"))
        self.kafka_group_id = os.getenv("KAFKA_GROUP_ID", "vulnerability")

        self.vmaas_vulnerabilities_api = os.getenv("VMAAS_VULNERABILITIES_API", "/api/v3/vulnerabilities")
        self.evaluator_manual_cves = strtobool(os.getenv("EVALUATOR_MANUAL_CVES", "FALSE"))

        self.evaluator_prometheus_port = 8085
        self.taskomatic_prometheus_port = 8085
        self.listener_prometheus_port = 8086
        self.adv_listener_prometheus_port = 8086
        self.vmaas_sync_prometheus_port = 8087

        self.db_min_pool_size = int(os.getenv("DB_MIN_POOL_SIZE", "10"))
        self.db_max_pool_size = int(os.getenv("DB_MAX_POOL_SIZE", "30"))

        self.worker_threads = int(os.getenv("WORKER_THREADS", "30"))
        self.max_queue_size = int(os.getenv("MAX_QUEUE_SIZE", "30"))
        self.disable_optimisation = strtobool(os.getenv("DISABLE_OPTIMISATION", "False"))

        self.timeout_secs = int(os.getenv("STATUS_TIMEOUT", "10"))

        self.default_route = f"{os.getenv('PATH_PREFIX', '/api')}/{os.getenv('APP_NAME', 'vulnerability')}/{os.getenv('API_VERSION', 'v1')}"
        self.read_only_mode = strtobool(os.environ.get("READ_ONLY_MODE", "FALSE"))

        self.db_upgrade_scripts_dir = os.getenv("DB_UPGRADE_SCRIPTS_DIR", "./database/schema/upgrade_scripts")
        self.worker_threads = int(os.getenv("WORKER_THREADS", "0"))
        self.gunicorn_workers = int(os.getenv("GUNICORN_WORKERS", "4"))

        self.max_loaded_evaluator_msgs = int(os.getenv("MAX_LOADED_EVALUATOR_MSGS", "30"))
        self.max_loaded_advisor_msgs = int(os.getenv("MAX_LOADED_ADVISOR_LISTENER_MSGS", "30"))

        self.public_port = 8000
        self.private_port = 8000

        # taskomatic jobs
        self.system_deletion_threshold = int(os.getenv("SYSTEM_DELETION_THRESHOLD", "24"))  # 24 hours
        self.content_git_repo = os.getenv("CONTENT_GIT_REPO", "")
        self.playbooks_git_repo = os.getenv("PLAYBOOKS_GIT_REPO", "")
        self.git_token = os.getenv("GIT_TOKEN", "")  # used also by exploit-sync
        self.jobs = os.getenv("JOBS", "").split(",")
        self.jobs_startup = os.getenv("JOBS_STARTUP", "").split(",")
        self.accounts_blacklist = os.getenv("ACCOUNTS_BLACKLIST", "")
        self.cve_freshness_threshold = int(os.getenv("CVE_FRESHNESS_THRESHOLD_DAYS", "3"))

        # exploit-sync job
        self.exploit_file_url = os.getenv("EXPLOIT_FILE_URL", "")

        # vmaas_sync
        self.enable_re_evaluation = strtobool(os.getenv("ENABLE_RE_EVALUATION", "YES"))
        self.enable_repo_based_re_evaluation = strtobool(os.getenv("ENABLE_REPO_BASED_RE_EVALUATION", "NO"))
        self.default_page_size = int(os.getenv("DEFAULT_PAGE_SIZE", "5000"))

        # how many systems to select in one batch and send to kafka
        self.re_evaluation_kafka_batch_size = int(os.getenv("RE_EVALUATION_KAFKA_BATCH_SIZE", "10000"))
        # how many batches to create at the same time
        self.re_evaluation_kafka_batches = int(os.getenv("RE_EVALUATION_KAFKA_BATCHES", "10"))

        self.dashboard_rules_age = int(os.getenv("DASHBOARD_RULES_AGE", "30"))

        # RBAC request timeout in seconds
        self.rbac_timeout = int(os.getenv("RBAC_TIMEOUT", "15"))
        self.disable_rbac = strtobool(os.getenv("DISABLE_RBAC", "FALSE"))
        # Granular RBAC feature-flag
        self.granular_rbac = strtobool(os.getenv("GRANULAR_RBAC", "FALSE"))

        # Minimal systems in account to enable cache
        self.cache_minimal_account_systems = int(os.getenv("CACHE_MINIMAL_ACCOUNT_SYSTEMS", "1000"))
        self.disable_account_cache = strtobool(os.getenv("DISABLE_ACCOUNT_CACHE", "FALSE"))

        # Kafka SSL settings
        self.kafka_ssl_enabled = strtobool(os.getenv("KAFKA_SSL_ENABLED", "FALSE"))
        self.security_protocol = "PLAINTEXT"
        self.ssl_context = None
        self.sasl_mechanism = "PLAIN"
        self.sasl_plain_username = None
        self.sasl_plain_password = None

        # Listeners
        self.listeners_valid_system_sec = int(os.getenv("LISTENERS_VALID_SYSTEM_SECONDS", "300"))
        self.listener_messages_timeout_sec = int(os.getenv("LISTENER_MESSAGES_TIMEOUT_SECS", "10"))


# pylint: disable=too-many-instance-attributes
class Config(BaseConfig, metaclass=Singleton):
    """VMaaS configuration singleton."""

    def __init__(self):
        super().__init__()
        if app_common_python.isClowderEnabled():
            self.clowder()
        else:
            self.legacy()
        self.other()

    def _set_kafka_ssl_legacy(self):
        self.security_protocol = "SASL_SSL"
        self.ssl_context = create_ssl_context(cafile=os.getenv("KAFKA_CA_CERT", "/opt/certs/kafka-cacert"))
        self.sasl_mechanism = "SCRAM-SHA-512"
        self.sasl_plain_username = os.getenv("KAFKA_USERNAME", "")
        self.sasl_plain_password = os.getenv("KAFKA_PASSWORD", "")

    def clowder(self):  # pylint: disable=too-many-statements,too-many-branches
        """ "Configuration from Clowder."""
        cfg = app_common_python.LoadedConfig

        self.public_port = cfg.publicPort
        self.private_port = cfg.privatePort
        self.prometheus_port = cfg.metricsPort

        self.db_name = os.getenv("POSTGRESQL_DATABASE", cfg.database.name)
        self.db_user = os.getenv("POSTGRESQL_USER", cfg.database.username)
        self.db_pass = os.getenv("POSTGRESQL_PASSWORD", cfg.database.password)
        self.db_host = os.getenv("POSTGRESQL_HOST", cfg.database.hostname)
        self.db_port = int(os.getenv("POSTGRESQL_PORT", cfg.database.port))
        self.db_ssl_mode = cfg.database.sslMode or "prefer"
        self.db_ssl_root_cert_path = cfg.rds_ca() if cfg.database.rdsCa else "/opt/rds-ca/rds-cacert"

        self.cw_aws_access_key_id = cfg.logging.cloudwatch.accessKeyId
        self.cw_aws_secret_access_key = cfg.logging.cloudwatch.secretAccessKey
        self.cw_aws_region = cfg.logging.cloudwatch.region
        self.cw_aws_log_group = cfg.logging.cloudwatch.logGroup

        def get_topic(name):
            return app_common_python.KafkaTopics[name].name

        broker_cfg = cfg.kafka.brokers[0]
        self.bootstrap_servers = f"{broker_cfg.hostname}:{broker_cfg.port}"
        self.events_topic = get_topic("platform.inventory.events")
        self.evaluator_upload_topic = get_topic("vulnerability.evaluator.upload")
        self.evaluator_recalc_topic = get_topic("vulnerability.evaluator.recalc")
        self.evaluator_topics = [
            get_topic(topic) for topic in os.getenv("EVALUATOR_TOPIC", "vulnerability.evaluator.upload,vulnerability.evaluator.recalc").split(",")
        ]
        self.payload_tracker_topic = get_topic("platform.payload-status")
        self.advisor_results_topic = get_topic("platform.engine.results")
        self.remediation_updates_topic = get_topic("platform.remediation-updates.vulnerability")
        self.notifications_topic = get_topic("platform.notifications.ingress")
        self.evaluator_results_topic = get_topic("vulnerability.evaluator.results")
        self.listener_ingress_topic = get_topic("vulnerability.listener.ingress")

        def format_uri_scheme_kafka(authtype):
            """Return protocol uri scheme"""
            if authtype in [BrokerConfigAuthtypeEnum.SASL]:
                return "SASL_SSL"
            raise ConfigException("Unknown auth method for kafka")

        def format_ca_cert_kafka(cert):
            """Dump certificate into file, return name"""
            if cert:
                with tempfile.NamedTemporaryFile(delete=False) as cert_f:
                    cert_f.write(cert.encode("utf-8"))
                    return cert_f.name
            return None

        if self.kafka_ssl_enabled and broker_cfg.authtype is not None:
            self.security_protocol = format_uri_scheme_kafka(broker_cfg.authtype)
            self.kafka_ca_cert = format_ca_cert_kafka(broker_cfg.cacert)
            self.ssl_context = create_ssl_context(cafile=self.kafka_ca_cert)
            mechanism = broker_cfg.sasl.saslMechanism.lower()
            if mechanism == "scram-sha-512":
                self.sasl_mechanism = "SCRAM-SHA-512"
            elif mechanism == "scram-sha-256":
                self.sasl_mechanism = "SCRAM-SHA-256"
            elif mechanism == "plain":
                self.sasl_mechanism = "PLAIN"
            else:
                raise ConfigException("Unknown SASL mechanism for kafka")
            self.sasl_plain_username = broker_cfg.sasl.username
            self.sasl_plain_password = broker_cfg.sasl.password

        self.rbac_url = ""
        self.taskomatic_host = ""
        self.notificator_host = ""
        self.vmaas_host = ""
        use_vmaas_go = strtobool(os.getenv("USE_VMAAS_GO", "False"))
        webapp_name = "webapp-service"
        if use_vmaas_go:
            webapp_name = "webapp-go"
        for endpoint in cfg.endpoints:
            if endpoint.app == "rbac":
                self.rbac_url = f"http://{endpoint.hostname}:{endpoint.port}"
            elif endpoint.app == "vmaas" and webapp_name in endpoint.name:
                self.vmaas_host = f"http://{endpoint.hostname}:{endpoint.port}"
        for endpoint in cfg.privateEndpoints:
            if endpoint.app == "vulnerability-engine":
                if "taskomatic" in endpoint.name:
                    self.taskomatic_host = f"http://{endpoint.hostname}:{endpoint.port}"
                elif "notificator" in endpoint.name:
                    self.notificator_host = f"http://{endpoint.hostname}:{endpoint.port}"

        # TODO: Back office proxy (mocked) needs to be deployed to ephemeral too
        # when we are in ephemeral, we may want obtain bo_proxy url from app_common_python
        # otherwise (even in Prod?) we may want to use an env variable

    def legacy(self):
        """Configuration from environment variables."""
        self.db_name = os.getenv("POSTGRESQL_DATABASE", "vulnerability").strip()
        self.db_user = os.getenv("POSTGRESQL_USER", "ve_db_user_unknown").strip()
        self.db_pass = os.getenv("POSTGRESQL_PASSWORD", "ve_db_user_unknown_pwd").strip()
        self.db_host = os.getenv("POSTGRESQL_HOST", "ve_database").strip()
        self.db_port = int(os.getenv("POSTGRESQL_PORT", "5432").strip())
        self.db_ssl_mode = os.getenv("POSTGRESQL_SSL_MODE", "prefer")
        self.db_ssl_root_cert_path = os.getenv("POSTGRESQL_SSL_ROOT_CERT_PATH", "/opt/rds-ca/rds-cacert")

        self.cw_aws_access_key_id = os.environ.get("CW_AWS_ACCESS_KEY_ID")
        self.cw_aws_secret_access_key = os.environ.get("CW_AWS_SECRET_ACCESS_KEY")
        self.cw_aws_region = os.environ.get("AWS_REGION", "us-east-1")
        self.cw_aws_log_group = os.environ.get("CW_LOG_GROUP", "platform-dev")

        self.bootstrap_servers = f"{os.getenv('KAFKA_HOST', 've_kafka')}:{os.getenv('KAFKA_PORT', '9092')}"
        self.events_topic = os.getenv("EVENTS_TOPIC", "platform.inventory.events")
        self.evaluator_upload_topic = os.getenv("MESSAGE_TOPIC", "vulnerability.evaluator.upload")
        self.evaluator_recalc_topic = os.getenv("MESSAGE_TOPIC", "vulnerability.evaluator.recalc")
        self.evaluator_topics = os.getenv("EVALUATOR_TOPIC", "vulnerability.evaluator.upload,vulnerability.evaluator.recalc").split(",")
        self.payload_tracker_topic = os.getenv("PAYLOAD_TRACKER_TOPIC", "platform.payload-status")
        self.advisor_results_topic = os.getenv("ADVISOR_RESULTS_TOPIC", "platform.engine.results")
        self.remediation_updates_topic = os.getenv("REMEDIATION_UPDATES_TOPIC", "platform.remediation-updates.vulnerability")
        self.notifications_topic = os.getenv("NOTIFICATIONS_TOPIC", "platform.notifications.ingress")
        self.evaluator_results_topic = os.getenv("EVALUATOR_RESULTS_TOPIC", "vulnerability.evaluator.results")
        self.listener_ingress_topic = os.getenv("LISTENER_INGRESS_TOPIC", "vulnerability.listener.ingress")

        self.rbac_url = os.environ.get("RBAC_URL")
        self.vmaas_host = os.getenv("VMAAS_HOST", "http://vmaas_webapp:8080")
        self.taskomatic_host = os.getenv("TASKOMATIC_HOST", "http://ve_taskomatic:8000")
        self.notificator_host = os.getenv("NOTIFICATOR_HOST", "http://ve_notificator:8000")

        self.prometheus_port = os.getenv("PROMETHEUS_PORT", "")

        # SSL settings
        if self.kafka_ssl_enabled:
            self._set_kafka_ssl_legacy()

    def other(self):
        """Configuration which depend on clowder/legacy setting."""
        self.vmaas_vulnerabilities_endpoint = f"{self.vmaas_host}{self.vmaas_vulnerabilities_api}"
