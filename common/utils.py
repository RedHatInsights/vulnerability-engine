"""
Various utility functions.
"""

import os
from time import sleep
from datetime import datetime

from prometheus_client import Counter
import requests

from common.database_handler import DatabasePool, DatabasePoolConnection
from common.logging import get_logger

REQUEST_RETRIES = int(os.getenv("REQUEST_RETRIES", "3"))
SLACK_WEBHOOK = os.getenv('SLACK_WEBHOOK')
VULNERABILITY_ENV = os.getenv('VULNERABILITY_ENV', 'dev')
MINIMAL_SCHEMA = int(os.getenv("MINIMAL_SCHEMA", "0"))

LOGGER = get_logger(__name__)

# prometheus probes
# counts
VMAAS_RETURN_ERR = Counter('ve_evaluator_vmaas_return_errors', 'Number of non-200 RCs from VMaaS')
VMAAS_CNX_ERR = Counter('ve_evaluator_vmaas_cnx_errors', 'Number of connection-errors from VMaaS')
FUTURE_ERR = Counter('ve_future_errors', 'Number of Future errors')


def external_service_request(endpoint, data_json=None, session=None, method='POST', headers=None):
    """Sends request to external service"""
    default_headers = {'Content-type': 'application/json',
                       'Accept': 'application/json'}
    if headers and isinstance(headers, dict):
        default_headers.update(headers)

    tries = 0
    while True:
        if tries >= REQUEST_RETRIES:
            break
        try:
            if session:
                response = session.request(method=method, url=endpoint, headers=default_headers, json=data_json)
            else:
                response = requests.request(method=method, url=endpoint, headers=default_headers, json=data_json)
            if response.status_code == 200:
                return response.json()
            if response.status_code == 503:
                LOGGER.info("External service temporarily unavailable, retrying...")
            else:
                tries += 1
                VMAAS_RETURN_ERR.inc()
                LOGGER.error("Error during %s request to endpoint %s: HTTP %s, %s",
                             method, endpoint, response.status_code, response.text)
                LOGGER.debug("JSON: %s", str(data_json))
        except requests.exceptions.RequestException:
            tries += 1
            VMAAS_CNX_ERR.inc()
            LOGGER.exception("Error calling external service: ")
        sleep(1)
    return None


def on_thread_done(future):
    """Callback to call after ThreadPoolExecutor worker finishes."""
    try:
        future.result()
    except Exception:  # pylint: disable=broad-except
        FUTURE_ERR.inc()
        LOGGER.exception("Future %s hit exception: ", future)


def str_or_none(value):
    """Return string or None i value not exist"""
    return str(value) if value else None


def format_datetime(datetime_obj):
    """Convert datetime format to string ISO format"""
    if isinstance(datetime_obj, datetime):
        return datetime_obj.isoformat()
    return str(datetime_obj) if datetime_obj else None


def send_msg_to_payload_tracker(producer, msg_dict, status, status_msg=None, loop=None):
    """prepare and send message to payload-tracker"""
    request_id = msg_dict['platform_metadata'].get('request_id')
    if not request_id:
        return
    tracking_payload = {
        'service': 'vulnerability',
        'account': msg_dict['host']['account'],
        'request_id': request_id,
        'inventory_id': msg_dict["host"]["id"],
        'status': status,
        'date': str(datetime.utcnow())}
    if status_msg:
        tracking_payload['status_msg'] = status_msg
    producer.send(tracking_payload, loop=loop)
    LOGGER.debug('Sent message to topic %s: %s', producer.topic, str(tracking_payload))


def send_remediations_update(producer, inventory_id: str, cves: list, loop=None) -> None:
    """
    Send a message in format of remediations application updates using given Kafka producer

    Args:
        producer (MQWriter): Kafka producer
        inventory_id (str): Inventory ID
        cves (list): List of CVE identifiers
        loop (asyncio.event_loop, optional): asyncio event loop to be used by producer
    """
    msg = {
        'host_id': inventory_id,
        'issues': ['vulnerabilities:{}'.format(cve) for cve in cves]
    }
    producer.send(msg, loop=loop)


def send_slack_notification(message):
    """If SLACK_WEBHOOK is set, sends notification to Slack"""
    if SLACK_WEBHOOK:
        requests.post(SLACK_WEBHOOK, json={'text': '[{}] {}'.format(VULNERABILITY_ENV, message)}, headers={'Content-type': 'application/json'})


def ensure_minimal_schema_version():
    """Ensure that database schema is up-to-date, wait if it's not."""
    with DatabasePool(1):
        with DatabasePoolConnection() as conn:
            with conn.cursor() as cur:
                while True:
                    cur.execute("SELECT version FROM db_version WHERE name = 'schema_version'")
                    current_schema = int(cur.fetchone()[0])
                    if current_schema >= MINIMAL_SCHEMA:
                        LOGGER.info("Current schema version: %s, minimal required: %s, OK", current_schema, MINIMAL_SCHEMA)
                        return
                    LOGGER.warning("Current schema version: %s, minimal required: %s, waiting...", current_schema, MINIMAL_SCHEMA)
                    sleep(10)


def validate_kafka_msg(msg_dict, required_fields, default_type="unknown"):
    """Check if all required fields are in msg_dict of kafka message."""
    for key, required_inner_keys in required_fields.items():
        if key not in msg_dict:
            LOGGER.warning("Missing key '%s' in msg_dict, skipping %s.", key, msg_dict.get("type", default_type))
            return False
        inner_msg_dict = msg_dict[key]
        for inner_key in required_inner_keys:
            if isinstance(inner_key, dict):
                if not validate_kafka_msg(inner_msg_dict, inner_key, default_type=msg_dict.get("type", default_type)):
                    return False
            elif inner_msg_dict is None or inner_key not in inner_msg_dict:
                LOGGER.warning("Missing key '%s.%s' in msg_dict, skipping %s.", key, inner_key, msg_dict.get("type", default_type))
                return False
    return True
