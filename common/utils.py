"""
Various utility functions.
"""

import os
from time import sleep
from datetime import datetime

from prometheus_client import Counter
import requests

from common.logging import get_logger

VMAAS_REQUEST_RETRIES = int(os.getenv("VMAAS_REQUEST_RETRIES", "3"))
SLACK_WEBHOOK = os.getenv('SLACK_WEBHOOK')
VULNERABILITY_ENV = os.getenv('VULNERABILITY_ENV', 'dev')

LOGGER = get_logger(__name__)

# prometheus probes
# counts
VMAAS_RETURN_ERR = Counter('ve_evaluator_vmaas_return_errors', 'Number of non-200 RCs from VMaaS')
VMAAS_CNX_ERR = Counter('ve_evaluator_vmaas_cnx_errors', 'Number of connection-errors from VMaaS')
FUTURE_ERR = Counter('ve_future_errors', 'Number of Future errors')


def vmaas_post_request(endpoint, data_json, session=None):
    """Sends request to VMAAS"""
    headers = {'Content-type': 'application/json',
               'Accept': 'application/json'}
    tries = 0
    while True:
        if tries >= VMAAS_REQUEST_RETRIES:
            break
        try:
            if session:
                response = session.post(endpoint, json=data_json, headers=headers)
            else:
                response = requests.post(endpoint, json=data_json, headers=headers)
            if response.status_code == 200:
                return response.json()
            if response.status_code == 503:
                LOGGER.info("VMAAS temporarily unavailable, retrying...")
            else:
                tries += 1
                VMAAS_RETURN_ERR.inc()
                LOGGER.error("Error during request to VMaaS endpoint %s: HTTP %s, %s",
                             endpoint, response.status_code, response.text)
                LOGGER.debug("JSON: %s", str(data_json))
        except requests.exceptions.RequestException:
            tries += 1
            VMAAS_CNX_ERR.inc()
            LOGGER.exception("Error calling VMAAS: ")
        sleep(1)
    return None


def on_thread_done(future):
    """Callback to call after ThreadPoolExecutor worker finishes."""
    try:
        future.result()
    except Exception:  # pylint: disable=broad-except
        FUTURE_ERR.inc()
        LOGGER.exception("Future %s hit exception: ", future)


def str_or_none(value):
    """Return string or None i value not exist"""
    return str(value) if value else None


def format_datetime(datetime_obj):
    """Convert datetime format to string ISO format"""
    if isinstance(datetime_obj, datetime):
        return datetime_obj.isoformat()
    return str(datetime_obj) if datetime_obj else None


def send_msg_to_payload_tracker(producer, msg_dict, status, status_msg=None, loop=None):
    """prepare and send message to payload-tracker"""
    request_id = msg_dict['platform_metadata'].get('request_id')
    if not request_id:
        return
    tracking_payload = {
        'service': 'vulnerability',
        'account': msg_dict['host']['account'],
        'request_id': request_id,
        'inventory_id': msg_dict["host"]["id"],
        'status': status,
        'date': str(datetime.utcnow())}
    if status_msg:
        tracking_payload['status_msg'] = status_msg
    producer.send(tracking_payload, loop=loop)
    LOGGER.info('Sent message to topic %s: %s', producer.topic, str(tracking_payload))


def send_remediations_update(producer, inventory_id: str, cves: list, loop=None) -> None:
    """
    Send a message in format of remediations application updates using given Kafka producer

    Args:
        producer (MQWriter): Kafka producer
        inventory_id (str): Inventory ID
        cves (list): List of CVE identifiers
        loop (asyncio.event_loop, optional): asyncio event loop to be used by producer
    """
    msg = {
        'host_id': inventory_id,
        'issues': ['vulnerabilities:{}'.format(cve) for cve in cves]
    }
    producer.send(msg, loop=loop)


def send_slack_notification(message):
    """If SLACK_WEBHOOK is set, sends notification to Slack"""
    if SLACK_WEBHOOK:
        requests.post(SLACK_WEBHOOK, json={'text': '[{}] {}'.format(VULNERABILITY_ENV, message)}, headers={'Content-type': 'application/json'})
