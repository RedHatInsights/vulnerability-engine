"""
Various utility functions.
"""

import os
from time import sleep
from datetime import datetime

from prometheus_client import Counter
import requests

from common.database_handler import DatabasePool, DatabasePoolConnection
from common.logging import get_logger

REQUEST_RETRIES = int(os.getenv("REQUEST_RETRIES", "3"))
SLACK_WEBHOOK = os.getenv('SLACK_WEBHOOK')
VULNERABILITY_ENV = os.getenv('VULNERABILITY_ENV', 'dev')
MINIMAL_SCHEMA = int(os.getenv("MINIMAL_SCHEMA", "0"))

LOGGER = get_logger(__name__)

# prometheus probes
# counts
VMAAS_RETURN_ERR = Counter('ve_evaluator_vmaas_return_errors', 'Number of non-200 RCs from VMaaS')
VMAAS_CNX_ERR = Counter('ve_evaluator_vmaas_cnx_errors', 'Number of connection-errors from VMaaS')
FUTURE_ERR = Counter('ve_future_errors', 'Number of Future errors')


def external_service_request(endpoint, data_json=None, session=None, method='POST', headers=None, service_access=None, **kwargs):
    """Sends request to external service"""
    # pylint: disable=too-many-branches
    default_headers = {'Content-type': 'application/json',
                       'Accept': 'application/json'}
    if headers and isinstance(headers, dict):
        default_headers.update(headers)

    tries = 0
    while True:
        if tries >= REQUEST_RETRIES:
            break
        try:
            if session:
                response = session.request(method=method, url=endpoint, headers=default_headers, json=data_json, timeout=5, **kwargs)
            else:
                response = requests.request(method=method, url=endpoint, headers=default_headers, json=data_json, timeout=5, **kwargs)
            if response.status_code == 200:
                if service_access is not None:
                    service_access.status = True
                return response.json()
            if response.status_code >= 500:
                if service_access is not None:
                    service_access.status = False
                    LOGGER.info("External service temporarily unavailable.")
                    break
                LOGGER.info("External service temporarily unavailable, retrying...")
                sleep(1)
            else:
                tries += 1
                VMAAS_RETURN_ERR.inc()
                LOGGER.error("Error during %s request to endpoint %s: HTTP %s, %s",
                             method, endpoint, response.status_code, response.text)
                LOGGER.debug("JSON: %s", str(data_json))
                # Do not retry for 4xx HTTP codes
                if 400 <= response.status_code < 500:
                    if service_access is not None and response.status_code == 404:
                        service_access.status = True
                    break
        except requests.exceptions.Timeout:
            VMAAS_CNX_ERR.inc()
            LOGGER.exception("Timeout error calling external service: %s: ", endpoint)
            break
        except requests.exceptions.RequestException:
            tries += 1
            VMAAS_CNX_ERR.inc()
            LOGGER.exception("Error calling external service: ")
    return None


def on_thread_done(future):
    """Callback to call after ThreadPoolExecutor worker finishes."""
    try:
        future.result()
    except Exception:  # pylint: disable=broad-except
        FUTURE_ERR.inc()
        LOGGER.exception("Future %s hit exception: ", future)


def str_or_none(value):
    """Return string or None i value not exist"""
    return str(value) if value else None


def format_datetime(datetime_obj):
    """Convert datetime format to string ISO format"""
    if isinstance(datetime_obj, datetime):
        return datetime_obj.isoformat()
    return str(datetime_obj) if datetime_obj else None


def send_msg_to_payload_tracker(producer, msg_dict, status, status_msg=None, loop=None, service="vulnerability-vmaas"):
    """prepare and send message to payload-tracker"""
    request_id = msg_dict['platform_metadata'].get('request_id')
    if not request_id:
        return
    tracking_payload = {
        'service': service,
        'account': msg_dict['host']['account'],
        'request_id': request_id,
        'inventory_id': msg_dict["host"]["id"],
        'status': status,
        'date': str(datetime.utcnow())}
    if status_msg:
        tracking_payload['status_msg'] = status_msg
    producer.send(tracking_payload, loop=loop)
    LOGGER.debug('Sent message to topic %s: %s', producer.topic, str(tracking_payload))


def send_remediations_update(producer, inventory_id: str, cves: list, loop=None) -> None:
    """
    Send a message in format of remediations application updates using given Kafka producer

    Args:
        producer (MQWriter): Kafka producer
        inventory_id (str): Inventory ID
        cves (list): List of CVE identifiers
        loop (asyncio.event_loop, optional): asyncio event loop to be used by producer
    """
    msg = {
        'host_id': inventory_id,
        'issues': ['vulnerabilities:{}'.format(cve) for cve in cves]
    }
    producer.send(msg, loop=loop)


def send_slack_notification(message):
    """If SLACK_WEBHOOK is set, sends notification to Slack"""
    if SLACK_WEBHOOK:
        requests.post(SLACK_WEBHOOK, json={'text': '[{}] {}'.format(VULNERABILITY_ENV, message)}, headers={'Content-type': 'application/json'})


def ensure_minimal_schema_version():
    """Ensure that database schema is up-to-date, wait if it's not."""
    with DatabasePool(1):
        with DatabasePoolConnection() as conn:
            with conn.cursor() as cur:
                while True:
                    cur.execute("SELECT version FROM db_version WHERE name = 'schema_version'")
                    current_schema = int(cur.fetchone()[0])
                    if current_schema >= MINIMAL_SCHEMA:
                        LOGGER.info("Current schema version: %s, minimal required: %s, OK", current_schema, MINIMAL_SCHEMA)
                        return
                    LOGGER.warning("Current schema version: %s, minimal required: %s, waiting...", current_schema, MINIMAL_SCHEMA)
                    sleep(10)


def validate_kafka_msg(msg_dict, required_fields, default_type="unknown"):
    """Check if all required fields are in msg_dict of kafka message.

       All fields are type of dict, where each key is represented by string,
       or tuple. In tuple the first value is key string and second is
       boolean value if key is nullable.
    """
    for key, required_inner_keys in required_fields.items():
        if key not in msg_dict:
            LOGGER.warning("Missing key '%s' in msg_dict, skipping %s.", key, msg_dict.get("type", default_type))
            return False
        inner_msg_dict = msg_dict[key]
        for inner_key in required_inner_keys:
            if isinstance(inner_key, dict):
                if not validate_kafka_msg(inner_msg_dict, inner_key, default_type=msg_dict.get("type", default_type)):
                    return False
            else:
                key = None
                is_nullable = True
                if isinstance(inner_key, tuple) and inner_key:
                    try:
                        key, is_nullable = inner_key
                    except ValueError:
                        key = inner_key[0]
                else:
                    key = inner_key
                if inner_msg_dict is None or key not in inner_msg_dict or (inner_msg_dict[key] is None and not is_nullable):
                    LOGGER.warning("Missing key '%s.%s' in msg_dict, skipping %s.", key, inner_key, msg_dict.get("type", default_type))
                    return False
    return True
