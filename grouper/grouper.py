"""
Vulnerability grouper pod, groups the messages from listener (inventory/evaluator uploads),
and attempts to pair them.
"""
import asyncio
import json
import signal

from aiokafka.structs import ConsumerRecord

from .common import CFG
from .common import GrouperMessageType
from .queue import GrouperQueue
from common.logging import get_logger
from common.logging import init_logging
from common.mqueue import MQReader
from common.status_app import create_status_app
from common.status_app import create_status_runner
from common.utils import create_task_and_log

LOGGER = get_logger(__name__)


class Grouper:
    """
    Grouper class
    """

    def __init__(self, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self.evaluator_inventory_topic = MQReader(CFG.grouper_inventory_topic)
        self.evaluator_advisor_topic = MQReader(CFG.grouper_advisor_topic)

        self.inventory_task = None
        self.advisor_task = None

        self.queue = GrouperQueue(loop)
        self.loop = loop

    async def init(self):
        """Async constructor"""
        await self.queue.init()

    async def stop(self):
        """Terminates the grouper execution"""
        LOGGER.info("Signal recieved, stopping grouper.")
        self.inventory_task.cancel()
        self.advisor_task.cancel()
        await self.evaluator_advisor_topic.stop()
        await self.evaluator_inventory_topic.stop()
        self.loop.stop()

    async def consume_message(self, msg: ConsumerRecord, unlock: asyncio.BoundedSemaphore):
        """Consume and parse single message"""
        try:
            msg_dict = json.loads(msg.value.decode("utf-8"))
        except json.decoder.JSONDecodeError:
            LOGGER.error("cannot parse incoming kafka message: %s", msg)
            unlock.release()
            return

        inventory_id = msg_dict["host"]["id"]
        org_id = msg_dict["host"]["org_id"]
        changed = msg_dict["host"]["changed"]

        reporter = msg_dict["host"].get("reporter", "")

        try:
            msg_type = GrouperMessageType(msg_dict.get("type"))
        except ValueError:
            LOGGER.error("received unknown message type: %s", msg_type)
            unlock.release()
            return

        if msg_type is GrouperMessageType.INVENTORY_UPLOAD:
            self.queue.push_inventory_msg(
                org_id, inventory_id, reporter, changed, msg_dict.get("platform_metadata", {}).get("request_id", "")
            )
        elif msg_type is GrouperMessageType.ADVISOR_UPLOAD:
            self.queue.push_advisor_msg(
                org_id, inventory_id, reporter, changed, msg_dict.get("platform_metadata", {}).get("request_id", "")
            )

    async def _start_grouping_inventory(self):
        """Start of the grouping inventory uploads"""
        async for msg in self.evaluator_inventory_topic.client:
            await self.queue.max_inventory_msgs.acquire()
            await self.consume_message(msg, self.queue.max_inventory_msgs)

    async def _start_grouping_advisor(self):
        """Start of the grouping advisor uploads"""
        async for msg in self.evaluator_advisor_topic.client:
            await self.queue.max_advisor_msgs.acquire()
            await self.consume_message(msg, self.queue.max_advisor_msgs)

    async def run(self):
        """Start of the grouper"""
        await self.evaluator_inventory_topic.start()
        await self.evaluator_advisor_topic.start()

        self.inventory_task = create_task_and_log(self._start_grouping_inventory(), LOGGER, self.loop)
        self.advisor_task = create_task_and_log(self._start_grouping_advisor(), LOGGER, self.loop)

        await asyncio.gather(self.inventory_task, self.advisor_task)

        await self.stop()


def main():
    """Start service"""
    init_logging()

    loop = asyncio.get_event_loop()
    status_app = create_status_app(LOGGER)
    _, status_site = create_status_runner(status_app, int(CFG.prometheus_port), LOGGER, loop)
    loop.run_until_complete(status_site.start())

    LOGGER.info("Starting kafka grouper service")

    grouper = Grouper(loop)

    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for sig in signals:
        loop.add_signal_handler(sig, lambda sig=sig: loop.create_task(grouper.stop()))

    loop.create_task(grouper.run())
    loop.run_forever()


if __name__ == "__main__":
    main()
