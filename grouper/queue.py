"""
Grouper Queue, groups advisor and inventory msgs, and sends the grouped
message to evaluator
"""
import asyncio
from typing import Dict

from common.mqueue import MQWriter
from common.logging import get_logger
from common.utils import create_task_and_log, send_msg_to_payload_tracker
from .common import (QueueItem, CFG, QUEUE_SIZE, BoundedSemaphorePrometheus, 
                     ADVISOR_QUEUE_SIZE, INVENTORY_QUEUE_SIZE)

LOGGER = get_logger(__name__)


class GrouperQueue:
    """Listener async queue for message waiting"""

    def __init__(self, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self._queue: Dict[str, QueueItem] = {}

        self.payload_tracker = MQWriter(CFG.payload_tracker_topic)
        self.evaluator = MQWriter(CFG.evaluator_upload_topic)

        self.max_advisor_msgs = BoundedSemaphorePrometheus(CFG.max_loaded_grouper_msgs, ADVISOR_QUEUE_SIZE)
        self.max_inventory_msgs = BoundedSemaphorePrometheus(CFG.max_loaded_grouper_msgs, INVENTORY_QUEUE_SIZE)

        self.loop = loop

    async def init(self):
        """Async constructor"""
        await self.payload_tracker.start()
        await self.evaluator.start()

    async def stop(self):
        """Stops the queue"""
        await self.payload_tracker.stop()
        await self.evaluator.stop()

    def push_inventory_msg(self, org_id: str, inventory_id: str, inventory_changed: bool, request_id: str):
        """Push inventory upload message to queue"""
        is_updated = False

        item = self._queue.get(inventory_id)
        if not item:
            LOGGER.info("pushing listener upload to queue for system: %s, org_id: %s", inventory_id, org_id)
            item = QueueItem(True, inventory_changed, False, False, request_id)
            self._queue[inventory_id] = item
        else:
            is_updated = True
            if item.inventory_upload:
                LOGGER.info("updating existing listener upload in queue for system: %s, org_id: %s", inventory_id, org_id)
                self.max_inventory_msgs.release()
            else:
                LOGGER.info("updating new listener upload in queue for system: %s, org_id: %s", inventory_id, org_id)

            item.inventory_upload = True
            item.inventory_changed = inventory_changed
            item.request_id = request_id

        if item.inventory_upload and item.advisor_upload:
            LOGGER.info("obtained both uploads for system: %s, account: %s, releasing lock", inventory_id, org_id)
            item.second_upload_event.set()
        elif not is_updated:
            QUEUE_SIZE.inc()
            send_msg_to_payload_tracker(self.payload_tracker, {"platform_metadata": {"requested_id": item.request_id}},
                                        "received", loop=self.loop)
            create_task_and_log(self._start_item_processing(org_id, inventory_id), LOGGER, self.loop)

    def push_advisor_msg(self, org_id: str, inventory_id: str, advisor_changed: bool, request_id: str):
        """Push advisor message to queue"""
        is_updated = False

        item = self._queue.get(inventory_id)
        if not item:
            LOGGER.info("pushing advisor upload to queue for system: %s, org_id: %s", inventory_id, org_id)
            item = QueueItem(False, False, True, advisor_changed, request_id)
            self._queue[inventory_id] = item
        else:
            is_updated = True
            if item.advisor_upload:
                LOGGER.info("updating advisor upload in queue for system: %s, org_id: %s", inventory_id, org_id)
                self.max_advisor_msgs.release()
            else:
                LOGGER.info("updating new advisor upload in queue for system: %s, org_id: %s", inventory_id, org_id)

            item.advisor_upload = True
            item.advisor_changed = advisor_changed
            item.request_id = request_id

        if item.inventory_upload and item.advisor_upload:
            LOGGER.info("obtained both messages for system: %s, account: %s, releasing lock", inventory_id, org_id)
            item.second_upload_event.set()
        elif not is_updated:
            QUEUE_SIZE.inc()
            send_msg_to_payload_tracker(self.payload_tracker, {"platform_metadata": {"requested_id": item.request_id}},
                                        "received", loop=self.loop)
            create_task_and_log(self._start_item_processing(org_id, inventory_id), LOGGER, self.loop)

    async def _start_item_processing(self, org_id: str, inventory_id: str):
        """Single queue item waiting coroutine"""
        item = self._queue[inventory_id]
        LOGGER.debug("starting waiting for %s msg for system: %s, account: %s", "inventory" if item.advisor_upload else "advisor",
                     inventory_id, org_id)

        try:
            await asyncio.wait_for(item.second_upload_event.wait(), CFG.grouper_messages_timeout_sec)
        except asyncio.TimeoutError:
            LOGGER.info("timeouted waiting for message for system: %s, account: %s", inventory_id, org_id)
        self._queue.pop(inventory_id, None)

        if item.inventory_upload:
            self.max_inventory_msgs.release()
        if item.advisor_upload:
            self.max_advisor_msgs.release()

        await self._send_for_evaluation(item, org_id, inventory_id)

        QUEUE_SIZE.dec()

    async def _send_for_evaluation(self, item: QueueItem, org_id: str, inventory_id: str):
        """Sends message to evaluate a system"""
        if (not item.inventory_changed and not item.advisor_changed) and not CFG.disable_optimisation:
            LOGGER.info("skipping evaluation, system not changed: %s, org_id: %s", inventory_id, org_id)
            send_msg_to_payload_tracker(self.payload_tracker, {"platform_metadata": {"requested_id": item.request_id}},
                                        "success", status_msg="unchanged system and not evaluated", loop=self.loop)
            return

        LOGGER.info("sending upload message to evaluator: %s, org_id: %s", inventory_id, org_id)
        msg = {
            "type": "upload_new_file",
            "host": {
                "id": inventory_id,
                "org_id": org_id,
            },
            "platform_metadata": {
                "request_id": item.request_id
            }
        }
        self.evaluator.send(msg)
