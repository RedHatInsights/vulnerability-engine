"""
Grouper Queue, groups advisor and inventory msgs, and sends the grouped
message to evaluator
"""
import asyncio
from datetime import datetime
from datetime import timezone
from typing import Dict

from .common import ADVISOR_QUEUE_SIZE
from .common import BoundedSemaphorePrometheus
from .common import CFG
from .common import CHANGED_SYSTEM
from .common import INVENTORY_QUEUE_SIZE
from .common import PAIR_HIT
from .common import PAIR_MISS
from .common import QUEUE_SIZE
from .common import QueueItem
from .common import UNCHANGED_SYSTEM
from common.logging import get_logger
from common.mqueue import MQWriter
from common.utils import create_task_and_log
from common.utils import send_msg_to_payload_tracker

LOGGER = get_logger(__name__)


class GrouperQueue:
    """Listener async queue for message waiting"""

    def __init__(self, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self._queue: Dict[str, QueueItem] = {}

        self.payload_tracker = MQWriter(CFG.payload_tracker_topic)
        self.evaluator = MQWriter(CFG.evaluator_upload_topic)

        self.max_advisor_msgs = BoundedSemaphorePrometheus(CFG.max_loaded_grouper_msgs, ADVISOR_QUEUE_SIZE)
        self.max_inventory_msgs = BoundedSemaphorePrometheus(CFG.max_loaded_grouper_msgs, INVENTORY_QUEUE_SIZE)

        self.loop = loop

    async def init(self):
        """Async constructor"""
        await self.payload_tracker.start()
        await self.evaluator.start()

    async def stop(self):
        """Stops the queue"""
        await self.payload_tracker.stop()
        await self.evaluator.stop()

    def push_inventory_msg(self, org_id: str, inventory_id: str, reporter: str, inventory_changed: bool, request_id: str):
        """Push inventory upload message to queue"""
        is_updated = False

        item = self._queue.get(inventory_id)
        if not item:
            LOGGER.info("pushing listener upload to queue for system: %s, org_id: %s", inventory_id, org_id)
            item = QueueItem(True, inventory_changed, False, False, request_id)
            self._queue[inventory_id] = item
        else:
            is_updated = True
            if item.inventory_upload:
                LOGGER.info("updating existing listener upload in queue for system: %s, org_id: %s", inventory_id, org_id)
                self.max_inventory_msgs.release()
            else:
                LOGGER.info("updating new listener upload in queue for system: %s, org_id: %s", inventory_id, org_id)

            item.inventory_upload = True
            item.inventory_changed = inventory_changed
            item.request_id = request_id

        if item.inventory_upload and item.advisor_upload:
            LOGGER.info("obtained both uploads for system: %s, account: %s, releasing lock", inventory_id, org_id)
            item.second_upload_event.set()
        elif not is_updated:
            QUEUE_SIZE.inc()
            create_task_and_log(self._start_item_processing(org_id, inventory_id, reporter), LOGGER, self.loop)

    def push_advisor_msg(self, org_id: str, inventory_id: str, reporter: str, advisor_changed: bool, request_id: str):
        """Push advisor message to queue"""
        is_updated = False

        item = self._queue.get(inventory_id)
        if not item:
            LOGGER.info("pushing advisor upload to queue for system: %s, org_id: %s", inventory_id, org_id)
            item = QueueItem(False, False, True, advisor_changed, request_id)
            self._queue[inventory_id] = item
        else:
            is_updated = True
            if item.advisor_upload:
                LOGGER.info("updating advisor upload in queue for system: %s, org_id: %s", inventory_id, org_id)
                self.max_advisor_msgs.release()
            else:
                LOGGER.info("updating new advisor upload in queue for system: %s, org_id: %s", inventory_id, org_id)

            item.advisor_upload = True
            item.advisor_changed = advisor_changed
            item.request_id = request_id

        if item.inventory_upload and item.advisor_upload:
            LOGGER.info("obtained both messages for system: %s, account: %s, releasing lock", inventory_id, org_id)
            item.second_upload_event.set()
        elif not is_updated:
            QUEUE_SIZE.inc()
            create_task_and_log(self._start_item_processing(org_id, inventory_id, reporter), LOGGER, self.loop)

    async def _start_item_processing(self, org_id: str, inventory_id: str, reporter: str):
        """Single queue item waiting coroutine"""
        item = self._queue[inventory_id]

        # RHSM systems do not need to wait for advisor message
        if reporter == "rhsm-system-profile-bridge":
            LOGGER.debug(
                "reporter %s skipped waiting for %s message for system: %s, account: %s",
                reporter,
                "inventory" if item.advisor_upload else "advisor",
                inventory_id,
                org_id,
            )
        else:
            LOGGER.debug(
                "starting waiting for %s msg for system: %s, account: %s",
                "inventory" if item.advisor_upload else "advisor",
                inventory_id,
                org_id,
            )

            try:
                await asyncio.wait_for(item.second_upload_event.wait(), CFG.grouper_messages_timeout_sec)
                PAIR_HIT.inc()
            except asyncio.TimeoutError:
                LOGGER.info("timing out while waiting for message for system: %s, account: %s", inventory_id, org_id)
                PAIR_MISS.inc()
        self._queue.pop(inventory_id, None)

        if item.inventory_upload:
            self.max_inventory_msgs.release()
        if item.advisor_upload:
            self.max_advisor_msgs.release()

        await self._send_for_evaluation(item, org_id, inventory_id)

        QUEUE_SIZE.dec()

    async def _send_for_evaluation(self, item: QueueItem, org_id: str, inventory_id: str):
        """Sends message to evaluate a system"""
        msg = {
            "type": "upload_new_file",
            "host": {
                "id": inventory_id,
                "org_id": org_id,
            },
            "platform_metadata": {"request_id": item.request_id},
            "timestamp": str(datetime.now(timezone.utc)),
        }
        if (not item.inventory_changed and not item.advisor_changed) and not CFG.disable_optimisation:
            UNCHANGED_SYSTEM.inc()
            LOGGER.info("skipping evaluation, system not changed: %s, org_id: %s", inventory_id, org_id)
            send_msg_to_payload_tracker(
                self.payload_tracker, msg, "success", status_msg="unchanged system, not sending to evaluator", loop=self.loop
            )
            return

        CHANGED_SYSTEM.inc()
        LOGGER.info("sending upload message to evaluator: %s, org_id: %s", inventory_id, org_id)
        send_msg_to_payload_tracker(
            self.payload_tracker, msg, "processing", status_msg="changed system, sending to evaluator", loop=self.loop
        )
        self.evaluator.send(msg)
