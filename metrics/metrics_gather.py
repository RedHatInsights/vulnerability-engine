#!/usr/bin/env python3
"""
Gathers metrics to show feature and product usage.
"""

import io
import os
import time
import datetime

from operator import itemgetter

from common.backoffice_proxy import send_mail
from common.database_handler import DatabasePool, DatabasePoolConnection, NamedCursor
from metrics.stats_manager import StatsManager

DEBUG = os.getenv('DEBUG', None)
SMTP_HOST = os.getenv('SMTP_HOST')
SMTP_PASS = os.getenv('SMTP_PASS')
SMTP_USER = os.getenv('SMTP_USER')
EMAIL_FROM = os.getenv('EMAIL_FROM')
EMAIL_MONTHLY_TO = os.getenv('EMAIL_MONTHLY_TO', None)
EMAIL_PARTIAL_MONTH_TO = os.getenv('EMAIL_PARTIAL_MONTH_TO', None)
EXCLUDE_ACCOUNTS = os.getenv('EXCLUDE_ACCOUNTS', None)

MAX_RESULTS_COUNT = 20
METRIC_LABEL = {'filtered_delta': 'Non-Red Hat Accounts Delta',
                'delta': 'All Accounts Delta',
                'filtered_total': 'Non-Red Hat Accounts Total',
                'total': 'All Accounts Total'}


class MetricsGatherer():
    """Metrics Gatherer"""

    def __init__(self, stats_mgr, exclude_accounts_text=None, debug=False):
        self.debug = debug
        self.stats_mgr = stats_mgr
        self.exclude_accounts = self.process_exclude_accounts_text(exclude_accounts_text)
        if self.debug:
            print("Exclude accounts: %s\n" % sorted(self.exclude_accounts))
        self.today = datetime.date.today()

    @staticmethod
    def process_exclude_accounts_text(exclude_accounts_text):
        """Retrieve list of exclude accounts from env var"""
        exclude_accounts = set()
        if exclude_accounts_text:
            excludesinput = io.StringIO(exclude_accounts_text)
            lines = excludesinput.readlines()
            for line in lines:
                account = line.split('#')[0].strip()
                if account:
                    exclude_accounts.add(account)
        return exclude_accounts

    def query_cve_status_usage(self, connection):
        """Query for cve status usage."""
        start = time.time()
        cve_status_usage = []
        if self.debug:
            print("generating CVE-status usage report...\n")
            print("  account    # CVEs with status set")
            print("------------ ----------------------")
        with NamedCursor(connection) as cur:
            cur.execute("""SELECT ra.name,
                                  count(ra.name)
                             FROM cve_account_data cad
                             JOIN rh_account ra
                               ON cad.rh_account_id = ra.id
                            WHERE cad.status_id != 0
                         GROUP BY ra.name
                         ORDER BY count(ra.name) DESC""")
            for row in cur.fetchall():
                cve_status_usage.append(row)
                if self.debug:
                    print(f"{row[0]:12s} {row[1]}")
        if self.debug:
            print("-----------------------------------")
        print("CVE-status usage query took %s milliseconds\n" % str((time.time() - start) * 1000))
        return cve_status_usage

    def query_system_cve_status_usage(self, connection):
        """Query for system cve status usage."""
        start = time.time()
        system_cve_status_usage = []
        if self.debug:
            print("generating system-CVE-status usage report...\n")
            print("  account    # system-CVEs with status set")
            print("------------ -----------------------------")
        with NamedCursor(connection) as cur:
            cur.execute("""SELECT ra.name,
                                  count(ra.name)
                             FROM system_vulnerabilities sv
                             JOIN system_platform sp
                               ON sv.system_id = sp.id
                             JOIN rh_account ra
                               ON sp.rh_account_id = ra.id
                            WHERE sv.status_id != 0
                              AND sp.opt_out = false
                              AND sp.stale = false
                              AND sp.when_deleted IS NULL
                              AND sv.rh_account_id = sp.rh_account_id
                         GROUP BY ra.name
                         ORDER BY count(ra.name) DESC""")
            for row in cur.fetchall():
                system_cve_status_usage.append(row)
                if self.debug:
                    print(f"{row[0]:12s} {row[1]}")
        if self.debug:
            print("------------------------------------------")
        print("system-CVE-status usage query took %s milliseconds\n" % str((time.time() - start) * 1000))
        return system_cve_status_usage

    def query_cve_business_risk_usage(self, connection):
        """Query for cve business risk usage."""
        start = time.time()
        cve_business_risk_usage = []
        if self.debug:
            print("generating CVE-business risk usage report...\n")
            print("  account    # CVEs with business risk set")
            print("------------ -----------------------------")
        with NamedCursor(connection) as cur:
            cur.execute("""SELECT ra.name,
                                  count(ra.name)
                             FROM cve_account_data cad
                             JOIN rh_account ra
                               ON cad.rh_account_id = ra.id
                            WHERE cad.business_risk_id != 0
                         GROUP BY ra.name
                         ORDER BY count(ra.name) DESC""")
            for row in cur.fetchall():
                cve_business_risk_usage.append(row)
                if self.debug:
                    print(f"{row[0]:12s} {row[1]}")
        if self.debug:
            print("------------------------------------------")
        print("CVE-business risk usage query took %s milliseconds\n" % str((time.time() - start) * 1000))
        return cve_business_risk_usage

    @staticmethod
    def metrics_tuple_list_to_map(tuple_list):
        """Given a tuple list, return the metrics values in map keyed on account."""
        to_map = {}
        for (key, value) in tuple_list:
            to_map[key] = value
        return to_map

    @staticmethod
    def db_to_tuples(tuples):
        """Transfers db tuples to dict with metrics tuples"""
        cve_status_tup = []
        system_cve_status_tup = []
        cve_br_tup = []

        for tup in tuples:
            cve_status_tup.append((tup[0], tup[1]))
            system_cve_status_tup.append((tup[0], tup[2]))
            cve_br_tup.append((tup[0], tup[3]))

        return {"cve_status_usage": cve_status_tup,
                "system_cve_status_usage": system_cve_status_tup,
                "cve_business_risk_usage": cve_br_tup}

    def compare_tuple_lists(self, prev_tuples, cur_tuples):
        """Compare two metrics lists and return sorted list of metric deltas."""
        prev_map = self.metrics_tuple_list_to_map(prev_tuples)
        result_list = []
        for (account, metric) in cur_tuples:
            prev_metric = prev_map.pop(account, 0)
            delta_metric = metric - prev_metric
            result_list.append((account, delta_metric))
        return sorted(result_list, key=itemgetter(1), reverse=True)

    def prep_filtered_results(self, tuple_list):
        """Apply exclude_accounts filter and return top MAX_RESULTS_COUNT."""
        unfiltered_list = []
        filtered_list = []
        for (account, metric) in tuple_list:
            if len(unfiltered_list) < MAX_RESULTS_COUNT:
                unfiltered_list.append((account, metric))
            if account not in self.exclude_accounts:
                filtered_list.append((account, metric))
                if len(filtered_list) == MAX_RESULTS_COUNT:
                    break
        return unfiltered_list, filtered_list

    def compare_data(self, previous, current):
        """Compare previous to current data and return all results."""
        cve_status_deltas = self.compare_tuple_lists(previous['cve_status_usage'],
                                                     current['cve_status_usage'])
        system_cve_status_deltas = self.compare_tuple_lists(previous['system_cve_status_usage'],
                                                            current['system_cve_status_usage'])
        cve_business_risk_deltas = self.compare_tuple_lists(previous['cve_business_risk_usage'],
                                                            current['cve_business_risk_usage'])
        results = {'cve_status_usage': {},
                   'system_cve_status_usage': {},
                   'cve_business_risk_usage': {}}
        unfiltered, filtered = self.prep_filtered_results(current['cve_status_usage'])
        results['cve_status_usage']['total'] = unfiltered
        results['cve_status_usage']['filtered_total'] = filtered
        unfiltered, filtered = self.prep_filtered_results(cve_status_deltas)
        results['cve_status_usage']['delta'] = unfiltered
        results['cve_status_usage']['filtered_delta'] = filtered
        unfiltered, filtered = self.prep_filtered_results(current['system_cve_status_usage'])
        results['system_cve_status_usage']['total'] = unfiltered
        results['system_cve_status_usage']['filtered_total'] = filtered
        unfiltered, filtered = self.prep_filtered_results(system_cve_status_deltas)
        results['system_cve_status_usage']['delta'] = unfiltered
        results['system_cve_status_usage']['filtered_delta'] = filtered
        unfiltered, filtered = self.prep_filtered_results(current['cve_business_risk_usage'])
        results['cve_business_risk_usage']['total'] = unfiltered
        results['cve_business_risk_usage']['filtered_total'] = filtered
        unfiltered, filtered = self.prep_filtered_results(cve_business_risk_deltas)
        results['cve_business_risk_usage']['delta'] = unfiltered
        results['cve_business_risk_usage']['filtered_delta'] = filtered
        return results

    @staticmethod
    def plain_text(results):
        """Generator: put results in plain text output."""
        for key in ('cve_status_usage', 'system_cve_status_usage', 'cve_business_risk_usage'):
            for metrics_key in ('filtered_delta', 'delta', 'filtered_total', 'total'):
                yield "%s - %s" % (key.replace('_', ' ').upper(), METRIC_LABEL[metrics_key])
                yield "+------------+----------------+"
                yield "|    account |          count |"
                for (account, value) in results[key][metrics_key]:
                    yield "+------------+----------------+"
                    yield "|%s|%s|" % (account.rjust(11) + " ", str(value).rjust(15) + " ")
                yield "+------------+----------------+"
                yield ""

    @staticmethod
    def html(results):
        """Generator: put results in html output."""
        for key in ('cve_status_usage', 'system_cve_status_usage', 'cve_business_risk_usage'):
            for metrics_key in ('filtered_delta', 'delta', 'filtered_total', 'total'):
                yield "<h5>%s</h5>" % (key.replace('_', ' ').upper() + " - " + METRIC_LABEL[metrics_key])
                yield "<table><tr><td>account</td><td>count</td></tr>"
                for (account, value) in results[key][metrics_key]:
                    yield "<tr><td>%s</td><td>%s</td></tr>" % (account, str(value))
                yield "</table>"

    def send_results(self, results):
        """Send the results via email or write to log as appropriate to the config."""
        if self.today.day == 1:
            # this is monthly report
            email_to = EMAIL_MONTHLY_TO
            subject = "Monthly Vulnerability Feature Usage Report (top %d)" % MAX_RESULTS_COUNT
        else:
            # partial month report
            email_to = EMAIL_PARTIAL_MONTH_TO
            subject = "Partial Month Vulnerability Feature Usage Report (top %d)" % MAX_RESULTS_COUNT
        if email_to:
            body = "\n".join(self.plain_text(results))
            send_mail(subject, body, [email_to])
        else:
            print("\n".join(self.plain_text(results)))

    @staticmethod
    def create_db_map(cve_s_map, system_cve_map, cve_br_map, timestamp):
        """Creates dict of new records to db, with tuples"""
        with DatabasePoolConnection() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT name FROM rh_account
                """)
                names = cur.fetchall()

        result = {}
        for name in names:
            name_ = name[0]
            result[name_] = (name_, timestamp, cve_s_map.get(name_, 0), system_cve_map.get(name_, 0), cve_br_map.get(name_, 0))
        return result

    def run(self):
        """Run the metrics gathering."""
        if self.debug:
            print("running...\n")
        with DatabasePoolConnection() as conn:
            cve_status_usage = self.query_cve_status_usage(conn)
            system_cve_status_usage = self.query_system_cve_status_usage(conn)
            cve_business_risk_usage = self.query_cve_business_risk_usage(conn)
            conn.commit()
        raw_data = {"cve_status_usage": cve_status_usage,
                    "system_cve_status_usage": system_cve_status_usage,
                    "cve_business_risk_usage": cve_business_risk_usage}
        cve_status_map = self.metrics_tuple_list_to_map(cve_status_usage)
        system_cve_status_map = self.metrics_tuple_list_to_map(system_cve_status_usage)
        cve_business_risk_map = self.metrics_tuple_list_to_map(cve_business_risk_usage)
        current_db_map = self.create_db_map(cve_status_map, system_cve_status_map, cve_business_risk_map, self.today)

        if self.stats_mgr.are_data(self.today):
            # replace existing day's data with that just gathered
            # in case something went wrong the first time around.
            print("Replacing %s data" % self.today)
            self.stats_mgr.remove_data(self.today)
        self.stats_mgr.save_data(current_db_map.values())
        if self.today.day == 1:
            # its day one, so do monthly report.
            # Compare to first day of previous month.
            if self.today.month == 1:
                previous_date = datetime.date(self.today.year - 1, 12, 1)
            else:
                previous_date = datetime.date(self.today.year, self.today.month - 1, 1)
        else:
            # Not monthly report, so compare with first of
            # current month to see how this month is doing
            previous_date = datetime.date(self.today.year, self.today.month, 1)
        if self.stats_mgr.are_data(previous_date):
            previous_data = self.stats_mgr.load_data(previous_date)
            previous_data = self.db_to_tuples(previous_data)
        else:
            previous_data = {"cve_status_usage": [],
                             "system_cve_status_usage": [],
                             "cve_business_risk_usage": []}
        results = self.compare_data(previous_data, raw_data)
        self.send_results(results)

        timestamps_to_delete = []
        for timestamp in self.stats_mgr.load_timestamps():
            if timestamp.day != 1:
                timestamps_to_delete.append(timestamp)
        if timestamps_to_delete:
            if self.debug:
                print("Clearing unnecessary data from db")
            self.stats_mgr.remove_multiple(tuple(timestamps_to_delete))


def main():
    """Main entrypoint"""
    with DatabasePool(2):
        with DatabasePoolConnection() as conn:
            stats_mng = StatsManager(conn)
            mgather = MetricsGatherer(stats_mng, exclude_accounts_text=EXCLUDE_ACCOUNTS, debug=DEBUG)
            mgather.run()
            conn.commit()


if __name__ == '__main__':
    main()
