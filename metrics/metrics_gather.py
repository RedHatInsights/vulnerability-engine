#!/usr/bin/env python3
"""
Gathers metrics to show feature and product usage.
"""

import os
import time
import argparse
import datetime
import smtplib

from operator import itemgetter
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from common.database_handler import DatabasePool, DatabasePoolConnection, NamedCursor
from metrics.s3_bucket_manager import S3BucketManager

DEBUG = os.getenv('DEBUG', None)
SMTP_HOST = os.getenv('SMTP_HOST')
SMTP_PASS = os.getenv('SMTP_PASS')
SMTP_USER = os.getenv('SMTP_USER')
EMAIL_FROM = os.getenv('EMAIL_FROM')
EMAIL_MONTHLY_TO = os.getenv('EMAIL_MONTHLY_TO', None)
EMAIL_PARTIAL_MONTH_TO = os.getenv('EMAIL_PARTIAL_MONTH_TO', None)

MAX_RESULTS_COUNT = 20
METRIC_LABEL = {'filtered_delta': 'Non-Red Hat Accounts Delta',
                'delta': 'All Accounts Delta',
                'filtered_total': 'Non-Red Hat Accounts Total',
                'total': 'All Accounts Total'}


class MetricsGatherer():
    """Metrics Gatherer"""

    def __init__(self, exclude_accounts, bucket_mgr, debug=False):
        self.debug = debug
        self.exclude_accounts = exclude_accounts
        self.bucket_mgr = bucket_mgr
        self.today = datetime.date.today()
        if self.debug:
            print("Exclude accounts: %s\n" % sorted(exclude_accounts))

    def query_cve_status_usage(self, connection):
        """Query for cve status usage."""
        start = time.time()
        cve_status_usage = []
        if self.debug:
            print("generating CVE-status usage report...\n")
            print("  account    # CVEs with status set")
            print("------------ ----------------------")
        with NamedCursor(connection) as cur:
            cur.execute("""SELECT ra.name,
                                  count(ra.name)
                             FROM cve_account_data cad
                             JOIN rh_account ra
                               ON cad.rh_account_id = ra.id
                            WHERE cad.status_id != 0
                         GROUP BY ra.name
                         ORDER BY count(ra.name) DESC""")
            for row in cur.fetchall():
                cve_status_usage.append(row)
                if self.debug:
                    print(f"{row[0]:12s} {row[1]}")
        if self.debug:
            print("-----------------------------------")
        print("CVE-status usage query took %s milliseconds\n" % str((time.time() - start) * 1000))
        return cve_status_usage

    def query_system_cve_status_usage(self, connection):
        """Query for system cve status usage."""
        start = time.time()
        system_cve_status_usage = []
        if self.debug:
            print("generating system-CVE-status usage report...\n")
            print("  account    # system-CVEs with status set")
            print("------------ -----------------------------")
        with NamedCursor(connection) as cur:
            cur.execute("""SELECT ra.name,
                                  count(ra.name)
                             FROM system_vulnerabilities sv
                             JOIN system_platform sp
                               ON sv.system_id = sp.id
                             JOIN rh_account ra
                               ON sp.rh_account_id = ra.id
                            WHERE sv.status_id != 0
                         GROUP BY ra.name
                         ORDER BY count(ra.name) DESC""")
            for row in cur.fetchall():
                system_cve_status_usage.append(row)
                if self.debug:
                    print(f"{row[0]:12s} {row[1]}")
        if self.debug:
            print("------------------------------------------")
        print("system-CVE-status usage query took %s milliseconds\n" % str((time.time() - start) * 1000))
        return system_cve_status_usage

    def query_cve_business_risk_usage(self, connection):
        """Query for cve business risk usage."""
        start = time.time()
        cve_business_risk_usage = []
        if self.debug:
            print("generating CVE-business risk usage report...\n")
            print("  account    # CVEs with business risk set")
            print("------------ -----------------------------")
        with NamedCursor(connection) as cur:
            cur.execute("""SELECT ra.name,
                                  count(ra.name)
                             FROM cve_account_data cad
                             JOIN rh_account ra
                               ON cad.rh_account_id = ra.id
                            WHERE cad.business_risk_id != 0
                         GROUP BY ra.name
                         ORDER BY count(ra.name) DESC""")
            for row in cur.fetchall():
                cve_business_risk_usage.append(row)
                if self.debug:
                    print(f"{row[0]:12s} {row[1]}")
        if self.debug:
            print("------------------------------------------")
        print("CVE-business risk usage query took %s milliseconds\n" % str((time.time() - start) * 1000))
        return cve_business_risk_usage

    @staticmethod
    def date_to_key(date):
        """Given a date, return the key used to store data in bucket."""
        return date.strftime("metrics-%Y-%m-%d")

    @staticmethod
    def key_to_date(key):
        """Given the key used to store data in bucket, return the date."""
        keysplit = key.split('-')
        return datetime.date(int(keysplit[1]), int(keysplit[2]), int(keysplit[3]))

    @staticmethod
    def metrics_tuple_list_to_map(tuple_list):
        """Given a tuple list, return the metrics values in map keyed on account."""
        to_map = {}
        for (key, value) in tuple_list:
            to_map[key] = value
        return to_map

    def compare_tuple_lists(self, prev_tuples, cur_tuples):
        """Compare two metrics lists and return sorted list of metric deltas."""
        prev_map = self.metrics_tuple_list_to_map(prev_tuples)
        result_list = []
        for (account, metric) in cur_tuples:
            prev_metric = prev_map.pop(account, 0)
            delta_metric = metric - prev_metric
            result_list.append((account, delta_metric))
        return sorted(result_list, key=itemgetter(1), reverse=True)

    def prep_filtered_results(self, tuple_list):
        """Apply exclude_accounts filter and return top MAX_RESULTS_COUNT."""
        unfiltered_list = []
        filtered_list = []
        for (account, metric) in tuple_list:
            if len(unfiltered_list) < MAX_RESULTS_COUNT:
                unfiltered_list.append((account, metric))
            if account not in self.exclude_accounts:
                filtered_list.append((account, metric))
                if len(filtered_list) == MAX_RESULTS_COUNT:
                    break
        return unfiltered_list, filtered_list

    def compare_data(self, previous, current):
        """Compare previous to current data and return all results."""
        cve_status_deltas = self.compare_tuple_lists(previous['cve_status_usage'],
                                                     current['cve_status_usage'])
        system_cve_status_deltas = self.compare_tuple_lists(previous['system_cve_status_usage'],
                                                            current['system_cve_status_usage'])
        cve_business_risk_deltas = self.compare_tuple_lists(previous['cve_business_risk_usage'],
                                                            current['cve_business_risk_usage'])
        results = {'cve_status_usage': {},
                   'system_cve_status_usage': {},
                   'cve_business_risk_usage': {}}
        unfiltered, filtered = self.prep_filtered_results(current['cve_status_usage'])
        results['cve_status_usage']['total'] = unfiltered
        results['cve_status_usage']['filtered_total'] = filtered
        unfiltered, filtered = self.prep_filtered_results(cve_status_deltas)
        results['cve_status_usage']['delta'] = unfiltered
        results['cve_status_usage']['filtered_delta'] = filtered
        unfiltered, filtered = self.prep_filtered_results(current['system_cve_status_usage'])
        results['system_cve_status_usage']['total'] = unfiltered
        results['system_cve_status_usage']['filtered_total'] = filtered
        unfiltered, filtered = self.prep_filtered_results(system_cve_status_deltas)
        results['system_cve_status_usage']['delta'] = unfiltered
        results['system_cve_status_usage']['filtered_delta'] = filtered
        unfiltered, filtered = self.prep_filtered_results(current['cve_business_risk_usage'])
        results['cve_business_risk_usage']['total'] = unfiltered
        results['cve_business_risk_usage']['filtered_total'] = filtered
        unfiltered, filtered = self.prep_filtered_results(cve_business_risk_deltas)
        results['cve_business_risk_usage']['delta'] = unfiltered
        results['cve_business_risk_usage']['filtered_delta'] = filtered
        return results

    @staticmethod
    def plain_text(results):
        """Generator: put results in plain text output."""
        for key in ('cve_status_usage', 'system_cve_status_usage', 'cve_business_risk_usage'):
            for metrics_key in ('filtered_delta', 'delta', 'filtered_total', 'total'):
                yield "%s - %s" % (key.replace('_', ' ').upper(), METRIC_LABEL[metrics_key])
                yield "+------------+----------------+"
                yield "|    account |          count |"
                for (account, value) in results[key][metrics_key]:
                    yield "+------------+----------------+"
                    yield "|%s|%s|" % (account.rjust(11) + " ", str(value).rjust(15) + " ")
                yield "+------------+----------------+"
                yield "   "

    @staticmethod
    def html(results):
        """Generator: put results in html output."""
        for key in ('cve_status_usage', 'system_cve_status_usage', 'cve_business_risk_usage'):
            for metrics_key in ('filtered_delta', 'delta', 'filtered_total', 'total'):
                yield "<h5>%s</h5>" % (key.replace('_', ' ').upper() + " - " + METRIC_LABEL[metrics_key])
                yield "<table><tr><td>account</td><td>count</td></tr>"
                for (account, value) in results[key][metrics_key]:
                    yield "<tr><td>%s</td><td>%s</td></tr>" % (account, str(value))
                yield "</table>"

    def send_results(self, results):
        """Send the results via email or write to log as appropriate to the config."""
        if self.today.day == 1:
            # this is monthly report
            email_to = EMAIL_MONTHLY_TO
            subject = "Monthly Vulnerability Feature Usage Report (top %d)" % MAX_RESULTS_COUNT
        else:
            # partial month report
            email_to = EMAIL_PARTIAL_MONTH_TO
            subject = "Partial Month Vulnerability Feature Usage Report (top %d)" % MAX_RESULTS_COUNT
        if email_to:
            outer = MIMEMultipart('alternative')
            outer['Subject'] = subject
            outer['From'] = EMAIL_FROM
            outer['To'] = email_to

            outer.attach(MIMEText("\n".join(self.plain_text(results)), _subtype="plain"))
            outer.attach(MIMEText("\n".join(self.html(results)), _subtype="html"))

            with smtplib.SMTP_SSL(SMTP_HOST) as mailer:
                mailer.login(SMTP_USER, SMTP_PASS)
                mailer.sendmail(EMAIL_FROM, email_to, outer.as_string())
            if self.debug:
                print("\n".join(self.plain_text(results)))
        else:
            print("\n".join(self.plain_text(results)))

    def run(self):
        """Run the metrics gathering."""
        if self.debug:
            print("running...\n")
        with DatabasePoolConnection() as conn:
            cve_status_usage = self.query_cve_status_usage(conn)
            system_cve_status_usage = self.query_system_cve_status_usage(conn)
            cve_business_risk_usage = self.query_cve_business_risk_usage(conn)
            conn.commit()
        raw_data = {"cve_status_usage": cve_status_usage,
                    "system_cve_status_usage": system_cve_status_usage,
                    "cve_business_risk_usage": cve_business_risk_usage}
        today_key = self.date_to_key(self.today)
        key_list = self.bucket_mgr.list_keys()
        if today_key in key_list:
            # replace existing day's data with that just gathered
            # in case something went wrong the first time around.
            print("Replacing %s data" % today_key)
            self.bucket_mgr.delete_by_key(today_key)
            key_list.remove(today_key)
        self.bucket_mgr.upload_data(today_key, raw_data)
        if self.today.day == 1:
            # its day one, so do monthly report.
            # Compare to first day of previous month.
            if self.today.month == 1:
                previous_date = datetime.date(self.today.year - 1, 12, 1)
            else:
                previous_date = datetime.date(self.today.year, self.today.month - 1, 1)
        else:
            # Not monthly report, so compare with first of
            # current month to see how this month is doing
            previous_date = datetime.date(self.today.year, self.today.month, 1)
        previous_key = self.date_to_key(previous_date)
        if previous_key in key_list:
            previous_data = self.bucket_mgr.retrieve_data(previous_key)
        else:
            previous_data = {"cve_status_usage": [],
                             "system_cve_status_usage": [],
                             "cve_business_risk_usage": []}
        results = self.compare_data(previous_data, raw_data)
        self.send_results(results)

        keys_to_delete = []
        for key in key_list:
            if self.key_to_date(key).day != 1:
                keys_to_delete.append(key)
        if keys_to_delete:
            if self.debug:
                print("Clearing unnecessary data from bucket")
            self.bucket_mgr.delete_by_key_list(keys_to_delete)


def main():
    """Main entrypoint"""
    parser = argparse.ArgumentParser(description='Gather feature and product usage by account')
    parser.add_argument("-e", "--excludes_file", action="store",
                        default="exclude_accounts.txt",
                        help="file containing list of accounts to exclude from results")
    args = parser.parse_args()

    exclude_accounts = set()
    if args.excludes_file:
        if DEBUG:
            print("Loading accounts to exclude from file %s" % args.excludes_file)
        if os.path.isfile(args.excludes_file):
            with open(args.excludes_file, 'r') as excludesfile:
                lines = excludesfile.readlines()
                for line in lines:
                    account = line.split('#')[0].strip()
                    if account:
                        exclude_accounts.add(account)
        else:
            print("Specified excludes file %s does not exist or is not a file." % args.config_file)
            raise SystemExit(1)

    with DatabasePool(1):
        bucket_mgr = S3BucketManager(debug=DEBUG)
        mgather = MetricsGatherer(exclude_accounts, bucket_mgr, debug=DEBUG)

        mgather.run()


if __name__ == '__main__':
    main()
