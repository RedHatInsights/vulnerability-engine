"""
Vulnerability engine Evaluator component.
"""
from collections import namedtuple
from dataclasses import dataclass
from typing import Dict
from enum import Enum

from prometheus_client import Counter, Histogram

from common.peewee_model import VulnerabilityState
from common.config import Config
from common.utils import get_available_remediation_type

CFG = Config()
PROMETHEUS_PORT = CFG.prometheus_port or str(CFG.evaluator_prometheus_port)

# Prometheus timings
VMAAS_EVAL_TIME = Histogram("ve_evaluator_vmaas_evaluation_seconds", "Time spent checking a system for vmaas hits",
                            buckets=[0.1, 0.25, 0.5, 0.75, 1.0, 1.5, 2, 5])
EVAL_TIME = Histogram("ve_evaluator_evaluation_seconds", "Time spent fully evaluating a system",
                      buckets=[0.1, 0.25, 0.5, 0.75, 1.0, 1.5, 2, 5])
RULES_EVAL_TIME = Histogram("ve_evaluator_rules_evaluation_seconds", "Time spent checking a system for rule hits",
                            buckets=[0.1, 0.25, 0.5, 0.75, 1.0, 1.5, 2, 5])

# Prometheus counts
EVAL_COUNT = Counter("ve_evaluator_evaluations", "Number of evaluations attempted")
INV_ID_NOT_FOUND = Counter("ve_evaluator_inventory_not_found", "Number of times inventory-id not in SystemPlatform")
UNKNOWN_MSG = Counter("ve_evaluator_unknown_msg", "Number of unrecognized messages delivered from queue")
MESSAGE_PARSE_ERROR = Counter("ve_evaluator_message_parse_error", "# of message parse errors")
VMAAS_ERRORS_SKIP = Counter("ve_evaluator_vmaas_errors_skip", "# of evaluations skipped due to VMaaS errors")
EMPTY_DATA_SKIP = Counter("ve_evaluator_data_skip", "# of evaluations skipped due to empty VMaaS json and rule results")

# single member inside rule cache
RuleCache = namedtuple("RuleCache", ["id", "playbook_count"])
# single member inside cve cache
CveImpactCache = namedtuple("CveImpactCache", ["id"])
# single member inside cve cache
CveCache = namedtuple("CveCache", ["id"])
# cve coupled with its advisories, form vmaas
CveAdvisories = namedtuple("Cve", ["name", "advisories"])
# system_platform row taken from DB
SystemPlatform = namedtuple("SystemPlatform", ["id", "rh_account_id", "vmaas_json", "rule_results"])
# single vulnerability stored inside db
VulnerabilityDB = namedtuple("VulnerabilityDB", ["state", "sv_id", "rule_id", "when_mitigated", "mitigation_reason",
                                                 "advisories", "advisory_available", "rule_hit_details", "remediation_type_id"])


class VmaasErrorException(Exception):
    """Raised when unable to contact VMAAS"""


class EvaluatorException(Exception):
    """Evaluator processing exception"""


class EvaluatorMessageType(Enum):
    """Message types which can arrive at kafka"""
    EVALUATE_SYSTEM = "upload_new_file"
    RE_EVALUATE_SYSTEM = "re-evaluate_system"


@dataclass
class SystemVulnerabilitiesRow:
    """Class represents single vulnerability for system"""
    # pylint: disable=too-many-instance-attributes
    state: VulnerabilityState

    rh_account_id: int
    system_id: int

    cve_id: int
    advisories: str
    advisory_available: bool
    when_mitigated: str

    rule_id: int
    rule_hit_details: str
    playbook_count: int
    mitigation_reason: str

    remediation_type_id: int = -1

    def _populate_remediation_type(self):
        """Populate the remediation type id field"""
        self.remediation_type_id = get_available_remediation_type(self.advisory_available, self.when_mitigated, self.mitigation_reason, self.playbook_count)

    def __post_init__(self):
        """Called after constructor"""
        self._populate_remediation_type()

    def add_rule_info(self, rule_id: int, rule_hit_details: str, playbook_count: int, mitigation_reason: str):
        """Add rule information to the vulnerability, used when vulnerability is upgraded from vmaas only to also rule"""
        self.rule_id = rule_id
        self.rule_hit_details = rule_hit_details
        self.playbook_count = playbook_count
        self.mitigation_reason = mitigation_reason
        # need to regenerate remediation type id
        self._populate_remediation_type()

    def format_db_dict(self) -> Dict:
        """Returns structure in dict, for DB operations"""
        return {"state": self.state,
                "cve_id": self.cve_id,
                "advisories": self.advisories,
                "advisory_available": self.advisory_available,
                "when_mitigated": self.when_mitigated,
                "rule_id": self.rule_id,
                "rule_hit_details": self.rule_hit_details,
                "mitigation_reason": self.mitigation_reason,
                "remediation_type_id": self.remediation_type_id,
                "system_id": self.system_id,
                "rh_account_id": self.rh_account_id}

    def should_update_db(self, vulnerability_db: VulnerabilityDB) -> bool:
        """Resolves if system_vulnerabilities row should be updated,
           compared to what is already inside of the DB"""
        # FIXME: Disable comparing state to not update each row of each vulnerability forcefully
        #        Let evaluator update the state naturally when other columns change
        #        Can be re-enabled later when the prod DB is less busy
        # if vulnerability_db.state is not self.state:
        #    return True

        should_update = False
        # if the state of vulnerability did not change
        # this needs to be done to not rewrite the mitigation reason
        # timestamp on every update
        self.when_mitigated = vulnerability_db.when_mitigated

        if vulnerability_db.remediation_type_id != self.remediation_type_id:
            should_update = True

        if (self.state is VulnerabilityState.VULNERABLE_BY_PACKAGE
           or self.state is VulnerabilityState.VULNERABLE_BY_RULE_AND_PACKAGE
           or self.state is VulnerabilityState.VULNERABLE_BY_PACKAGE_NOT_RULE):
            if vulnerability_db.advisories != self.advisories:
                should_update = True
            if vulnerability_db.advisory_available != self.advisory_available:
                should_update = True

        if (self.state is VulnerabilityState.VULNERABLE_BY_RULE
           or self.state is VulnerabilityState.VULNERABLE_BY_RULE_AND_PACKAGE
           or self.state is VulnerabilityState.VULNERABLE_BY_PACKAGE_NOT_RULE):
            if vulnerability_db.rule_id != self.rule_id:
                should_update = True
            if vulnerability_db.rule_hit_details != self.rule_hit_details:
                should_update = True
            if vulnerability_db.mitigation_reason != self.mitigation_reason:
                should_update = True

        return should_update
