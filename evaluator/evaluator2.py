"""
Vulnerability engine evaluator component
"""
import asyncio
import json
from typing import Dict, List, Tuple
import signal

from psycopg_pool.pool_async import AsyncConnectionPool
from psycopg import AsyncConnection, sql
from psycopg.rows import dict_row
from aiokafka import ConsumerRecord

from common.logging import get_logger, init_logging
from common.peewee_model import VulnerabilityState
from common.status_app import create_status_app, create_status_runner
from common.utils import a_ensure_minimal_schema_version, send_msg_to_payload_tracker, send_remediations_update, send_notifications
from common.database_handler import setup_async_db_pool
from common.mqueue import MQWriter, MQReader
from listener.common import create_task_and_log
from .logic import EvaluatorLogic
from .common import (SystemPlatform, VulnerabilityDB, Vulnerability, EvaluatorMessageTypes,
                     EvaluatorException, VmaasErrorException,
                     PROMETHEUS_PORT, CFG, EVAL_COUNT, INV_ID_NOT_FOUND, EVAL_TIME,
                     UNKNOWN_MSG, MESSAGE_PARSE_ERROR, VMAAS_ERRORS_SKIP, EMPTY_DATA_SKIP)

LOGGER = get_logger(__name__)


class Evaluator:
    """Main evaluator class"""

    def __init__(self, db_pool: AsyncConnectionPool, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self.db_pool: AsyncConnectionPool = db_pool
        self.loop = loop
        self.evaluator_logic = EvaluatorLogic(db_pool)

        LOGGER.info("consuming evaluator topic: %s", CFG.evaluator_topics)
        self.evaluator_topic = MQReader(CFG.evaluator_topics, group_id="evaluator-new")
        self.payload_tracker = MQWriter(CFG.payload_tracker_topic)
        self.remediations_results = MQWriter(CFG.remediation_updates_topic)
        self.evaluator_results = MQWriter(CFG.evaluator_results_topic)

    async def init(self):
        """Async constructor"""
        await self.evaluator_logic.init()

    async def _lock_system(self, inventory_id: str, conn: AsyncConnection) -> SystemPlatform:
        """Lock system for update and return its row"""
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute("""
                SELECT id, rh_account_id, vmaas_json, rule_results
                FROM system_platform
                WHERE inventory_id = %s
                AND when_deleted IS NULL
                FOR UPDATE
                LIMIT 1
                """, (inventory_id,))
            row = await cur.fetchone()
        if row:
            return SystemPlatform(row["id"], row["rh_account_id"], row["vmaas_json"], row["rule_results"])
        return None

    async def _load_db_system_vulnerabilities(self, system_platform: SystemPlatform, conn: AsyncConnection) -> Dict[str, VulnerabilityDB]:
        """Make map from marked vulnerabilities in db for system"""
        cve_map = {}
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute("""
                SELECT sv.state, cm.cve, sv.id as sv_id, sv.rule_id, sv.when_mitigated, sv.mitigation_reason,
                       sv.advisories, sv.advisory_available, sv.rule_hit_details,
                       sv.remediation_type_id
                FROM system_vulnerabilities_active AS sv
                JOIN cve_metadata AS cm ON sv.cve_id = cm.id
                LEFT JOIN insights_rule AS ir ON sv.rule_id = ir.id
                WHERE sv.system_id = %s AND sv.rh_account_id = %s
                """, (system_platform.id, system_platform.rh_account_id,))
            for cve_system in await cur.fetchall():
                # FIXME: this try/except should be deleted once all system_vulnerabilities rows
                # will have defined state + we can do NOT NULL constraint on that field in DB
                try:
                    state = VulnerabilityState(cve_system["state"])
                except ValueError:
                    state = None

                cve_map[cve_system["cve"]] = VulnerabilityDB(
                    state, cve_system["sv_id"],
                    cve_system["rule_id"], cve_system["when_mitigated"], cve_system["mitigation_reason"],
                    cve_system["advisories"], cve_system["advisory_available"],
                    cve_system["rule_hit_details"], cve_system["remediation_type_id"])
        return cve_map

    async def _insert_vulnerabilities(self, to_insert: [Dict], conn: AsyncConnection) -> List[Tuple]:
        """Insert given system_vulnerabilities"""
        new_sys_vulns = []
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.executemany("""
                INSERT INTO system_vulnerabilities
                (state, cve_id, rh_account_id, system_id,
                 advisories, advisory_available, when_mitigated, rule_id,
                 rule_hit_details, mitigation_reason, remediation_type_id)
                VALUES
                (%(state)s, %(cve_id)s, %(rh_account_id)s, %(system_id)s,
                 %(advisories)s, %(advisory_available)s, %(when_mitigated)s,
                 %(rule_id)s, %(rule_hit_details)s,
                 %(mitigation_reason)s, %(remediation_type_id)s)
                RETURNING id, cve_id
            """, to_insert, returning=True)
            for inserted in await cur.fetchall():
                new_sys_vulns.append((inserted["id"], inserted["cve_id"]))
        return new_sys_vulns

    async def _update_vulnerabilities(self, to_update: [Dict], conn: AsyncConnection):
        """Update given system_vulnerabilities"""
        # TODO: think if it would be possible to do EXECUTEMANY
        # where the update queries would update only changed fields
        async with conn.cursor() as cur:
            await cur.executemany("""
                UPDATE system_vulnerabilities AS sv
                SET state = %(state)s,
                    advisories = %(advisories)s,
                    advisory_available = %(advisory_available)s,
                    when_mitigated = %(when_mitigated)s,
                    rule_id = %(rule_id)s,
                    rule_hit_details = %(rule_hit_details)s,
                    mitigation_reason = %(mitigation_reason)s,
                    remediation_type_id = %(remediation_type_id)s
                WHERE sv.rh_account_id = %(rh_account_id)s
                AND sv.system_id = %(system_id)s
                AND sv.cve_id = %(cve_id)s
            """, to_update)

    async def _delete_vulnerabilities(self,
                                      to_delete: [int],
                                      system_platform: SystemPlatform,
                                      conn: AsyncConnection):
        """Delete given system_vulnerabilities from table"""
        async with conn.cursor() as cur:
            await cur.execute("""DELETE FROM system_vulnerabilities AS sv
                                 WHERE sv.id = ANY (%s)
                                 AND sv.rh_account_id = %s
                                 """, (to_delete, system_platform.rh_account_id))

    async def _mark_system_evaluated(self,
                                     cve_cache_count: int,
                                     system_platform: SystemPlatform,
                                     conn: AsyncConnection):
        """Mark system as evaluated, updating its cache and last evaluation"""
        last_evaluation, advisor_evaluated = sql.Identifier("last_evaluation"), sql.Identifier("advisor_evaluated")
        if system_platform.vmaas_json:
            last_evaluation = sql.Literal("now()")
        if system_platform.rule_results:
            advisor_evaluated = sql.Literal("now()")

        async with conn.cursor() as cur:
            await cur.execute(
                sql.SQL("""UPDATE system_platform
                           SET last_evaluation = {},
                               advisor_evaluated = {},
                               cve_count_cache = %s
                           WHERE id = %s""").format(last_evaluation, advisor_evaluated),
                (cve_cache_count, system_platform.id))

    async def _compare_vulnerabilities(self, vulnerabilities_db: Dict[str, VulnerabilityDB], vulnerabilities: Dict[str, Vulnerability]):
        """Compare vulnerabilities mark in DB with fresh evaluated vulnerabilities"""
        to_insert, to_update, to_delete = [], [], []
        for cve, vulnerability in vulnerabilities.items():
            vulnerability_db = vulnerabilities_db.pop(cve, None)
            # vulnerability is not in db, we need to insert it
            if not vulnerability_db:
                to_insert.append(vulnerability.format_db_dict())
                continue

            # vulnerability is in db, check if fields changed
            if vulnerability.should_update_db(vulnerability_db):
                to_update.append(vulnerability.format_db_dict())

        # remaining vulnerability_db map are cves that we do not know anything about anymore
        for cve, vulnerability_db in vulnerabilities_db.items():
            to_delete.append(vulnerability_db.sv_id)

        return to_insert, to_update, to_delete

    async def _evaluate_system(self, inventory_id: str, org_id: str):
        """Evaluate vulnerabilities for single system, and update DB"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                system_platform = await self._lock_system(inventory_id, conn)
                if not system_platform:
                    INV_ID_NOT_FOUND.inc()
                    raise EvaluatorException(f"cannot find system: {inventory_id}, org_id: {org_id}, skipping evaluation")
                if not system_platform.vmaas_json and not system_platform.rule_results:
                    EMPTY_DATA_SKIP.inc()
                    LOGGER.error("skipping evaluation, due to empty vmaas_json and rule_results, system: %s, org_id: %s", inventory_id, org_id)
                    return

                # start both task asynchronously to speed up
                vulnerabilities_db, vulnerabilities = await asyncio.gather(
                    self._load_db_system_vulnerabilities(system_platform, conn),
                    self.evaluator_logic.evaluate_vulnerabilities(system_platform, conn),
                )

                # copy the list of cves that system is vulnerable to
                vulnerabilities_cves = list(vulnerabilities.keys())

                to_insert, to_update, to_delete = await self._compare_vulnerabilities(vulnerabilities_db, vulnerabilities)
                new_system_vulns = []
                if to_insert:
                    new_system_vulns = await self._insert_vulnerabilities(to_insert, conn)
                if to_update:
                    await self._update_vulnerabilities(to_update, conn)
                if to_delete:
                    await self._delete_vulnerabilities(to_delete, system_platform, conn)

                await self._mark_system_evaluated(len(vulnerabilities_cves), system_platform, conn)

                send_remediations_update(self.remediations_results, inventory_id, vulnerabilities_cves)
                send_notifications(self.evaluator_results, new_system_vulns, [], [], system_platform.rh_account_id, None, org_id)

    async def consume_message(self, msg: ConsumerRecord):
        """Consume single message from evaluator topic"""
        try:
            msg_dict = json.loads(msg.value.decode("utf-8"))
        except json.decoder.JSONDecodeError:
            LOGGER.error("cannot parse incoming kafka message: %s", msg)
            MESSAGE_PARSE_ERROR.inc()
            return

        inventory_id = msg_dict["host"]["id"]
        org_id = msg_dict["host"]["org_id"]

        msg_type = msg_dict.get("type")
        try:
            msg_type = EvaluatorMessageTypes(msg_type)
        except ValueError:
            LOGGER.error("received unknown message type: %s", msg_type)
            UNKNOWN_MSG.inc()
            return

        notify_payload_tracker = False
        if msg_type == EvaluatorMessageTypes.UPLOAD_NEW_FILE:
            notify_payload_tracker = True
            send_msg_to_payload_tracker(self.payload_tracker, msg_dict, "processing",
                                        status_msg="scheduled for evaluation", loop=self.loop)

        LOGGER.info("evaluating system: %s, org_id: %s", inventory_id, org_id)
        EVAL_COUNT.inc()
        try:
            with EVAL_TIME.time():
                await self._evaluate_system(inventory_id, org_id)
        except EvaluatorException as ex:
            LOGGER.error(str(ex))
            if notify_payload_tracker:
                send_msg_to_payload_tracker(self.payload_tracker, msg_dict, "error",
                                            status_msg=str(ex), loop=self.loop)
        except VmaasErrorException as ex:
            LOGGER.error(str(ex))
            VMAAS_ERRORS_SKIP.inc()
            return

        if notify_payload_tracker:
            send_msg_to_payload_tracker(self.payload_tracker, msg_dict, "success", loop=self.loop)

    async def _start_evaluating(self):
        """Evaluate messages in kafka"""
        async for msg in self.evaluator_topic.client:
            create_task_and_log(self.consume_message(msg), LOGGER, self.loop)

    async def run(self):
        """Start the whole service"""
        await self.evaluator_topic.start()
        await self.payload_tracker.start()
        await self.remediations_results.start()
        await self.evaluator_results.start()

        async with self.db_pool:
            await self.init()
            await self._start_evaluating()
            await self.stop()

    async def stop(self):
        """Stop the whole service"""
        LOGGER.info("Stopping the service")

        await self.evaluator_topic.stop()
        await self.payload_tracker.stop()
        await self.remediations_results.stop()
        await self.evaluator_results.stop()
        self.loop.stop()


def main():
    """Main"""
    init_logging()
    loop = asyncio.get_event_loop()

    status_app = create_status_app(LOGGER)
    _, status_site = create_status_runner(status_app, int(PROMETHEUS_PORT), LOGGER, loop)
    loop.run_until_complete(status_site.start())

    loop.run_until_complete(a_ensure_minimal_schema_version())

    LOGGER.info("Starting evaluator service")

    db_pool = setup_async_db_pool(CFG)
    evaluator = Evaluator(db_pool, loop)

    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for sig in signals:
        loop.add_signal_handler(
            sig, lambda sig=sig: loop.create_task(evaluator.stop()))

    loop.create_task(evaluator.run())
    loop.run_forever()
    LOGGER.info("Stopped evaluator service")


if __name__ == "__main__":
    main()
