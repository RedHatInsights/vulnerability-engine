#!/usr/bin/python3
import os
import logging
import multiprocessing
import json
import requests

from kafka import KafkaConsumer

VMAAS_HOST = os.getenv('VMAAS_HOST', 'webapp-vmaas-stable.1b13.insights.openshiftapps.com')


class Consumer(multiprocessing.Process):
    """ The main class of Kafka consumer.

        Logic for processing messages
        should be implemented in the run() method
    """
    def __init__(self, kafka_host, kafka_port, kafka_topic):
        multiprocessing.Process.__init__(self)
        self.stop_event = multiprocessing.Event()

        # connect to the Messaging Service
        self.consumer = KafkaConsumer(bootstrap_servers=kafka_host + ':' + kafka_port)

        # subscribe to the topic
        self.consumer.subscribe([kafka_topic])

    def stop(self):
        self.stop_event.set()

    def run(self):
        """
        This method should be overridden in the inherited classes.
        :return:
        """
        # just close connection
        self.consumer.close()


class VmaasUpdates(Consumer):
    """ This class contains logic for the processing new available
        updates from VMaaS.

         For the Phase 0, run() method just print steps to implement.

    """

    # TODO: implement selection from the DB after it is ready
    DB_SELECT_RESULT = [
        {
            'system_uuid': 'uuid1',
            "package_list": [
                "kernel-2.6.32-696.20.1.el6.x86_64"
            ],
            "repository_list": [
                "rhel-6-server-rpms"
            ],
            "releasever": "6Server",
            "basearch": "x86_64",
            "updates": None
        },
    ]

    def run(self):
        """
        This method process messages with type 'vmaas_updates'
        :return:
        """

        vmaas_updates_endpoint = 'https://' + VMAAS_HOST + '/api/v1/updates'
        while not self.stop_event.is_set():
            for message in self.consumer:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if msg_dict['type'] == 'vmaas_updates':

                    # reevaluate updates for every system in the DB
                    for s in self.DB_SELECT_RESULT:
                        print("Reevaluating for: " + s['system_uuid'])

                        r = requests.post(vmaas_updates_endpoint, json={'package_list': s['package_list'],
                                                                        'repository_list': s['repository_list'],
                                                                        'releasever': s['releasever'],
                                                                        'basearch': s['basearch']
                                                                        })

                        if r.status_code == 200:
                            response_json = json.loads(r.text)

                            # TODO: save results back to the DB
                            s['updates'] = response_json['update_list']

                            print(json.dumps(s, indent=4, sort_keys=True))
                        else:
                            # TODO: add error logging here
                            pass

                if self.stop_event.is_set():
                    break

        self.consumer.close()


class NewSystem(Consumer):
    """ This class contains logic for the processing messages about
        new registered system.

         For the Phase 0, run() method just print steps to implement.

    """

    MESSAGE = """
        --- NEW SYSTEM WAS ADDED ---
    1) Get ID of new system from the message
    2) Get details about new system with provided ID from the Inventory Service
    3) Get available from VMaaS
    4) Add record about new system into the Storage
    """

    def run(self):
        """
        This method process messages with type 'inventory_new_system'
        :return:
        """
        while not self.stop_event.is_set():
            for message in self.consumer:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if msg_dict['type'] == 'inventory_new_system':
                    print(self.MESSAGE)

                if self.stop_event.is_set():
                    break

        self.consumer.close()


class UpdateSystem(Consumer):
    """ This class contains logic for the processing messages about
        system updates.

         For the Phase 0, run() method just print steps to implement.

    """

    MESSAGE = """
        --- UPDATE SYSTEM (Phase 0) ---
    1) Get ID of new system from the message
    2) Get details about new system with provided ID from the Inventory Service
    3) Get available updates from VMaaS
    4) Update record about new system into the Storage
    """

    def run(self):
        """
        This method process messages with type 'inventory_update_system'
        :return:
        """
        while not self.stop_event.is_set():
            for message in self.consumer:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if msg_dict['type'] == 'inventory_update_system':
                    print(self.MESSAGE)

                if self.stop_event.is_set():
                    break

        self.consumer.close()


def main():
    kafka_host = os.getenv('KAFKA_HOST', 'kafka-1.vmaas-ci.svc')
    kafka_port = os.getenv('KAFKA_PORT', '29092')
    kafka_topic = os.getenv('KAFKA_TOPIC', 'vulnerability_results')


    tasks = [
        VmaasUpdates(kafka_host, kafka_port, kafka_topic),
        NewSystem(kafka_host, kafka_port, kafka_topic),
        UpdateSystem(kafka_host, kafka_port, kafka_topic)
    ]

    # start all message processing tasks
    for t in tasks:
        t.start()

    # wait until all tasks are done
    for task in tasks:
        task.join()


if __name__ == "__main__":
    logging.basicConfig(
        format='%(asctime)s.%(msecs)s:%(name)s:%(thread)d:%(levelname)s:%(process)d:%(message)s',
        level=logging.INFO
    )
    main()