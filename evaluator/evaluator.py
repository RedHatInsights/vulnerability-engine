"""
Vulnerability engine evaluator component
"""
import asyncio
import json
import signal

from psycopg_pool.pool_async import AsyncConnectionPool
from aiokafka import ConsumerRecord

from common.logging import get_logger, init_logging
from common.status_app import create_status_app, create_status_runner
from common.utils import a_ensure_minimal_schema_version, create_task_and_log
from common.database_handler import setup_async_db_pool
from common.mqueue import MQWriter, MQReader
from .processor import EvaluatorProcessor
from .common import EvaluatorMessageType, PROMETHEUS_PORT, CFG, MESSAGE_PARSE_ERROR

LOGGER = get_logger(__name__)


class Evaluator:
    """Main evaluator class"""

    def __init__(self, db_pool: AsyncConnectionPool, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self.db_pool: AsyncConnectionPool = db_pool
        self.loop = loop

        self.evaluator_topic = MQReader(CFG.evaluator_topics)

        self.payload_tracker = MQWriter(CFG.payload_tracker_topic)
        self.remediations_results = MQWriter(CFG.remediation_updates_topic)
        self.evaluator_results = MQWriter(CFG.evaluator_results_topic)

        self.processor = EvaluatorProcessor(self.remediations_results, self.evaluator_results, self.payload_tracker, db_pool, loop)

        self.consume_task = None
        self.max_evaluator_msgs = asyncio.BoundedSemaphore(CFG.max_loaded_evaluator_msgs)

    async def init(self):
        """Async constructor"""
        await self.processor.init()

    async def _consume_message(self, msg: ConsumerRecord):
        """Consume notification about new upload"""
        try:
            msg_dict = json.loads(msg.value.decode("utf-8"))
        except json.decoder.JSONDecodeError:
            LOGGER.error("cannot parse incoming kafka message: %s", msg)
            MESSAGE_PARSE_ERROR.inc()
            return

        inventory_id = msg_dict["host"]["id"]
        org_id = msg_dict["host"]["org_id"]
        request_id = msg_dict.get("platform_metadata", {}).get("request_id")

        try:
            msg_type = EvaluatorMessageType(msg_dict.get("type"))
        except ValueError:
            LOGGER.error("received unknown message type: %s", msg_type)
            return

        await self.processor.evaluate_system(inventory_id, org_id, request_id)

    async def consume_message(self, msg: ConsumerRecord):
        """Consume message for evaluation, wrapper for semaphore"""
        try:
            await self._consume_message(msg)
        finally:
            self.max_evaluator_msgs.release()

    async def _start_evaluating(self):
        """Start consuming evaluation topic"""
        async for msg in self.evaluator_topic.client:
            await self.max_evaluator_msgs.acquire()
            create_task_and_log(self.consume_message(msg), LOGGER, self.loop)

    async def run(self):
        """Start the whole service"""
        await self.evaluator_topic.start()
        await self.payload_tracker.start()
        await self.remediations_results.start()
        await self.evaluator_results.start()

        async with self.db_pool:
            await self.init()
            self.consume_task = create_task_and_log(self._start_evaluating(), LOGGER, self.loop)
            await self.consume_task
            await self.stop()

    async def stop(self):
        """Stop the whole service"""
        LOGGER.info("Stopping the service")
        self.consume_task.cancel()

        await self.evaluator_topic.stop()
        await self.payload_tracker.stop()
        await self.remediations_results.stop()
        await self.evaluator_results.stop()

        self.loop.stop()


def main():
    """Main"""
    init_logging()
    loop = asyncio.get_event_loop()

    status_app = create_status_app(LOGGER)
    _, status_site = create_status_runner(status_app, int(PROMETHEUS_PORT), LOGGER, loop)
    loop.run_until_complete(status_site.start())

    loop.run_until_complete(a_ensure_minimal_schema_version())

    LOGGER.info("Starting evaluator service")

    db_pool = setup_async_db_pool(CFG)
    evaluator = Evaluator(db_pool, loop)

    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for sig in signals:
        loop.add_signal_handler(sig, lambda sig=sig: loop.create_task(evaluator.stop()))

    create_task_and_log(evaluator.run(), LOGGER, loop)
    loop.run_forever()
    LOGGER.info("Stopped evaluator service")


if __name__ == "__main__":
    main()
