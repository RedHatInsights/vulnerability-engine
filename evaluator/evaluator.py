#!/usr/bin/python3
import os
import logging
import multiprocessing
import json
import requests

from kafka import KafkaConsumer

from database.database_handler import DatabaseHandler, init_db

VMAAS_HOST = os.getenv('VMAAS_HOST', 'webapp-vmaas-stable.1b13.insights.openshiftapps.com')
logging.basicConfig(
    format='%(asctime)s.%(msecs)s:%(name)s:%(thread)d:%(levelname)s:%(process)d:%(message)s',
    level=logging.INFO
)


class VmaasUpdates(multiprocessing.Process):
    """ This class contains logic for the processing new available
        updates from VMaaS.

         For the Phase 0, run() method just print steps to implement.

    """
    def __init__(self, kafka_host, kafka_port, kafka_topic, kafka_group):
        multiprocessing.Process.__init__(self)
        self.stop_event = multiprocessing.Event()

        # connect to the Messaging Service
        bootstrap_server = kafka_host + ':' + kafka_port
        self.consumer = KafkaConsumer(kafka_topic,
                          bootstrap_servers=bootstrap_server,
                          group_id=kafka_group,
                          auto_offset_reset='earliest',
                          )

        logging.info("Using BOOTSTRAP_SERVERS: %s" % bootstrap_server)
        logging.info("Using GROUP_ID: %s" % kafka_group)
        logging.info("Using TOPIC: %s" % kafka_topic)

        # get DB connection
        self.conn = DatabaseHandler.get_connection()

    # TODO: implement selection from the DB after it is ready
    DB_SELECT_RESULT = [
        {
            'system_uuid': 'uuid1',
            "package_list": [
                "kernel-2.6.32-696.20.1.el6.x86_64"
            ],
            "repository_list": [
                "rhel-6-server-rpms"
            ],
            "releasever": "6Server",
            "basearch": "x86_64",
            "updates": None
        },
    ]

    def run(self):
        """
        This method process messages with type 'vmaas_updates'
        :return:
        """

        vmaas_updates_endpoint = 'https://' + VMAAS_HOST + '/api/v1/updates'
        while not self.stop_event.is_set():
            for message in self.consumer:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if msg_dict['type'] == 'vmaas_updates':

                    # reevaluate updates for every system in the DB
                    for s in self.DB_SELECT_RESULT:

                        updates_json = {'package_list': s['package_list'],
                                        'repository_list': s['repository_list'],
                                        'releasever': s['releasever'],
                                        'basearch': s['basearch']
                                        }

                        r = requests.post(vmaas_updates_endpoint, json=updates_json)

                        if r.status_code == 200:
                            response_json = json.loads(r.text)
                            system_errata = set()

                            for pkg in response_json['update_list']:
                                for upd in response_json['update_list'][pkg]['available_updates']:
                                    system_errata.add(upd['erratum'])

                            # TODO: save results back to the DB instead just logging it
                            cur = self.conn.cursor()

                            logging.info(str(system_errata))
                        else:
                            logging.error("Error during request to VMaaS endpoint " + vmaas_updates_endpoint)
                            logging.debug("Updates JSON: " + str(updates_json))
                else:
                    logging.info("DEBUG: unknown message type")

                if self.stop_event.is_set():
                    break

        self.consumer.close()


def main():

    init_db()

    kafka_host = os.getenv('KAFKA_HOST', 'kafka-1.vmaas-ci.svc')
    kafka_port = os.getenv('KAFKA_PORT', '29092')
    kafka_topic = os.getenv('KAFKA_TOPIC', 'vulnerability_results')
    kafka_group_id = os.getenv('KAFKA_GROUP_ID', 'vulnerability')

    tasks = [
        VmaasUpdates(kafka_host, kafka_port, kafka_topic, kafka_group_id)
    ]

    # start all message processing tasks
    for t in tasks:
        t.start()

    # wait until all tasks are done
    for task in tasks:
        task.join()


if __name__ == "__main__":
    main()