#!/usr/bin/env python3
"""
vulnerability-engine evaluator
"""
from datetime import datetime
import asyncio
import os
import json
import signal
from prometheus_client import Counter, Histogram, start_http_server
from psycopg2 import DatabaseError
from psycopg2.extras import execute_values
import requests

from common import mqueue
from common.database_handler import DatabasePool, DatabasePoolConnection
from common.logging import init_logging, get_logger
from common.utils import vmaas_post_request

LOGGER = get_logger(__name__)

VMAAS_HOST = os.getenv('VMAAS_HOST', 'http://vmaas-webapp-1.vmaas-ci.svc:8080')
VMAAS_VULNERABILITIES_API = os.getenv("VMAAS_VULNERABILITIES_API", "/api/v1/vulnerabilities")
vmaas_vulnerabilities_endpoint = "%s%s" % (VMAAS_HOST, VMAAS_VULNERABILITIES_API)  # pylint: disable=invalid-name

kafka_evaluator_topic = os.getenv('EVALUATOR_TOPIC',  # pylint: disable=invalid-name
                                  'vulnerability.evaluator.upload,vulnerability.evaluator.recalc').split(",")
prometheus_port = os.getenv('PROMETHEUS_PORT', '8085')  # pylint: disable=invalid-name

# prometheus probes
# times
VMAAS_EVAL_TIME = Histogram('ve_evaluator_vmaas_evaluation_seconds', 'Time spent checking a system for vmaas hits')
# counts
VMAAS_COUNT = Counter('ve_evaluator_vmaas_calls', 'Number of VMaaS-evaluations attempted')
INV_ID_NOT_FOUND = Counter('ve_evaluator_inventory_not_found', 'Number of times inventory-id not in SystemPlatform')
UNKNOWN_MSG = Counter('ve_evaluator_unknown_msg', 'Number of unrecognized messages delivered from queue')
UNKNOWN_TOPIC = Counter('ve_evaluator_unknown_topic', 'Number of times message delivered from unsupported topic')

CONSUMER_QUEUE = mqueue.MQReader(kafka_evaluator_topic)
WEBHOOKS_QUEUE = mqueue.MQWriter(mqueue.WEBHOOKS_TOPIC)


async def terminate(_, loop):
    """Trigger shutdown."""
    LOGGER.info("Signal received, stopping kafka consumers.")
    await CONSUMER_QUEUE.stop()
    await WEBHOOKS_QUEUE.stop()
    loop.stop()


class QueueEvaluator:
    """ This class contains logic for the processing vulnerabilities using VMaaS.
    """

    def __init__(self):
        LOGGER.info("Using BOOTSTRAP_SERVERS: %s", mqueue.BOOTSTRAP_SERVERS)
        LOGGER.info("Using GROUP_ID: %s", mqueue.GROUP_ID)
        LOGGER.info("Using TOPICS: %s", ", ".join(kafka_evaluator_topic))

        self.session = requests.Session()

    @staticmethod
    def _load_cves_for_inventory_id(inventory_id, cur):
        system_cves_map = {}
        cur.execute("select id, cve, first_reported, when_mitigated \
                       from system_vulnerabilities where inventory_id = %s", (inventory_id,))
        for sys_vuln_id, cve, first_reported, when_mitigated in cur.fetchall():
            sys_vuln = {'id': sys_vuln_id,
                        'cve': cve,
                        'first_reported': first_reported,
                        'when_mitigated': when_mitigated}
            system_cves_map[cve] = sys_vuln
        return system_cves_map

    @staticmethod
    def _register_missing_cves(missing_cves, cur):
        to_insert = [(cve, "unknown", 0) for cve in missing_cves]
        # do nothing if row exists - other evaluator or vmaas-sync just inserted it
        execute_values(cur, """INSERT INTO cve_metadata
                       (cve, description, impact_id)
                       VALUES %s
                       ON CONFLICT (cve) DO NOTHING""", to_insert, page_size=len(to_insert))

    def _store_new_cves(self, inventory_id, new_cves, rh_account, cur):
        system_cves_id_map = {}
        if not new_cves:
            return system_cves_id_map
        cvss_buckets = {'0to3': 0, '3to7': 0, '7to10': 0}

        # FIXME: getting metadata from DB on every system update should be optimized
        cur.execute("select cve, coalesce(cvss3_score, cvss2_score) from cve_metadata where cve in %s",
                    (tuple(new_cves),))
        cves_in_db = set()
        for cve_tuple in cur.fetchall():
            cves_in_db.add(cve_tuple[0])
            if cve_tuple[1] is None:
                pass
            elif cve_tuple[1] < 3:
                cvss_buckets['0to3'] += 1
            elif 3 <= cve_tuple[1] < 7:
                cvss_buckets['3to7'] += 1
            elif 7 <= cve_tuple[1] <= 10:
                cvss_buckets['7to10'] += 1

        cve_metadata_missing = [cve for cve in new_cves if cve not in cves_in_db]
        cve_system_list = [(inventory_id, cve) for cve in new_cves]

        # Insert new CVEs into db
        if cve_metadata_missing:
            self._register_missing_cves(cve_metadata_missing, cur)

        execute_values(cur, "insert into system_vulnerabilities \
                       (inventory_id, cve) values %s \
                       returning cve, id",
                       cve_system_list, page_size=len(cve_system_list))
        for cve, sys_vuln_id in cur.fetchall():
            system_cves_id_map[cve] = sys_vuln_id

        for level in cvss_buckets:
            if cvss_buckets[level]:
                msg = {
                    'application': 'vulnerability',
                    'event_type': 'new-host-cve',
                    'timestamp': datetime.utcnow().isoformat(),
                    'account_id': rh_account,
                    'level': level,
                    'message': 'Discovered %s new CVEs with cvss score within %s radius for host id: %s' % (
                        cvss_buckets[level], level, inventory_id),
                }
                WEBHOOKS_QUEUE.send(msg)
        return system_cves_id_map

    @staticmethod
    def _update_mitigated_cves(inventory_id, mitigated_cves, cur):
        if not mitigated_cves:
            return

        cur.execute("update system_vulnerabilities set when_mitigated = now() \
        where inventory_id = %s and cve in %s", (inventory_id,
                                                 tuple(mitigated_cves),))

    @staticmethod
    def _update_unmitigated_cves(inventory_id, unmitigated_cves, cur):
        if not unmitigated_cves:
            return

        cur.execute("update system_vulnerabilities set when_mitigated = null, \
                    first_reported = now() where inventory_id = %s and \
                    cve in %s", (inventory_id,
                                 tuple(unmitigated_cves),))

    @staticmethod
    def _update_system(inventory_id, cve_count, cur):
        cur.execute("""update system_platform set last_evaluation = now(),
                                                  cve_count_cache = %s
                       where inventory_id = %s""",
                    (cve_count, inventory_id,))

    @staticmethod
    def _update_cve_affected_systems_cache(new_cves, unmitigated_cves, mitigated_cves, rh_account, sat_managed, cur):
        # pylint: disable=too-many-branches
        if not new_cves and not unmitigated_cves and not mitigated_cves:
            return
        all_cves = new_cves.copy()
        all_cves.update(unmitigated_cves)
        all_cves.update(mitigated_cves)
        inc_cves = []
        dec_cves = []
        delete_cves = []
        cur.execute("""select cve, systems_affected from cve_affected_systems_cache
                       where rh_account = %s and cve in %s
                       order by cve for update""",
                    (rh_account, tuple(all_cves),))
        for cve, systems_affected in cur.fetchall():
            if cve in new_cves or cve in unmitigated_cves:
                inc_cves.append(cve)
            elif cve in mitigated_cves and systems_affected > 1:
                dec_cves.append(cve)
            elif cve in mitigated_cves:
                delete_cves.append(cve)
            # cves not in DB cache
            all_cves.remove(cve)
        # filter out rest of cves and insert cache for new and unmitigated
        insert_cves = [(cve, rh_account, 1, 0 if sat_managed else 1)
                       for cve in all_cves if cve in new_cves or cve in unmitigated_cves]
        if inc_cves:
            if sat_managed:
                cur.execute("""update cve_affected_systems_cache set systems_affected = systems_affected + 1
                               where rh_account = %s and cve in %s""", (rh_account, tuple(inc_cves)))
            else:
                cur.execute("""update cve_affected_systems_cache set systems_affected = systems_affected + 1,
                                 direct_systems_affected = direct_systems_affected + 1
                               where rh_account = %s and cve in %s""", (rh_account, tuple(inc_cves)))
        if dec_cves:
            if sat_managed:
                cur.execute("""update cve_affected_systems_cache set systems_affected = systems_affected - 1
                               where rh_account = %s and cve in %s""", (rh_account, tuple(dec_cves)))
            else:
                cur.execute("""update cve_affected_systems_cache set systems_affected = systems_affected - 1,
                                 direct_systems_affected = direct_systems_affected - 1
                               where rh_account = %s and cve in %s""", (rh_account, tuple(dec_cves)))
        if delete_cves:
            cur.execute("""delete from cve_affected_systems_cache
                           where rh_account = %s and cve in %s""", (rh_account, tuple(delete_cves)))
        if insert_cves:
            execute_values(cur, """insert into cve_affected_systems_cache
                                   (cve, rh_account, systems_affected, direct_systems_affected) values %s
                                   on conflict (cve, rh_account) do update set
                                     systems_affected = cve_affected_systems_cache.systems_affected
                                                      + excluded.systems_affected,
                                     direct_systems_affected = cve_affected_systems_cache.direct_systems_affected
                                                             + excluded.direct_systems_affected""",
                           insert_cves, page_size=len(insert_cves))

    def _vmaas_request_cves(self, vmaas_request_json):
        """Make VMaaS request for cves"""
        system_cves = set()
        vulnerabilities_response_json = vmaas_post_request(vmaas_vulnerabilities_endpoint,
                                                           vmaas_request_json, session=self.session)
        if vulnerabilities_response_json is not None:
            for cve in vulnerabilities_response_json['cve_list']:
                system_cves.add(cve)
        return system_cves

    @VMAAS_EVAL_TIME.time()
    def evaluate_vmaas(self, system_platform, cur):
        """Evaluates messages received from vmaas"""
        VMAAS_COUNT.inc()
        inventory_id = system_platform[0]
        LOGGER.info("Evaluating vulnerabilities for inventory_id: %s", inventory_id)
        # JSON to POST requests to vmaas vulnerabilities endpoint
        vmaas_request_json = json.loads(system_platform[1])
        rh_account = system_platform[2]
        opt_out = system_platform[3]
        satellite_managed = system_platform[4]

        system_cves_map = self._load_cves_for_inventory_id(inventory_id, cur)
        unprocessed_cves = set(system_cves_map.keys())
        new_cves = set()
        mitigated_cves = set()
        unmitigated_cves = set()

        reported_cves = self._vmaas_request_cves(vmaas_request_json)

        for cve in reported_cves:
            if cve in system_cves_map:
                unprocessed_cves.discard(cve)
                if system_cves_map[cve]['when_mitigated']:
                    # it was mitigated, now its not
                    unmitigated_cves.add(cve)
            else:
                new_cves.add(cve)

        for cve in unprocessed_cves:
            mitigated_cves.add(cve)

        self._store_new_cves(inventory_id, new_cves, rh_account, cur)
        self._update_mitigated_cves(inventory_id, mitigated_cves, cur)
        self._update_unmitigated_cves(inventory_id, unmitigated_cves, cur)
        self._update_system(inventory_id, len(reported_cves), cur)
        # don't update cve cache for opted out system
        if not opt_out:
            # pylint: disable=too-many-function-args
            self._update_cve_affected_systems_cache(new_cves, unmitigated_cves,
                                                    mitigated_cves, rh_account, satellite_managed, cur)

        LOGGER.debug("Finished evaluating vulnerabilities for inventory_id: %s", inventory_id)

    def run(self):
        """
        This method evaluates incoming system package profiles using VMaaS
        :return:
        """

        loop = asyncio.get_event_loop()
        signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
        for sig in signals:
            loop.add_signal_handler(
                sig, lambda sig=sig: loop.create_task(terminate(sig, loop)))

        # pylint: disable=too-many-branches
        def process_message(message):
            """Message procession logic"""
            if message.topic in kafka_evaluator_topic:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if 'type' not in msg_dict:
                    LOGGER.error("Received message is missing type field: %s", msg_dict)
                    return
                if msg_dict['type'] in ['upload_new_file', 're-evaluate_system']:
                    with DatabasePoolConnection() as conn:
                        with conn.cursor() as cur:
                            LOGGER.info("Received message type: %s", msg_dict['type'])
                            # Lock the system for processing
                            cur.execute("""SELECT inventory_id, vmaas_json, rh_account,
                                                opt_out, satellite_managed FROM system_platform
                                        WHERE inventory_id = %s
                                        FOR UPDATE""", (msg_dict['system_id'],))
                            system_platform = cur.fetchone()
                            if system_platform is not None:
                                try:
                                    self.evaluate_vmaas(system_platform, cur)
                                    conn.commit()
                                except DatabaseError:
                                    LOGGER.exception("Unable to store data: ")
                                    conn.rollback()
                            else:
                                INV_ID_NOT_FOUND.inc()
                                LOGGER.error("System with inventory_id not found in DB: %s", msg_dict['system_id'])
                else:
                    UNKNOWN_MSG.inc()
                    LOGGER.error("Received unknown message type: %s", msg_dict['type'])
            else:
                UNKNOWN_TOPIC.inc()
                LOGGER.error("Received message on unsupported topic: %s", message.topic)

        with DatabasePool(1):
            CONSUMER_QUEUE.listen(process_message)

            # wait until loop is stopped from terminate callback
            loop.run_forever()

            LOGGER.info("Shutting down.")
            self.session.close()


def run_evaluator():
    """Sets up and runs the evaluator"""
    evaluator = QueueEvaluator()
    evaluator.run()


def main():
    """Sets up and run whole application"""
    # Set up endpoint for prometheus monitoring
    init_logging()
    LOGGER.info("Opening port [%s] for prometheus", prometheus_port)
    start_http_server(int(prometheus_port))
    run_evaluator()


if __name__ == "__main__":
    main()
