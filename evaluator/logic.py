"""
Vulnerability engine evaluator logic component
"""
from typing import List, Dict
import json
from datetime import datetime

from psycopg import AsyncConnection
from psycopg.rows import dict_row
from psycopg.types.json import Jsonb
from psycopg_pool.pool_async import AsyncConnectionPool

from common.peewee_model import VulnerabilityState
from common.logging import get_logger
from common.vmaas_client import vmaas_request
from common.constants import format_vmaas_cve_endpoint
from .common import (CveAdvisories, Vulnerability, SystemPlatform,
                     VmaasErrorException, CveImpactCache, CveCache,
                     RuleCache, CFG, VMAAS_EVAL_TIME, RULES_EVAL_TIME)

LOGGER = get_logger(__name__)


class EvaluatorLogic:
    # pylint: disable=no-self-use
    """Implements a logic for evaluating and combining vmaas and advisor rule results"""

    def __init__(self, db_pool: AsyncConnectionPool):
        """Constructor"""
        self.db_pool: AsyncConnectionPool = db_pool
        self.cve_impact_cache: Dict[str, CveImpactCache] = {}
        self.cve_cache: Dict[str, CveCache] = {}

    async def init(self):
        """Async constructor"""
        self.cve_impact_cache = await self._load_cve_impact_cache()
        self.cve_cache = await self._load_cve_cache()

    async def _load_cve_impact_cache(self) -> Dict[str, CveImpactCache]:
        """Load cve impact cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name FROM cve_impact""")
                for cve_impact in await cur.fetchall():
                    cache[cve_impact["name"]] = CveImpactCache(cve_impact["id"])
        return cache

    async def _load_cve_cache(self) -> Dict[str, CveCache]:
        """Load cve cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, cve FROM cve_metadata""")
                for cve in await cur.fetchall():
                    cache[cve["cve"]] = CveCache(cve["id"])
        return cache

    async def _load_rule_cache(self, conn: AsyncConnection) -> Dict[str, RuleCache]:
        """Load rule cache from DB"""
        cache = {}
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute("""SELECT id, name, playbook_count FROM insights_rule""")
            for rule in await cur.fetchall():
                cache[rule["name"]] = RuleCache(rule["id"], rule["playbook_count"])
        return cache

    def _construct_cve_row(self, cve: Dict) -> Dict:
        """Construct CVE row (dict) for insertion to DB"""
        res = cve.copy()
        res["impact_id"] = self.cve_impact_cache[cve["impact"]].id
        res["cvss3_score"] = float(res["cvss3_score"]) if cve.get("cvss3_score") else None
        res["cvss3_metrics"] = res.get("cvss3_metrics")
        res["cvss2_score"] = float(res["cvss2_score"]) if cve.get("cvss2_score") else None
        res["cvss2_metrics"] = res.get("cvss2_metrics")
        res["redhat_url"] = res.get("redhat_url")
        res["secondary_url"] = res.get("secondary_url")
        res["advisories_list"] = Jsonb(res.get("errata_list"))
        return res

    async def _insert_cve(self, cve: str, conn: AsyncConnection):
        """Insert CVE into database and add it to the cache,
           attempts to fetch CVE from vmaas"""
        async with conn.cursor(row_factory=dict_row) as cur:
            LOGGER.info("attempting to get %s data from VMAAS", cve)
            cve_request_endpoint = format_vmaas_cve_endpoint(cve)

            cve_page = await vmaas_request(cve_request_endpoint, method="GET")
            cve_data = None
            try:
                cve_data = cve_page["cve_list"][cve]
            except (KeyError, TypeError):
                LOGGER.error("error importing %s from VMAAS", cve)

            if cve_data:
                cve_row = self._construct_cve_row(cve_data)
                await cur.execute("""INSERT INTO cve_metadata
                                    (cve, description, impact_id, public_date, modified_date,
                                    cvss3_score, cvss3_metrics, cvss2_score, cvss2_metrics, redhat_url,
                                    secondary_url, advisories_list)
                                    VALUES (%(synopsis)s, %(description)s, %(impact_id)s, %(public_date)s, %(modified_date)s,
                                            %(cvss3_score)s, %(cvss3_metrics)s, %(cvss2_score)s, %(cvss2_metrics)s,
                                            %(redhat_url)s, %(secondary_url)s, %(advisories_list)s)
                                    ON CONFLICT (cve) DO UPDATE SET
                                    description = EXCLUDED.description,
                                    impact_id = EXCLUDED.impact_id,
                                    public_date = EXCLUDED.public_date,
                                    modified_date = EXCLUDED.modified_date,
                                    cvss3_score = EXCLUDED.cvss3_score,
                                    cvss3_metrics = EXCLUDED.cvss3_metrics,
                                    cvss2_score = EXCLUDED.cvss2_score,
                                    cvss2_metrics = EXCLUDED.cvss2_metrics,
                                    redhat_url = EXCLUDED.redhat_url,
                                    secondary_url = EXCLUDED.secondary_url,
                                    advisories_list = EXCLUDED.advisories_list
                                    RETURNING id, cve""", cve_row)
            else:
                await cur.execute("""INSERT INTO cve_metadata (cve, description, impact_id)
                                     VALUES (%s, %s, %s)
                                     ON CONFLICT (cve) DO UPDATE SET cve = %s
                                     RETURNING id, cve""", (cve, "unknown", 0, cve))
            row = await cur.fetchone()
            self.cve_cache[row["cve"]] = CveCache(row["id"])

    async def _get_or_upsert_cve(self, cve: str, conn: AsyncConnection) -> CveCache:
        """Returns CVE from cache, or inserts the CVE into DB and cache"""
        if cve not in self.cve_cache:
            await self._insert_cve(cve, conn)
        return self.cve_cache[cve]

    async def _insert_rule(self,
                           rule: str,
                           rule_cves: [str],
                           conn: AsyncConnection,
                           rule_only=False) -> int:
        """Inserts rule into DB and returns its ID"""
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute("""INSERT INTO insights_rule (name, rule_only)
                                 VALUES (%s, %s)
                                 ON CONFLICT (name) DO UPDATE
                                 SET name = %s, rule_only = %s
                                 RETURNING id""", (rule, rule_only, rule, rule_only))
            row = await cur.fetchone()
            to_insert = []
            for cve in rule_cves:
                cve_db = await self._get_or_upsert_cve(cve, conn)
                to_insert.append((row["id"], cve_db.id))
            await cur.executemany("""INSERT INTO cve_rule_mapping (rule_id, cve_id)
                                     VALUES (%s, %s)
                                     ON CONFLICT DO NOTHING""", to_insert)
            return row["id"]

    async def _perform_vmaas_request(self, vmaas_req: str) -> (List[CveAdvisories], List[CveAdvisories]):
        """Perform VMAAS request for package based evaluation"""
        playbook_cves = []
        manually_fixable_cves = []

        vmaas_json = json.loads(vmaas_req)

        if not vmaas_json.get("package_list", []) or not vmaas_json.get("repository_list", []):
            return playbook_cves, manually_fixable_cves

        vmaas_json["epoch_required"] = True
        vmaas_response = await vmaas_request(CFG.vmaas_vulnerabilities_endpoint, vmaas_json)
        if vmaas_response:
            for cve in vmaas_response["cve_list"]:
                playbook_cves.append(CveAdvisories(cve["cve"], ",".join(sorted(cve["errata"] or [])) or None))
            for cve in vmaas_response["manually_fixable_cve_list"]:
                manually_fixable_cves.append(CveAdvisories(cve["cve"], ",".join(sorted(cve["errata"] or [])) or None))
        else:
            raise VmaasErrorException("cannot evaluate system, unable to contact vmaas for evaluation")
        return playbook_cves, manually_fixable_cves

    async def _evaluate_vmaas_res(self,
                                  playbook_cves: List[CveAdvisories],
                                  manually_fixable_cves: List[CveAdvisories],
                                  results: dict,
                                  system_platform: SystemPlatform,
                                  conn: AsyncConnection) -> dict:
        """Insert vmaas cve results"""
        # system is pontentially vulnerable to cves returned from vmaas
        for cve_adv in playbook_cves:
            cve = await self._get_or_upsert_cve(cve_adv.name, conn)
            results[cve_adv.name] = Vulnerability(
                VulnerabilityState.VULNERABLE_BY_PACKAGE,
                system_platform.rh_account_id,
                system_platform.id,
                cve.id, cve_adv.advisories, True,
                None, None, None, None, None)
        for cve_adv in manually_fixable_cves:
            cve = await self._get_or_upsert_cve(cve_adv.name, conn)
            results[cve_adv.name] = Vulnerability(
                VulnerabilityState.VULNERABLE_BY_PACKAGE,
                system_platform.rh_account_id,
                system_platform.id,
                cve.id, cve_adv.advisories, False,
                None, None, None, None, None)
        return results

    async def _get_or_upsert_rule(self,
                                  rule: str,
                                  rule_details_raw: str,
                                  rule_cache: Dict[str, RuleCache],
                                  conn: AsyncConnection,
                                  rule_only=False) -> Dict[str, RuleCache]:
        """Returns rule from cache, or inserts the rule into DB and cache"""
        if rule not in rule_cache:
            rule_details = json.loads(rule_details_raw)
            rule_id = await self._insert_rule(rule, rule_details["cves"].keys(), conn, rule_only=rule_only)
            rule_cache[rule] = RuleCache(rule_id, None)
        return rule_cache

    async def _evaluate_advisor_res(self,
                                    rule_results: dict,
                                    results: Dict[str, Vulnerability],
                                    rule_cache: Dict[str, RuleCache],
                                    system_platform: SystemPlatform,
                                    conn: AsyncConnection) -> Dict[str, Vulnerability]:
        """Merge results from vmaas package evaluation with advisor rule evaluation"""
        for cve, hit_details in rule_results["rule_hits"].items():
            cve_id = await self._get_or_upsert_cve(cve, conn)

            rule = hit_details["rule_id"]
            rule_cache = await self._get_or_upsert_rule(rule, hit_details["details"], rule_cache, conn)
            rule_db = rule_cache[rule]

            # if the system is not vulnerable to CVE from vmaas, we expect that it does not have advisory
            vulnerability = results.get(cve)
            if vulnerability:
                # system was vulnerable for cve from vmaas and also is for rule
                vulnerability.state = VulnerabilityState.VULNERABLE_BY_RULE_AND_PACKAGE
            else:
                # system is vulnerable for cve from rule, but not from vmaas
                vulnerability = Vulnerability(
                    VulnerabilityState.VULNERABLE_BY_RULE,
                    system_platform.rh_account_id,
                    system_platform.id,
                    cve_id.id, None, False, datetime.utcnow(),
                    None, None, None, None)
            vulnerability.add_rule_info(rule_db.id, hit_details["details"], rule_db.playbook_count, None)
            results[cve] = vulnerability

        for cve, pass_details in rule_results["rule_passes"].items():
            package_vulnerability = results.pop(cve, None)

            if not package_vulnerability:
                continue

            # system was marked vulnerable from vmaas but not from by rules -> abnv
            rule = pass_details["rule_id"]
            rule_cache = await self._get_or_upsert_rule(rule, pass_details["details"], rule_cache, conn, rule_only=True)
            rule_db = rule_cache[rule]

            package_vulnerability.add_rule_info(rule_db.id, pass_details["details"], rule_db.playbook_count, pass_details["mitigation_reason"])
            package_vulnerability.state = VulnerabilityState.VULNERABLE_BY_PACKAGE_NOT_RULE
            results[cve] = package_vulnerability

        return results

    async def evaluate_vulnerabilities(self,
                                       system_platform: SystemPlatform,
                                       conn: AsyncConnection) -> Dict[str, Vulnerability]:
        """Evaluate cve hits from vmaas and advisor"""
        results = {}

        if system_platform.vmaas_json:
            with VMAAS_EVAL_TIME.time():
                playbook_cves, manually_fixable_cves = await self._perform_vmaas_request(system_platform.vmaas_json)
                results = await self._evaluate_vmaas_res(playbook_cves, manually_fixable_cves, results, system_platform, conn)
        if system_platform.rule_results:
            # unfortunately, rule cache can change meanwhile evaluator is running,
            # so it cannot be static and needs to be loaded on each evaluation
            with RULES_EVAL_TIME.time():
                rule_cache = await self._load_rule_cache(conn)
                results = await self._evaluate_advisor_res(system_platform.rule_results, results, rule_cache, system_platform, conn)
        return results
