"""
Vulnerability engine evaluator logic component
"""
from typing import List, Dict, Tuple, Set
import json
from datetime import datetime

from psycopg import AsyncConnection
from psycopg.rows import dict_row
from psycopg.types.json import Jsonb
from psycopg_pool.pool_async import AsyncConnectionPool

from common.peewee_model import VulnerabilityState
from common.logging import get_logger
from common.vmaas_client import vmaas_request
from common.constants import format_vmaas_cve_endpoint
from .common import (
    CveAdvisories,
    CveUnpatched,
    SystemVulnerabilitiesRow,
    SystemPlatform,
    VmaasErrorException,
    CveImpactCache,
    CveCache,
    RuleCache,
    PackageNameCache,
    CpeCache,
    VulnerablePackageCache,
    CFG,
    VMAAS_EVAL_TIME,
    RULES_EVAL_TIME,
)

LOGGER = get_logger(__name__)


class EvaluatorLogic:
    # pylint: disable=no-self-use
    """Implements a logic for evaluating and combining vmaas and advisor rule results"""

    def __init__(self, db_pool: AsyncConnectionPool):
        """Constructor"""
        self.db_pool: AsyncConnectionPool = db_pool
        self.cve_impact_cache: Dict[str, CveImpactCache] = {}
        self.cve_cache: Dict[str, CveCache] = {}
        self.package_name_cache: Dict[str, PackageNameCache] = {}
        self.cpe_cache: Dict[str, CpeCache] = {}
        self.vulnerable_package_cache: Dict[(int, int), VulnerablePackageCache] = {}

    async def init(self):
        """Async constructor"""
        self.cve_impact_cache = await self._load_cve_impact_cache()
        self.cve_cache = await self._load_cve_cache()
        self.package_name_cache = await self._load_package_name_cache()
        self.cpe_cache = await self._load_cpe_cache()
        self.vulnerable_package_cache = await self._load_vulnerable_package_cache()

    async def _load_cve_impact_cache(self) -> Dict[str, CveImpactCache]:
        """Load cve impact cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name FROM cve_impact""")
                for cve_impact in await cur.fetchall():
                    cache[cve_impact["name"]] = CveImpactCache(cve_impact["id"])
        return cache

    async def _load_cve_cache(self) -> Dict[str, CveCache]:
        """Load cve cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, cve FROM cve_metadata""")
                for cve in await cur.fetchall():
                    cache[cve["cve"]] = CveCache(cve["id"])
        return cache

    async def _load_rule_cache(self, conn: AsyncConnection) -> Dict[str, RuleCache]:
        """Load rule cache from DB"""
        cache = {}
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute("""SELECT id, name, playbook_count FROM insights_rule""")
            for rule in await cur.fetchall():
                cache[rule["name"]] = RuleCache(rule["id"], rule["playbook_count"])
        return cache

    async def _load_package_name_cache(self) -> Dict[str, PackageNameCache]:
        """Load package name cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name FROM package_name""")
                for package_name in await cur.fetchall():
                    cache[package_name["name"]] = PackageNameCache(package_name["id"])
        return cache

    async def _load_cpe_cache(self) -> Dict[str, CpeCache]:
        """Load cpe cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name FROM cpe""")
                for cpe in await cur.fetchall():
                    cache[cpe["name"]] = CpeCache(cpe["id"])
        return cache

    async def _load_vulnerable_package_cache(self) -> Dict[Tuple[int, int], VulnerablePackageCache]:
        """Load vulnerable package cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, package_name_id, cpe_id FROM vulnerable_package""")
                for vulnerable_package in await cur.fetchall():
                    cache[(vulnerable_package["package_name_id"], vulnerable_package["cpe_id"])] = VulnerablePackageCache(
                        vulnerable_package["id"]
                    )
        return cache

    def _construct_cve_row(self, cve: Dict) -> Dict:
        """Construct CVE row (dict) for insertion to DB"""
        res = cve.copy()
        res["impact_id"] = self.cve_impact_cache[cve["impact"]].id
        res["cvss3_score"] = float(res["cvss3_score"]) if cve.get("cvss3_score") else None
        res["cvss3_metrics"] = res.get("cvss3_metrics")
        res["cvss2_score"] = float(res["cvss2_score"]) if cve.get("cvss2_score") else None
        res["cvss2_metrics"] = res.get("cvss2_metrics")
        res["redhat_url"] = res.get("redhat_url")
        res["secondary_url"] = res.get("secondary_url")
        res["advisories_list"] = Jsonb(res.get("errata_list"))
        return res

    async def _insert_cve(self, cve: str):
        """Insert CVE into database and add it to the cache,
        attempts to fetch CVE from vmaas"""
        LOGGER.info("attempting to get %s data from VMAAS", cve)
        cve_request_endpoint = format_vmaas_cve_endpoint(cve)

        cve_page = await vmaas_request(cve_request_endpoint, method="GET")
        cve_data = None
        try:
            cve_data = cve_page["cve_list"][cve]
        except (KeyError, TypeError):
            LOGGER.error("error importing %s from VMAAS", cve)

        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    if cve_data:
                        cve_row = self._construct_cve_row(cve_data)
                        await cur.execute(
                            """INSERT INTO cve_metadata
                                            (cve, description, impact_id, public_date, modified_date,
                                            cvss3_score, cvss3_metrics, cvss2_score, cvss2_metrics, redhat_url,
                                            secondary_url, advisories_list)
                                            VALUES (%(synopsis)s, %(description)s, %(impact_id)s, %(public_date)s, %(modified_date)s,
                                                    %(cvss3_score)s, %(cvss3_metrics)s, %(cvss2_score)s, %(cvss2_metrics)s,
                                                    %(redhat_url)s, %(secondary_url)s, %(advisories_list)s)
                                            ON CONFLICT (cve) DO UPDATE SET
                                            description = EXCLUDED.description,
                                            impact_id = EXCLUDED.impact_id,
                                            public_date = EXCLUDED.public_date,
                                            modified_date = EXCLUDED.modified_date,
                                            cvss3_score = EXCLUDED.cvss3_score,
                                            cvss3_metrics = EXCLUDED.cvss3_metrics,
                                            cvss2_score = EXCLUDED.cvss2_score,
                                            cvss2_metrics = EXCLUDED.cvss2_metrics,
                                            redhat_url = EXCLUDED.redhat_url,
                                            secondary_url = EXCLUDED.secondary_url,
                                            advisories_list = EXCLUDED.advisories_list
                                            RETURNING id, cve""",
                            cve_row,
                        )
                    else:
                        await cur.execute(
                            """INSERT INTO cve_metadata (cve, description, impact_id)
                                            VALUES (%s, %s, %s)
                                            ON CONFLICT (cve) DO UPDATE SET cve = %s
                                            RETURNING id, cve""",
                            (cve, "unknown", 0, cve),
                        )
                    row = await cur.fetchone()
            self.cve_cache[row["cve"]] = CveCache(row["id"])

    async def _insert_package_name(self, package_name: str):
        """Insert package name into database and add it to the cache"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    await cur.execute(
                        """INSERT INTO package_name (name)
                                        VALUES (%s)
                                        ON CONFLICT (name) DO UPDATE SET name = %s
                                        RETURNING id, name""",
                        (package_name, package_name),
                    )
                    row = await cur.fetchone()
            self.package_name_cache[row["name"]] = PackageNameCache(row["id"])

    async def _insert_cpe(self, cpe: str):
        """Insert CPE into database and add it to the cache"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    await cur.execute(
                        """INSERT INTO cpe (name)
                                        VALUES (%s)
                                        ON CONFLICT (name) DO UPDATE SET name = %s
                                        RETURNING id, name""",
                        (cpe, cpe),
                    )
                    row = await cur.fetchone()
            self.cpe_cache[row["name"]] = CpeCache(row["id"])

    async def _insert_vulnerable_package(self, package_name_id: int, cpe_id: int):
        """Insert vulnerable package into database and add it to the cache"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    await cur.execute(
                        """INSERT INTO vulnerable_package (package_name_id, cpe_id)
                                        VALUES (%s, %s)
                                        ON CONFLICT (package_name_id, cpe_id) DO UPDATE SET package_name_id = %s, cpe_id = %s
                                        RETURNING id, package_name_id, cpe_id""",
                        (package_name_id, cpe_id, package_name_id, cpe_id),
                    )
                    row = await cur.fetchone()
            self.vulnerable_package_cache[(row["package_name_id"], row["cpe_id"])] = VulnerablePackageCache(row["id"])

    async def _get_or_upsert_cve(self, cve: str) -> CveCache:
        """Returns CVE from cache, or inserts the CVE into DB and cache"""
        if cve not in self.cve_cache:
            await self._insert_cve(cve)
        return self.cve_cache[cve]

    async def _get_or_upsert_package_name(self, package_name: str) -> PackageNameCache:
        """Returns package name from cache, or inserts the package_name into DB and cache"""
        if package_name not in self.package_name_cache:
            await self._insert_package_name(package_name)
        return self.package_name_cache[package_name]

    async def _get_or_upsert_cpe(self, cpe: str) -> CpeCache:
        """Returns CPE from cache, or inserts the CPE into DB and cache"""
        if cpe not in self.cpe_cache:
            await self._insert_cpe(cpe)
        return self.cpe_cache[cpe]

    async def _get_or_upsert_vulnerable_package(self, package_name_id: int, cpe_id: int) -> VulnerablePackageCache:
        """Returns vulnerable package from cache, or inserts the vulnerable package into DB and cache"""
        if (package_name_id, cpe_id) not in self.vulnerable_package_cache:
            await self._insert_vulnerable_package(package_name_id, cpe_id)
        return self.vulnerable_package_cache[(package_name_id, cpe_id)]

    async def _insert_rule(self, rule: str, rule_cves: [str], conn: AsyncConnection, rule_only=False) -> int:
        """Inserts rule into DB and returns its ID"""
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """INSERT INTO insights_rule (name, rule_only)
                                 VALUES (%s, %s)
                                 ON CONFLICT (name) DO UPDATE
                                 SET name = %s, rule_only = %s
                                 RETURNING id""",
                (rule, rule_only, rule, rule_only),
            )
            row = await cur.fetchone()
            to_insert = []
            for cve in rule_cves:
                cve_db = await self._get_or_upsert_cve(cve)
                to_insert.append((row["id"], cve_db.id))
            await cur.executemany(
                """INSERT INTO cve_rule_mapping (rule_id, cve_id)
                                     VALUES (%s, %s)
                                     ON CONFLICT DO NOTHING""",
                to_insert,
            )
            return row["id"]

    async def _perform_vmaas_request(self, vmaas_req: str) -> (List[CveAdvisories], List[CveAdvisories], List[CveUnpatched]):
        """Perform VMAAS request for package based evaluation"""
        playbook_cves = []
        manually_fixable_cves = []
        unpatched_cves = []

        vmaas_json = json.loads(vmaas_req)

        if not vmaas_json.get("package_list", []) or not vmaas_json.get("repository_list", []):
            return playbook_cves, manually_fixable_cves, unpatched_cves

        vmaas_json["epoch_required"] = True
        vmaas_json["extended"] = True
        vmaas_response = await vmaas_request(CFG.vmaas_vulnerabilities_endpoint, vmaas_json)
        if vmaas_response:
            for cve in vmaas_response["cve_list"]:
                playbook_cves.append(CveAdvisories(cve["cve"], ",".join(sorted(cve["errata"] or [])) or None))
            for cve in vmaas_response["manually_fixable_cve_list"]:
                manually_fixable_cves.append(CveAdvisories(cve["cve"], ",".join(sorted(cve["errata"] or [])) or None))
            for cve in vmaas_response["unpatched_cve_list"]:
                for affected_package in cve["affected"]:
                    unpatched_cves.append(CveUnpatched(cve["cve"], affected_package["package_name"], affected_package["cpe"]))
        else:
            raise VmaasErrorException("cannot evaluate system, unable to contact vmaas for evaluation")
        return playbook_cves, manually_fixable_cves, unpatched_cves

    async def _load_db_vulnerable_package_cve(self, vuln_package_ids: List[int], conn: AsyncConnection) -> Dict[int, Set[int]]:
        """Make map from vulnerable_package, cve pairs in db"""
        pkg_map = {}
        if not vuln_package_ids:
            return pkg_map
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """
                SELECT vulnerable_package_id, cve_id
                FROM vulnerable_package_cve
                WHERE vulnerable_package_id = ANY (%s)
                """,
                (vuln_package_ids,),
            )
            for vuln_pkg_cve in await cur.fetchall():
                pkg_map.setdefault(vuln_pkg_cve["vulnerable_package_id"], set()).add(vuln_pkg_cve["cve_id"])
        return pkg_map

    async def _compare_vulnerable_package_cve(
        self, vuln_package_cve_db: Dict[int, Set[int]], vuln_package_cve: Dict[int, Set[int]]
    ) -> Tuple[List, List]:
        """Compare vulnerable package cves in DB with fresh evaluated cves"""
        to_insert, to_delete = [], []
        for vuln_package_id, cves in vuln_package_cve.items():
            cves_db = vuln_package_cve_db.get(vuln_package_id, set())
            for cve_id in cves:
                # vulnerability is not in db, we need to insert it
                if cve_id not in cves_db:
                    to_insert.append((vuln_package_id, cve_id))
                else:
                    cves_db.remove(cve_id)

        # remaining vuln_package_cve_db map are cves that we do not know anything about anymore
        for vuln_package_id, cves in vuln_package_cve_db.items():
            for cve_id in cves:
                to_delete.append((vuln_package_id, cve_id))

        return sorted(to_insert), sorted(to_delete)

    async def _insert_vulnerable_package_cve(self, to_insert: List[Tuple[int, int]], conn: AsyncConnection):
        """Insert given vulnerable package cves to table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """INSERT INTO vulnerable_package_cve (vulnerable_package_id, cve_id)
                                     VALUES (%s, %s)
                                     ON CONFLICT DO NOTHING
                                     """,
                to_insert,
            )

    async def _delete_vulnerable_package_cve(self, to_delete: List[Tuple[int, int]], conn: AsyncConnection):
        """Delete given vulnerable package cves from table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """DELETE FROM vulnerable_package_cve
                                     WHERE vulnerable_package_id = %s
                                       AND cve_id = %s
                                     """,
                to_delete,
            )

    async def _load_db_system_vulnerable_package(self, system_platform: SystemPlatform, conn: AsyncConnection) -> Set[int]:
        """Make map from system, vulnerable_package pairs in db"""
        pkgs = set()
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """
                SELECT vulnerable_package_id
                FROM system_vulnerable_package
                WHERE rh_account_id = %s
                  AND system_id = %s
                """,
                (system_platform.rh_account_id, system_platform.id),
            )
            for system_vuln_pkg in await cur.fetchall():
                pkgs.add(system_vuln_pkg["vulnerable_package_id"])
        return pkgs

    async def _compare_system_vulnerable_package(
        self, system_platform: SystemPlatform, system_vuln_package_db: Set[int], system_vuln_package: List[int]
    ) -> Tuple[List, List]:
        """Compare system vulnerable packages in DB with fresh evaluated result"""
        to_insert, to_delete = [], []
        for vuln_package_id in system_vuln_package:
            # vulnerability is not in db, we need to insert it
            if vuln_package_id not in system_vuln_package_db:
                to_insert.append((system_platform.rh_account_id, system_platform.id, vuln_package_id))
            else:
                system_vuln_package_db.remove(vuln_package_id)

        # remaining system_vuln_package_db set are vulnerable packages we do not know anything about anymore
        for vuln_package_id in system_vuln_package_db:
            to_delete.append((system_platform.rh_account_id, system_platform.id, vuln_package_id))

        return sorted(to_insert), sorted(to_delete)

    async def _insert_system_vulnerable_package(self, to_insert: List[Tuple[int, int, int]], conn: AsyncConnection):
        """Insert given system vulnerable packages to table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """INSERT INTO system_vulnerable_package
                                     (rh_account_id, system_id, vulnerable_package_id, first_reported)
                                     VALUES (%s, %s, %s, now())
                                     ON CONFLICT DO NOTHING
                                     """,
                to_insert,
            )

    async def _delete_system_vulnerable_package(self, to_delete: List[Tuple[int, int, int]], conn: AsyncConnection):
        """Delete given system vulnerable packages from table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """DELETE FROM system_vulnerable_package
                                     WHERE rh_account_id = %s
                                       AND system_id = %s
                                       AND vulnerable_package_id = %s
                                     """,
                to_delete,
            )

    async def _evaluate_vmaas_res(
        self,
        playbook_cves: List[CveAdvisories],
        manually_fixable_cves: List[CveAdvisories],
        unpatched_cves: List[CveUnpatched],
        sys_vuln_rows: dict,
        system_platform: SystemPlatform,
        conn: AsyncConnection,
    ) -> dict:
        """Insert vmaas cve results"""

        # system is potentially vulnerable to cves returned from vmaas
        for cve_adv in playbook_cves:
            cve = await self._get_or_upsert_cve(cve_adv.name)
            sys_vuln_rows[cve_adv.name] = SystemVulnerabilitiesRow(
                VulnerabilityState.VULNERABLE_BY_PACKAGE,
                system_platform.rh_account_id,
                system_platform.id,
                cve.id,
                cve_adv.advisories,
                True,
                None,
                None,
                None,
                None,
                None,
            )

        for cve_adv in manually_fixable_cves:
            cve = await self._get_or_upsert_cve(cve_adv.name)
            sys_vuln_rows[cve_adv.name] = SystemVulnerabilitiesRow(
                VulnerabilityState.VULNERABLE_BY_PACKAGE,
                system_platform.rh_account_id,
                system_platform.id,
                cve.id,
                cve_adv.advisories,
                True,
                None,
                None,
                None,
                None,
                None,
            )

        # don't look on unfixed cves if the feature flag is off
        if not CFG.cves_without_errata_evaluator:
            return sys_vuln_rows

        # aggregate unfixed cves, get (package name, cpe) pairs and list of cves for these pairs
        pn_cpes = {}
        for cve_unpatched in unpatched_cves:
            cve_cache = await self._get_or_upsert_cve(cve_unpatched.cve)
            pn_cpes.setdefault((cve_unpatched.package_name, cve_unpatched.cpe), set()).add(cve_cache.id)

        vuln_package_cve = {}
        for (package_name, cpe), cve_ids in pn_cpes.items():
            package_name_cache = await self._get_or_upsert_package_name(package_name)
            cpe_cache = await self._get_or_upsert_cpe(cpe)
            vulnerable_package_cache = await self._get_or_upsert_vulnerable_package(package_name_cache.id, cpe_cache.id)
            vuln_package_cve[vulnerable_package_cache.id] = cve_ids

        # ensure all vulnerable_package_cve pairs are up to date
        vuln_package_cve_db = await self._load_db_vulnerable_package_cve(list(vuln_package_cve), conn)
        to_insert, to_delete = await self._compare_vulnerable_package_cve(vuln_package_cve_db, vuln_package_cve)
        LOGGER.debug(
            "system: %s, vulnerable_package_cve changes, i: %s, d: %s", system_platform.inventory_id, len(to_insert), len(to_delete)
        )
        if to_insert:
            await self._insert_vulnerable_package_cve(to_insert, conn)
        if to_delete:
            await self._delete_vulnerable_package_cve(to_delete, conn)

        # ensure all system_vulnerable_package pairs are up to date
        system_vuln_package_db = await self._load_db_system_vulnerable_package(system_platform, conn)
        to_insert, to_delete = await self._compare_system_vulnerable_package(
            system_platform, system_vuln_package_db, list(vuln_package_cve)
        )
        LOGGER.debug(
            "system: %s, system_vulnerable_package changes, i: %s, d: %s", system_platform.inventory_id, len(to_insert), len(to_delete)
        )
        if to_insert:
            await self._insert_system_vulnerable_package(to_insert, conn)
        if to_delete:
            await self._delete_system_vulnerable_package(to_delete, conn)

        return sys_vuln_rows

    async def _get_or_upsert_rule(
        self, rule: str, rule_details_raw: str, rule_cache: Dict[str, RuleCache], conn: AsyncConnection, rule_only=False
    ) -> Dict[str, RuleCache]:
        """Returns rule from cache, or inserts the rule into DB and cache"""
        if rule not in rule_cache:
            rule_details = json.loads(rule_details_raw)
            rule_id = await self._insert_rule(rule, rule_details["cves"].keys(), conn, rule_only=rule_only)
            rule_cache[rule] = RuleCache(rule_id, None)
        return rule_cache

    async def _evaluate_advisor_res(
        self,
        rule_results: dict,
        sys_vuln_rows: Dict[str, SystemVulnerabilitiesRow],
        rule_cache: Dict[str, RuleCache],
        system_platform: SystemPlatform,
        conn: AsyncConnection,
    ) -> Dict[str, SystemVulnerabilitiesRow]:
        """Merge results from vmaas package evaluation with advisor rule evaluation"""
        for cve, hit_details in rule_results["rule_hits"].items():
            cve_id = await self._get_or_upsert_cve(cve)

            rule = hit_details["rule_id"]
            rule_cache = await self._get_or_upsert_rule(rule, hit_details["details"], rule_cache, conn)
            rule_db = rule_cache[rule]

            # if the system is not vulnerable to CVE from vmaas, we expect that it does not have advisory
            vulnerability = sys_vuln_rows.get(cve)
            if vulnerability:
                # system was vulnerable for cve from vmaas and also is for rule
                vulnerability.state = VulnerabilityState.VULNERABLE_BY_RULE_AND_PACKAGE
            else:
                # system is vulnerable for cve from rule, but not from vmaas
                vulnerability = SystemVulnerabilitiesRow(
                    VulnerabilityState.VULNERABLE_BY_RULE,
                    system_platform.rh_account_id,
                    system_platform.id,
                    cve_id.id,
                    None,
                    False,
                    datetime.utcnow(),
                    None,
                    None,
                    None,
                    None,
                )
            vulnerability.add_rule_info(rule_db.id, hit_details["details"], rule_db.playbook_count, None)
            sys_vuln_rows[cve] = vulnerability

        for cve, pass_details in rule_results["rule_passes"].items():
            package_vulnerability = sys_vuln_rows.pop(cve, None)

            if not package_vulnerability:
                continue

            # system was marked vulnerable from vmaas but not from by rules -> abnv
            rule = pass_details["rule_id"]
            rule_cache = await self._get_or_upsert_rule(rule, pass_details["details"], rule_cache, conn, rule_only=True)
            rule_db = rule_cache[rule]

            package_vulnerability.add_rule_info(
                rule_db.id, pass_details["details"], rule_db.playbook_count, pass_details["mitigation_reason"]
            )
            package_vulnerability.state = VulnerabilityState.VULNERABLE_BY_PACKAGE_NOT_RULE
            sys_vuln_rows[cve] = package_vulnerability

        return sys_vuln_rows

    async def evaluate_vulnerabilities(self, system_platform: SystemPlatform, conn: AsyncConnection) -> Dict[str, SystemVulnerabilitiesRow]:
        """Evaluate cve hits from vmaas and advisor"""
        sys_vuln_rows = {}

        if system_platform.vmaas_json:
            with VMAAS_EVAL_TIME.time():
                playbook_cves, manually_fixable_cves, unpatched_cves = await self._perform_vmaas_request(system_platform.vmaas_json)
                sys_vuln_rows = await self._evaluate_vmaas_res(
                    playbook_cves, manually_fixable_cves, unpatched_cves, sys_vuln_rows, system_platform, conn
                )
        if system_platform.rule_results:
            # unfortunately, rule cache can change meanwhile evaluator is running,
            # so it cannot be static and needs to be loaded on each evaluation
            with RULES_EVAL_TIME.time():
                rule_cache = await self._load_rule_cache(conn)
                sys_vuln_rows = await self._evaluate_advisor_res(
                    system_platform.rule_results, sys_vuln_rows, rule_cache, system_platform, conn
                )
        return sys_vuln_rows
