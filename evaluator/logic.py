"""
Vulnerability engine evaluator logic component
"""
import json
from datetime import datetime
from typing import Dict
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple

from prometheus_async.aio import time
from psycopg import AsyncConnection
from psycopg.rows import dict_row
from psycopg.types.json import Jsonb
from psycopg_pool.pool_async import AsyncConnectionPool

from .common import CFG
from .common import CpeCache
from .common import CveAdvisories
from .common import CveCache
from .common import CveImpactCache
from .common import CveUnpatched
from .common import EVAL_PART_TIME
from .common import ModuleCache
from .common import PackageNameCache
from .common import RuleCache
from .common import RULES_EVAL_TIME
from .common import SystemPlatform
from .common import SystemVulnerabilitiesRow
from .common import VMAAS_EVAL_TIME
from .common import VmaasErrorException
from .common import VulnerablePackageCache
from common.constants import format_vmaas_cve_endpoint
from common.logging import get_logger
from common.peewee_model import VulnerabilityState
from common.vmaas_client import vmaas_request

LOGGER = get_logger(__name__)


class EvaluatorLogic:
    # pylint: disable=no-self-use
    """Implements a logic for evaluating and combining vmaas and advisor rule results"""

    def __init__(self, db_pool: AsyncConnectionPool):
        """Constructor"""
        self.db_pool: AsyncConnectionPool = db_pool
        self.cve_impact_cache: Dict[str, CveImpactCache] = {}
        self.cve_cache: Dict[str, CveCache] = {}
        self.package_name_cache: Dict[str, PackageNameCache] = {}
        self.cpe_cache: Dict[str, CpeCache] = {}
        self.module_cache: Dict[str, ModuleCache] = {}
        self.vulnerable_package_cache: Dict[(int, int, Optional[int]), VulnerablePackageCache] = {}
        self.skipped_rules = ["CVE_2017_5715_cpu_virt|VIRT_CVE_2017_5715_CPU_3_ONLYKERNEL", "CVE_2017_5715_cpu_virt"]

    async def init(self):
        """Async constructor"""
        self.cve_impact_cache = await self._load_cve_impact_cache()
        self.cve_cache = await self._load_cve_cache()
        self.package_name_cache = await self._load_package_name_cache()
        self.cpe_cache = await self._load_cpe_cache()
        self.module_cache = await self._load_module_cache()
        self.vulnerable_package_cache = await self._load_vulnerable_package_cache()

    async def _load_cve_impact_cache(self) -> Dict[str, CveImpactCache]:
        """Load cve impact cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name FROM cve_impact""")
                for cve_impact in await cur.fetchall():
                    cache[cve_impact["name"]] = CveImpactCache(cve_impact["id"])
        return cache

    async def _load_cve_cache(self) -> Dict[str, CveCache]:
        """Load cve cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, cve FROM cve_metadata""")
                for cve in await cur.fetchall():
                    cache[cve["cve"]] = CveCache(cve["id"])
        return cache

    async def _load_rule_cache(self, conn: AsyncConnection) -> Dict[str, RuleCache]:
        """Load rule cache from DB"""
        cache = {}
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute("""SELECT id, name, playbook_count FROM insights_rule""")
            for rule in await cur.fetchall():
                cache[rule["name"]] = RuleCache(rule["id"], rule["playbook_count"])
        return cache

    async def _load_package_name_cache(self) -> Dict[str, PackageNameCache]:
        """Load package name cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name FROM package_name""")
                for package_name in await cur.fetchall():
                    cache[package_name["name"]] = PackageNameCache(package_name["id"])
        return cache

    async def _load_cpe_cache(self) -> Dict[str, CpeCache]:
        """Load cpe cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name FROM cpe""")
                for cpe in await cur.fetchall():
                    cache[cpe["name"]] = CpeCache(cpe["id"])
        return cache

    async def _load_module_cache(self) -> Dict[str, ModuleCache]:
        """Load module cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, name, stream FROM module""")
                for module in await cur.fetchall():
                    cache[(module["name"], module["stream"])] = ModuleCache(module["id"])
        return cache

    async def _load_vulnerable_package_cache(self) -> Dict[Tuple[int, int, Optional[int]], VulnerablePackageCache]:
        """Load vulnerable package cache from DB"""
        cache = {}
        async with self.db_pool.connection() as conn:
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute("""SELECT id, package_name_id, cpe_id, module_id FROM vulnerable_package""")
                for vulnerable_package in await cur.fetchall():
                    cache[
                        (vulnerable_package["package_name_id"], vulnerable_package["cpe_id"], vulnerable_package["module_id"])
                    ] = VulnerablePackageCache(vulnerable_package["id"])
        return cache

    def _construct_cve_row(self, cve: Dict) -> Dict:
        """Construct CVE row (dict) for insertion to DB"""
        res = cve.copy()
        res["impact_id"] = self.cve_impact_cache[cve["impact"]].id
        res["cvss3_score"] = float(res["cvss3_score"]) if cve.get("cvss3_score") else None
        res["cvss3_metrics"] = res.get("cvss3_metrics")
        res["cvss2_score"] = float(res["cvss2_score"]) if cve.get("cvss2_score") else None
        res["cvss2_metrics"] = res.get("cvss2_metrics")
        res["redhat_url"] = res.get("redhat_url")
        res["secondary_url"] = res.get("secondary_url")
        res["advisories_list"] = Jsonb(res.get("errata_list"))
        return res

    async def _insert_cve(self, cve: str):
        """Insert CVE into database and add it to the cache,
        attempts to fetch CVE from vmaas"""
        LOGGER.info("attempting to get %s data from VMAAS", cve)
        if not cve:
            LOGGER.error("programming error, trying to insert empty string or None into cve_metadata")
            return

        cve_request_endpoint = format_vmaas_cve_endpoint(cve)

        cve_page = await vmaas_request(cve_request_endpoint, method="GET")
        cve_data = None
        try:
            cve_data = cve_page["cve_list"][cve]
        except (KeyError, TypeError):
            LOGGER.error("error importing %s from VMAAS", cve)

        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    if cve_data:
                        cve_row = self._construct_cve_row(cve_data)
                        await cur.execute(
                            """INSERT INTO cve_metadata
                                            (cve, description, impact_id, public_date, modified_date,
                                            cvss3_score, cvss3_metrics, cvss2_score, cvss2_metrics, redhat_url,
                                            secondary_url, advisories_list)
                                            VALUES (%(synopsis)s, %(description)s, %(impact_id)s, %(public_date)s, %(modified_date)s,
                                                    %(cvss3_score)s, %(cvss3_metrics)s, %(cvss2_score)s, %(cvss2_metrics)s,
                                                    %(redhat_url)s, %(secondary_url)s, %(advisories_list)s)
                                            ON CONFLICT (cve) DO UPDATE SET
                                            description = EXCLUDED.description,
                                            impact_id = EXCLUDED.impact_id,
                                            public_date = EXCLUDED.public_date,
                                            modified_date = EXCLUDED.modified_date,
                                            cvss3_score = EXCLUDED.cvss3_score,
                                            cvss3_metrics = EXCLUDED.cvss3_metrics,
                                            cvss2_score = EXCLUDED.cvss2_score,
                                            cvss2_metrics = EXCLUDED.cvss2_metrics,
                                            redhat_url = EXCLUDED.redhat_url,
                                            secondary_url = EXCLUDED.secondary_url,
                                            advisories_list = EXCLUDED.advisories_list
                                            RETURNING id, cve""",
                            cve_row,
                        )
                    else:
                        await cur.execute(
                            """INSERT INTO cve_metadata (cve, description, impact_id)
                                            VALUES (%s, %s, %s)
                                            ON CONFLICT (cve) DO UPDATE SET cve = %s
                                            RETURNING id, cve""",
                            (cve, "unknown", 0, cve),
                        )
                    row = await cur.fetchone()
            self.cve_cache[row["cve"]] = CveCache(row["id"])

    async def _insert_package_name(self, package_name: str):
        """Insert package name into database and add it to the cache"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    await cur.execute(
                        """INSERT INTO package_name (name)
                                        VALUES (%s)
                                        ON CONFLICT (name) DO UPDATE SET name = %s
                                        RETURNING id, name""",
                        (package_name, package_name),
                    )
                    row = await cur.fetchone()
            self.package_name_cache[row["name"]] = PackageNameCache(row["id"])

    async def _insert_cpe(self, cpe: str):
        """Insert CPE into database and add it to the cache"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    await cur.execute(
                        """INSERT INTO cpe (name)
                                        VALUES (%s)
                                        ON CONFLICT (name) DO UPDATE SET name = %s
                                        RETURNING id, name""",
                        (cpe, cpe),
                    )
                    row = await cur.fetchone()
            self.cpe_cache[row["name"]] = CpeCache(row["id"])

    async def _insert_module(self, module_name: str, module_stream: str):
        """Insert module into database and add it to the cache"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    await cur.execute(
                        """INSERT INTO module (name, stream)
                                        VALUES (%s, %s)
                                        ON CONFLICT (name, stream) DO UPDATE SET name = %s, stream = %s
                                        RETURNING id, name, stream""",
                        (module_name, module_stream, module_name, module_stream),
                    )
                    row = await cur.fetchone()
            self.module_cache[(row["name"], row["stream"])] = ModuleCache(row["id"])

    async def _insert_vulnerable_package(self, package_name_id: int, cpe_id: int, module_id: Optional[int]):
        """Insert vulnerable package into database and add it to the cache"""
        async with self.db_pool.connection() as conn:
            async with conn.transaction():
                async with conn.cursor(row_factory=dict_row) as cur:
                    await cur.execute(
                        """INSERT INTO vulnerable_package (package_name_id, cpe_id, module_id)
                                        VALUES (%s, %s, %s)
                                        ON CONFLICT DO NOTHING""",
                        (package_name_id, cpe_id, module_id),
                    )
                    if module_id:
                        await cur.execute(
                            """SELECT id FROM vulnerable_package WHERE package_name_id = %s AND cpe_id = %s AND module_id = %s""",
                            (package_name_id, cpe_id, module_id),
                        )
                    else:
                        await cur.execute(
                            """SELECT id FROM vulnerable_package WHERE package_name_id = %s AND cpe_id = %s AND module_id IS NULL""",
                            (package_name_id, cpe_id),
                        )
                    row = await cur.fetchone()
            self.vulnerable_package_cache[(package_name_id, cpe_id, module_id)] = VulnerablePackageCache(row["id"])

    async def _get_or_upsert_cve(self, cve: str) -> CveCache | None:
        """Returns CVE from cache, or inserts the CVE into DB and cache"""
        if not cve:
            LOGGER.error("programming error, trying to insert empty string or None into cve_metadata")
            return
        if cve not in self.cve_cache:
            await self._insert_cve(cve)
        return self.cve_cache[cve]

    async def _get_or_upsert_package_name(self, package_name: str) -> PackageNameCache:
        """Returns package name from cache, or inserts the package_name into DB and cache"""
        if package_name not in self.package_name_cache:
            await self._insert_package_name(package_name)
        return self.package_name_cache[package_name]

    async def _get_or_upsert_cpe(self, cpe: str) -> CpeCache:
        """Returns CPE from cache, or inserts the CPE into DB and cache"""
        if cpe not in self.cpe_cache:
            await self._insert_cpe(cpe)
        return self.cpe_cache[cpe]

    async def _get_or_upsert_module(self, module_name: str, module_stream: str) -> ModuleCache:
        """Returns module from cache, or inserts the module into DB and cache"""
        if (module_name, module_stream) not in self.module_cache:
            await self._insert_module(module_name, module_stream)
        return self.module_cache[(module_name, module_stream)]

    async def _get_or_upsert_vulnerable_package(
        self, package_name_id: int, cpe_id: int, module_id: Optional[int]
    ) -> VulnerablePackageCache:
        """Returns vulnerable package from cache, or inserts the vulnerable package into DB and cache"""
        if (package_name_id, cpe_id, module_id) not in self.vulnerable_package_cache:
            await self._insert_vulnerable_package(package_name_id, cpe_id, module_id)
        return self.vulnerable_package_cache[(package_name_id, cpe_id, module_id)]

    async def _insert_rule(self, rule: str, rule_cves: [str], conn: AsyncConnection, rule_only=False) -> int:
        """Inserts rule into DB and returns its ID"""
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """INSERT INTO insights_rule (name, rule_only)
                                 VALUES (%s, %s)
                                 ON CONFLICT (name) DO UPDATE
                                 SET name = %s, rule_only = %s
                                 RETURNING id""",
                (rule, rule_only, rule, rule_only),
            )
            row = await cur.fetchone()
            to_insert = []
            for cve in rule_cves:
                cve_db = await self._get_or_upsert_cve(cve)
                if cve_db is not None:
                    to_insert.append((row["id"], cve_db.id))
            await cur.executemany(
                """INSERT INTO cve_rule_mapping (rule_id, cve_id)
                                     VALUES (%s, %s)
                                     ON CONFLICT DO NOTHING""",
                to_insert,
            )
            return row["id"]

    @time(EVAL_PART_TIME.labels(part="vmaas_request"))
    async def _perform_vmaas_request(self, vmaas_json: dict) -> (List[CveAdvisories], List[CveAdvisories], List[CveUnpatched]):
        """Perform VMAAS request for package based evaluation"""
        playbook_cves = []
        manually_fixable_cves = []
        unpatched_cves = []

        if not vmaas_json.get("package_list", []) or not vmaas_json.get("repository_list", []):
            return playbook_cves, manually_fixable_cves, unpatched_cves

        vmaas_json["epoch_required"] = True
        vmaas_json["extended"] = True
        vmaas_response = await vmaas_request(CFG.vmaas_vulnerabilities_endpoint, vmaas_json)
        if vmaas_response:
            for cve in vmaas_response["cve_list"]:
                playbook_cves.append(CveAdvisories(cve["cve"], ",".join(sorted(cve["errata"] or [])) or None))
            for cve in vmaas_response["manually_fixable_cve_list"]:
                manually_fixable_cves.append(CveAdvisories(cve["cve"], ",".join(sorted(cve["errata"] or [])) or None))
            for cve in vmaas_response["unpatched_cve_list"]:
                for affected_package in cve["affected"]:
                    unpatched_cves.append(
                        CveUnpatched(
                            cve["cve"],
                            affected_package["package_name"],
                            affected_package["cpe"],
                            affected_package["module_name"],
                            affected_package["module_stream"],
                        )
                    )
        else:
            raise VmaasErrorException("cannot evaluate system, unable to contact vmaas for evaluation")
        return playbook_cves, manually_fixable_cves, unpatched_cves

    @time(EVAL_PART_TIME.labels(part="load_vulnerable_package_cve"))
    async def _load_db_vulnerable_package_cve(self, vuln_package_ids: List[int], conn: AsyncConnection) -> Dict[int, Set[int]]:
        """Make map from vulnerable_package, cve pairs in db"""
        pkg_map = {}
        if not vuln_package_ids:
            return pkg_map
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """
                SELECT vulnerable_package_id, cve_id
                FROM vulnerable_package_cve
                WHERE vulnerable_package_id = ANY (%s)
                """,
                (vuln_package_ids,),
            )
            for vuln_pkg_cve in await cur.fetchall():
                pkg_map.setdefault(vuln_pkg_cve["vulnerable_package_id"], set()).add(vuln_pkg_cve["cve_id"])
        return pkg_map

    @time(EVAL_PART_TIME.labels(part="cmp_vulnerable_package_cve"))
    async def _compare_vulnerable_package_cve(
        self, vuln_package_cve_db: Dict[int, Set[int]], vuln_package_cve: Dict[int, Set[int]]
    ) -> Tuple[List, List]:
        """Compare vulnerable package cves in DB with fresh evaluated cves"""
        to_insert, to_delete = [], []
        for vuln_package_id, cves in vuln_package_cve.items():
            cves_db = vuln_package_cve_db.get(vuln_package_id, set())
            for cve_id in cves:
                # vulnerability is not in db, we need to insert it
                if cve_id not in cves_db:
                    to_insert.append((vuln_package_id, cve_id))
                else:
                    cves_db.remove(cve_id)

        # remaining vuln_package_cve_db map are cves that we do not know anything about anymore
        for vuln_package_id, cves in vuln_package_cve_db.items():
            for cve_id in cves:
                to_delete.append((vuln_package_id, cve_id))

        return sorted(to_insert), sorted(to_delete)

    @time(EVAL_PART_TIME.labels(part="insert_vulnerable_package_cve"))
    async def _insert_vulnerable_package_cve(self, to_insert: List[Tuple[int, int]], conn: AsyncConnection):
        """Insert given vulnerable package cves to table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """INSERT INTO vulnerable_package_cve (vulnerable_package_id, cve_id)
                                     VALUES (%s, %s)
                                     ON CONFLICT DO NOTHING
                                     """,
                to_insert,
            )

    @time(EVAL_PART_TIME.labels(part="delete_vulnerable_package_cve"))
    async def _delete_vulnerable_package_cve(self, to_delete: List[Tuple[int, int]], conn: AsyncConnection):
        """Delete given vulnerable package cves from table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """DELETE FROM vulnerable_package_cve
                                     WHERE vulnerable_package_id = %s
                                       AND cve_id = %s
                                     """,
                to_delete,
            )

    @time(EVAL_PART_TIME.labels(part="load_system_vulnerable_package"))
    async def _load_db_system_vulnerable_package(self, system_platform: SystemPlatform, conn: AsyncConnection) -> Set[int]:
        """Make map from system, vulnerable_package pairs in db"""
        pkgs = set()
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """
                SELECT vulnerable_package_id
                FROM system_vulnerable_package
                WHERE rh_account_id = %s
                  AND system_id = %s
                """,
                (system_platform.rh_account_id, system_platform.id),
            )
            for system_vuln_pkg in await cur.fetchall():
                pkgs.add(system_vuln_pkg["vulnerable_package_id"])
        return pkgs

    @time(EVAL_PART_TIME.labels(part="cmp_system_vulnerable_package"))
    async def _compare_system_vulnerable_package(
        self, system_platform: SystemPlatform, system_vuln_package_db: Set[int], system_vuln_package: List[int]
    ) -> Tuple[List, List]:
        """Compare system vulnerable packages in DB with fresh evaluated result"""
        to_insert, to_delete = [], []
        for vuln_package_id in system_vuln_package:
            # vulnerability is not in db, we need to insert it
            if vuln_package_id not in system_vuln_package_db:
                to_insert.append((system_platform.rh_account_id, system_platform.id, vuln_package_id))
            else:
                system_vuln_package_db.remove(vuln_package_id)

        # remaining system_vuln_package_db set are vulnerable packages we do not know anything about anymore
        for vuln_package_id in system_vuln_package_db:
            to_delete.append((system_platform.rh_account_id, system_platform.id, vuln_package_id))

        return sorted(to_insert), sorted(to_delete)

    @time(EVAL_PART_TIME.labels(part="insert_system_vulnerable_package"))
    async def _insert_system_vulnerable_package(self, to_insert: List[Tuple[int, int, int]], conn: AsyncConnection):
        """Insert given system vulnerable packages to table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """INSERT INTO system_vulnerable_package
                                     (rh_account_id, system_id, vulnerable_package_id, first_reported)
                                     VALUES (%s, %s, %s, now())
                                     ON CONFLICT DO NOTHING
                                     """,
                to_insert,
            )

    @time(EVAL_PART_TIME.labels(part="delete_system_vulnerable_package"))
    async def _delete_system_vulnerable_package(self, to_delete: List[Tuple[int, int, int]], conn: AsyncConnection):
        """Delete given system vulnerable packages from table"""
        async with conn.cursor() as cur:
            await cur.executemany(
                """DELETE FROM system_vulnerable_package
                                     WHERE rh_account_id = %s
                                       AND system_id = %s
                                       AND vulnerable_package_id = %s
                                     """,
                to_delete,
            )

    async def _evaluate_vmaas_res(
        self,
        playbook_cves: List[CveAdvisories],
        manually_fixable_cves: List[CveAdvisories],
        unpatched_cves: List[CveUnpatched],
        sys_vuln_rows: dict,
        system_platform: SystemPlatform,
        conn: AsyncConnection,
        recalc_event_id: Optional[int] = None,
    ) -> dict:
        """Insert vmaas cve results"""

        with EVAL_PART_TIME.labels(part="get_or_upsert").time():
            # system is potentially vulnerable to cves returned from vmaas
            for cve_adv in playbook_cves:
                cve = await self._get_or_upsert_cve(cve_adv.name)
                if cve is not None:
                    sys_vuln_rows[cve_adv.name] = SystemVulnerabilitiesRow(
                        VulnerabilityState.VULNERABLE_BY_PACKAGE,
                        system_platform.rh_account_id,
                        system_platform.id,
                        cve.id,
                        cve_adv.advisories,
                        True,
                        False,
                        None,
                        None,
                        None,
                        None,
                        None,
                    )

            for cve_adv in manually_fixable_cves:
                cve = await self._get_or_upsert_cve(cve_adv.name)
                if cve is not None:
                    sys_vuln_rows[cve_adv.name] = SystemVulnerabilitiesRow(
                        VulnerabilityState.VULNERABLE_BY_PACKAGE,
                        system_platform.rh_account_id,
                        system_platform.id,
                        cve.id,
                        cve_adv.advisories,
                        True,
                        True,
                        None,
                        None,
                        None,
                        None,
                        None,
                    )

            # if this is a re-evaluation, it means it was triggered by a new erratum in repository => don't change unfixed CVEs
            # the change of unfixed CVEs in oval/csaf is not covered, it'll be handled only by evaluator_upload for now
            if recalc_event_id:
                return sys_vuln_rows

            # aggregate unfixed cves, get (package name, cpe, module) tuples and list of cves for these pairs
            pn_cpes = {}
            for cve_unpatched in unpatched_cves:
                cve_cache = await self._get_or_upsert_cve(cve_unpatched.cve)
                if cve_cache is not None:
                    pn_cpes.setdefault(
                        (cve_unpatched.package_name, cve_unpatched.cpe, cve_unpatched.module_name, cve_unpatched.module_stream), set()
                    ).add(cve_cache.id)

            vuln_package_cve = {}
            for (package_name, cpe, module_name, module_stream), cve_ids in pn_cpes.items():
                package_name_cache = await self._get_or_upsert_package_name(package_name)
                cpe_cache = await self._get_or_upsert_cpe(cpe)
                if module_name and module_stream:
                    module_cache = await self._get_or_upsert_module(module_name, module_stream)
                    module_id = module_cache.id
                else:
                    module_id = None
                vulnerable_package_cache = await self._get_or_upsert_vulnerable_package(package_name_cache.id, cpe_cache.id, module_id)
                vuln_package_cve[vulnerable_package_cache.id] = cve_ids

        # ensure all vulnerable_package_cve pairs are up to date
        vuln_package_cve_db = await self._load_db_vulnerable_package_cve(list(vuln_package_cve), conn)
        to_insert, to_delete = await self._compare_vulnerable_package_cve(vuln_package_cve_db, vuln_package_cve)
        LOGGER.debug(
            "system: %s, vulnerable_package_cve changes, i: %s, d: %s", system_platform.inventory_id, len(to_insert), len(to_delete)
        )
        LOGGER.debug("inserting vulnerable pkg-cve: %s", to_insert)
        LOGGER.debug("deleting vulnerable pkg-cve: %s", to_delete)
        if to_insert:
            await self._insert_vulnerable_package_cve(to_insert, conn)
        if to_delete:
            await self._delete_vulnerable_package_cve(to_delete, conn)

        # limit number of vulnerable packages linked to a system (skip vulnerable packages affecting same CVEs)
        target_system_vuln_package = []
        seen_cves = set()
        for vuln_package_id, cve_ids in sorted(vuln_package_cve.items()):
            if not cve_ids.issubset(seen_cves):
                target_system_vuln_package.append(vuln_package_id)
                seen_cves.update(cve_ids)

        # ensure all system_vulnerable_package pairs are up to date
        system_vuln_package_db = await self._load_db_system_vulnerable_package(system_platform, conn)
        to_insert, to_delete = await self._compare_system_vulnerable_package(
            system_platform, system_vuln_package_db, target_system_vuln_package
        )
        LOGGER.debug(
            "system: %s, system_vulnerable_package changes, i: %s, d: %s", system_platform.inventory_id, len(to_insert), len(to_delete)
        )
        if to_insert:
            await self._insert_system_vulnerable_package(to_insert, conn)
        if to_delete:
            await self._delete_system_vulnerable_package(to_delete, conn)

        return sys_vuln_rows

    async def _get_or_upsert_rule(
        self, rule: str, rule_details: dict, rule_cache: Dict[str, RuleCache], conn: AsyncConnection, rule_only=False
    ) -> Dict[str, RuleCache]:
        """Returns rule from cache, or inserts the rule into DB and cache"""
        if rule not in rule_cache:
            rule_id = await self._insert_rule(rule, rule_details["cves"].keys(), conn, rule_only=rule_only)
            rule_cache[rule] = RuleCache(rule_id, None)
        return rule_cache

    async def _evaluate_advisor_res(
        self,
        rule_results: dict,
        sys_vuln_rows: Dict[str, SystemVulnerabilitiesRow],
        rule_cache: Dict[str, RuleCache],
        system_platform: SystemPlatform,
        conn: AsyncConnection,
    ) -> Dict[str, SystemVulnerabilitiesRow]:
        """Merge results from vmaas package evaluation with advisor rule evaluation"""
        for cve, hit_details in rule_results["rule_hits"].items():
            cve_id = await self._get_or_upsert_cve(cve)
            if cve_id is None:
                continue

            # TODO: remove this once CVE_2017_5753_4_cpu_kernel and CVE_2017_5715_cpu_virt are merged
            rule = hit_details["rule_id"]
            if rule in self.skipped_rules:
                continue

            # TODO: remove this once majority of systems are re-evaluated
            if not isinstance(hit_details["details"], dict):
                hit_details["details"] = json.loads(hit_details["details"])

            rule_cache = await self._get_or_upsert_rule(rule, hit_details["details"], rule_cache, conn)
            rule_db = rule_cache[rule]

            # if the system is not vulnerable to CVE from vmaas, we expect that it does not have advisory
            vulnerability = sys_vuln_rows.get(cve)
            mitigation_reason = hit_details.get("details", {}).get("cves", {}).get(cve)

            if vulnerability and not mitigation_reason:
                # system was vulnerable for cve from vmaas and also is for rule
                vulnerability.state = VulnerabilityState.VULNERABLE_BY_RULE_AND_PACKAGE
            elif vulnerability and mitigation_reason:
                # system was vulnerable for cve from vmaas but not from by rules -> abnv
                vulnerability.add_rule_info(rule_db.id, hit_details["details"], rule_db.playbook_count, mitigation_reason)
                vulnerability.state = VulnerabilityState.VULNERABLE_BY_PACKAGE_NOT_RULE
            elif mitigation_reason:
                # system is not vulnerable from vmaas nor rules
                continue
            else:
                # system is vulnerable for cve from rule, but not from vmaas
                vulnerability = SystemVulnerabilitiesRow(
                    VulnerabilityState.VULNERABLE_BY_RULE,
                    system_platform.rh_account_id,
                    system_platform.id,
                    cve_id.id,
                    None,
                    False,
                    False,
                    datetime.utcnow(),
                    None,
                    None,
                    None,
                    None,
                )
            vulnerability.add_rule_info(rule_db.id, hit_details["details"], rule_db.playbook_count, None)
            sys_vuln_rows[cve] = vulnerability

        for cve, pass_details in rule_results["rule_passes"].items():
            package_vulnerability = sys_vuln_rows.pop(cve, None)

            if not package_vulnerability:
                continue

            # TODO: remove this once CVE_2017_5753_4_cpu_kernel and CVE_2017_5715_cpu_virt are merged
            rule = pass_details["rule_id"]
            if rule in self.skipped_rules:
                continue

            # system was marked vulnerable from vmaas but not from by rules -> abnv
            rule_cache = await self._get_or_upsert_rule(rule, pass_details["details"], rule_cache, conn, rule_only=True)
            rule_db = rule_cache[rule]

            package_vulnerability.add_rule_info(
                rule_db.id, pass_details["details"], rule_db.playbook_count, pass_details["mitigation_reason"]
            )
            package_vulnerability.state = VulnerabilityState.VULNERABLE_BY_PACKAGE_NOT_RULE
            sys_vuln_rows[cve] = package_vulnerability

        return sys_vuln_rows

    async def evaluate_vulnerabilities(
        self, system_platform: SystemPlatform, conn: AsyncConnection, recalc_event_id: Optional[int] = None
    ) -> Dict[str, SystemVulnerabilitiesRow]:
        """Evaluate cve hits from vmaas and advisor"""
        sys_vuln_rows = {}

        if system_platform.vmaas_json:
            with VMAAS_EVAL_TIME.time():
                playbook_cves, manually_fixable_cves, unpatched_cves = await self._perform_vmaas_request(system_platform.vmaas_json)
                sys_vuln_rows = await self._evaluate_vmaas_res(
                    playbook_cves,
                    manually_fixable_cves,
                    unpatched_cves,
                    sys_vuln_rows,
                    system_platform,
                    conn,
                    recalc_event_id=recalc_event_id,
                )
        if system_platform.rule_results:
            # unfortunately, rule cache can change meanwhile evaluator is running,
            # so it cannot be static and needs to be loaded on each evaluation
            with RULES_EVAL_TIME.time():
                rule_cache = await self._load_rule_cache(conn)
                sys_vuln_rows = await self._evaluate_advisor_res(
                    system_platform.rule_results, sys_vuln_rows, rule_cache, system_platform, conn
                )
        return sys_vuln_rows
