#!/usr/bin/python3
import os
import logging
import time
import multiprocessing
import json

from kafka import KafkaConsumer


class Consumer(multiprocessing.Process):
    """ The main class of Kafka consumer.

        Logic for processing messages
        should be implemented in the run() method
    """
    def __init__(self, kafka_host, kafka_port, kafka_topic):
        multiprocessing.Process.__init__(self)
        self.stop_event = multiprocessing.Event()

        # connect to the Messaging Service
        self.consumer = KafkaConsumer(bootstrap_servers=kafka_host + ':' + kafka_port)

        # subscribe to the topic
        self.consumer.subscribe([kafka_topic])

    def stop(self):
        self.stop_event.set()

    def run(self):
        """
        This method should be overridden in the inherited classes.
        :return:
        """
        # just close connection
        self.consumer.close()


class VmaasUpdates(Consumer):
    """ This class contains logic for the processing new available
        updates from VMaaS.

         For the Phase 0, run() method just print steps to implement.

    """

    MESSAGE = """
        --- PROCESSING VMAAS UPDATES ---
    1) Select all systems from the storage
    2) For every system get its package list
    3) Sent POST request to VMaaS with packages list
    4) Save updates back to the storage
    """

    def run(self):
        """
        This method process messages with type 'vmaas_updates'
        :return:
        """
        while not self.stop_event.is_set():
            for message in self.consumer:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if msg_dict['type'] == 'vmaas_updates':
                    print(self.MESSAGE)

                if self.stop_event.is_set():
                    break

        self.consumer.close()


class NewSystem(Consumer):
    """ This class contains logic for the processing messages about
        new registered system.

         For the Phase 0, run() method just print steps to implement.

    """

    MESSAGE = """
        --- NEW SYSTEM WAS ADDED ---
    1) Get ID of new system from the message
    2) Get details about new system with provided ID from the Inventory Service
    3) Get available from VMaaS
    4) Add record about new system into the Storage
    """

    def run(self):
        """
        This method process messages with type 'inventory_new_system'
        :return:
        """
        while not self.stop_event.is_set():
            for message in self.consumer:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if msg_dict['type'] == 'inventory_new_system':
                    print(self.MESSAGE)

                if self.stop_event.is_set():
                    break

        self.consumer.close()


class UpdateSystem(Consumer):
    """ This class contains logic for the processing messages about
        system updates.

         For the Phase 0, run() method just print steps to implement.

    """

    MESSAGE = """
        --- UPDATE SYSTEM (Phase 0) ---
    1) Get ID of new system from the message
    2) Get details about new system with provided ID from the Inventory Service
    3) Get available updates from VMaaS
    4) Update record about new system into the Storage
    """

    def run(self):
        """
        This method process messages with type 'inventory_update_system'
        :return:
        """
        while not self.stop_event.is_set():
            for message in self.consumer:
                msg_dict = json.loads(message.value.decode('utf-8'))
                if msg_dict['type'] == 'inventory_update_system':
                    print(self.MESSAGE)

                if self.stop_event.is_set():
                    break

        self.consumer.close()


def main():
    kafka_host = os.getenv('KAFKA_HOST', 'kafka-1.vmaas-ci.svc')
    kafka_port = os.getenv('KAFKA_PORT', '29092')
    kafka_topic = os.getenv('KAFKA_TOPIC', 'vulnerability_results')

    tasks = [
        VmaasUpdates(kafka_host, kafka_port, kafka_topic),
        NewSystem(kafka_host, kafka_port, kafka_topic),
        UpdateSystem(kafka_host, kafka_port, kafka_topic)
    ]

    # start all message processing tasks
    for t in tasks:
        t.start()

    # wait until all tasks are done
    for task in tasks:
        task.join()


if __name__ == "__main__":
    logging.basicConfig(
        format='%(asctime)s.%(msecs)s:%(name)s:%(thread)d:%(levelname)s:%(process)d:%(message)s',
        level=logging.INFO
    )
    main()