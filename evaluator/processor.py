"""
Processing logic of grouped evaluator message for single system
"""
import asyncio
import json
from datetime import datetime
from datetime import timedelta
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple

from prometheus_async.aio import time
from psycopg import AsyncConnection
from psycopg import sql
from psycopg.rows import dict_row
from psycopg_pool.pool_async import AsyncConnectionPool

from .common import EMPTY_DATA_SKIP
from .common import EVAL_COUNT
from .common import EVAL_PART_TIME
from .common import EVAL_PERFORMED_COUNT
from .common import EVAL_TIME
from .common import EVALUATED_EARLIER_SKIP
from .common import EvaluatorException
from .common import INV_ID_NOT_FOUND
from .common import PACKAGE_RE
from .common import RECALC_EVENT_ERROR
from .common import RECALC_PACKAGES_UNCHANGED_SKIP
from .common import RecalcEvent
from .common import SystemPlatform
from .common import SystemVulnerabilitiesRow
from .common import VMAAS_ERRORS_SKIP
from .common import VmaasErrorException
from .common import VulnerabilityDB
from .logic import EvaluatorLogic
from common.logging import get_logger
from common.mqueue import MQWriter
from common.peewee_model import VulnerabilityState
from common.utils import executemany_fetchall
from common.utils import send_msg_to_payload_tracker
from common.utils import send_notifications
from common.utils import send_remediations_update

LOGGER = get_logger(__name__)


class EvaluatorProcessor:
    """Evaluator processor"""

    def __init__(
        self,
        remediations_results: MQWriter,
        evaluator_results: MQWriter,
        payload_tracker: MQWriter,
        db_pool: AsyncConnectionPool,
        loop: asyncio.BaseEventLoop,
    ):
        """Constructor"""
        self.db_pool: AsyncConnectionPool = db_pool
        self.loop = loop
        self.evaluator_logic = EvaluatorLogic(db_pool)

        self.remediations_results = remediations_results
        self.evaluator_results = evaluator_results
        self.payload_tracker = payload_tracker
        self.recent_recalc_events: Dict[int, RecalcEvent] = {}

    async def init(self):
        """Async constructor"""
        await self.evaluator_logic.init()

    async def _get_changed_packages(self, recalc_event_id: Optional[int], conn: AsyncConnection) -> Optional[dict]:
        """Get changed packages for a recalc event from cache or fetch it from DB."""
        if recalc_event_id is None:
            return None
        if recalc_event_id not in self.recent_recalc_events:
            # Cleanup old recalc events first
            deadline = datetime.now() - timedelta(days=30)
            for rc_e_id in list(self.recent_recalc_events):
                created = self.recent_recalc_events[rc_e_id].created
                if created < deadline:
                    del self.recent_recalc_events[rc_e_id]
                    LOGGER.info("Unloaded old recalc event id: %s", rc_e_id)
            # Fetch single recalc event from DB and put it into cache
            async with conn.cursor(row_factory=dict_row) as cur:
                await cur.execute(
                    """
                    SELECT created, changed_packages
                    FROM recalc_event
                    WHERE id = %s
                    """,
                    (recalc_event_id,),
                )
                row = await cur.fetchone()
            if row:
                self.recent_recalc_events[recalc_event_id] = RecalcEvent(row["created"], row["changed_packages"])
                LOGGER.info("Loaded recalc event id: %s", recalc_event_id)
            else:
                LOGGER.error("Recalc event id not found: %s", recalc_event_id)
                RECALC_EVENT_ERROR.inc()
                return None
        return self.recent_recalc_events[recalc_event_id].changed_packages

    async def _needs_recalc(self, system_platform: SystemPlatform, changed_packages: dict) -> bool:
        """Returns True if there is at least one package name in system profile which changed in current recalc event."""
        if system_platform.vmaas_json:
            relevant_changed_repos = set(changed_packages).intersection(system_platform.vmaas_json.get("repository_list", []))
            for pkg in system_platform.vmaas_json.get("package_list", []):
                pkg_match = PACKAGE_RE.match(pkg)
                if pkg_match:
                    pkg_name = pkg_match.group("pn")
                    for repo in relevant_changed_repos:
                        if pkg_name in changed_packages[repo]:
                            return True
        return False

    @time(EVAL_PART_TIME.labels(part="lock_system"))
    async def _lock_system(self, inventory_id: str, conn: AsyncConnection) -> SystemPlatform:
        """Lock system for update and return its row"""
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """
                SELECT id, rh_account_id, vmaas_json, rule_results, last_evaluation
                FROM system_platform
                WHERE inventory_id = %s
                AND when_deleted IS NULL
                FOR UPDATE
                LIMIT 1
                """,
                (inventory_id,),
            )
            row = await cur.fetchone()
        if row:
            vmaas_json = json.loads(row["vmaas_json"]) if row["vmaas_json"] else None
            return SystemPlatform(row["id"], inventory_id, row["rh_account_id"], vmaas_json, row["rule_results"], row["last_evaluation"])
        return None

    @time(EVAL_PART_TIME.labels(part="load_system_vulnerabilities"))
    async def _load_db_system_vulnerabilities(self, system_platform: SystemPlatform, conn: AsyncConnection) -> Dict[str, VulnerabilityDB]:
        """Make map from marked vulnerabilities in db for system"""
        cve_map = {}
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.execute(
                """
                SELECT sv.state, cm.cve, sv.id as sv_id, sv.rule_id, sv.when_mitigated, sv.mitigation_reason,
                       sv.advisories, sv.advisory_available, sv.rule_hit_details,
                       sv.remediation_type_id
                FROM system_vulnerabilities_active AS sv
                JOIN cve_metadata AS cm ON sv.cve_id = cm.id
                LEFT JOIN insights_rule AS ir ON sv.rule_id = ir.id
                WHERE sv.system_id = %s AND sv.rh_account_id = %s
                """,
                (
                    system_platform.id,
                    system_platform.rh_account_id,
                ),
            )
            for cve_system in await cur.fetchall():
                # FIXME: this try/except should be deleted once all system_vulnerabilities rows
                # will have defined state + we can do NOT NULL constraint on that field in DB
                try:
                    state = VulnerabilityState(cve_system["state"])
                except ValueError:
                    state = None

                cve_map[cve_system["cve"]] = VulnerabilityDB(
                    state,
                    cve_system["sv_id"],
                    cve_system["rule_id"],
                    cve_system["when_mitigated"],
                    cve_system["mitigation_reason"],
                    cve_system["advisories"],
                    cve_system["advisory_available"],
                    cve_system["rule_hit_details"],
                    cve_system["remediation_type_id"],
                )
        return cve_map

    @time(EVAL_PART_TIME.labels(part="insert_vulnerabilities"))
    async def _insert_vulnerabilities(self, to_insert: [Dict], conn: AsyncConnection) -> List[Tuple]:
        """Insert given system_vulnerabilities"""
        new_sys_vulns = []
        async with conn.cursor(row_factory=dict_row) as cur:
            await cur.executemany(
                """
                INSERT INTO system_vulnerabilities_active
                (state, cve_id, rh_account_id, system_id,
                 advisories, advisory_available, when_mitigated, rule_id,
                 rule_hit_details, mitigation_reason, remediation_type_id)
                VALUES
                (%(state)s, %(cve_id)s, %(rh_account_id)s, %(system_id)s,
                 %(advisories)s, %(advisory_available)s, %(when_mitigated)s,
                 %(rule_id)s, %(rule_hit_details)s,
                 %(mitigation_reason)s, %(remediation_type_id)s)
                RETURNING id, cve_id
            """,
                to_insert,
                returning=True,
            )
            for inserted in await executemany_fetchall(cur):
                new_sys_vulns.append((inserted["id"], inserted["cve_id"]))
        return new_sys_vulns

    @time(EVAL_PART_TIME.labels(part="update_vulnerabilities"))
    async def _update_vulnerabilities(self, to_update: [Dict], conn: AsyncConnection):
        """Update given system_vulnerabilities"""
        # TODO: think if it would be possible to do EXECUTEMANY
        # where the update queries would update only changed fields
        async with conn.cursor() as cur:
            await cur.executemany(
                """
                UPDATE system_vulnerabilities_active AS sv
                SET state = %(state)s,
                    advisories = %(advisories)s,
                    advisory_available = %(advisory_available)s,
                    when_mitigated = %(when_mitigated)s,
                    rule_id = %(rule_id)s,
                    rule_hit_details = %(rule_hit_details)s,
                    mitigation_reason = %(mitigation_reason)s,
                    remediation_type_id = %(remediation_type_id)s
                WHERE sv.rh_account_id = %(rh_account_id)s
                AND sv.system_id = %(system_id)s
                AND sv.cve_id = %(cve_id)s
            """,
                to_update,
            )

    @time(EVAL_PART_TIME.labels(part="delete_vulnerabilities"))
    async def _delete_vulnerabilities(self, to_delete: [int], system_platform: SystemPlatform, conn: AsyncConnection):
        """Delete given system_vulnerabilities from table"""
        async with conn.cursor() as cur:
            await cur.execute(
                """DELETE FROM system_vulnerabilities_active AS sv
                                 WHERE sv.id = ANY (%s)
                                 AND sv.rh_account_id = %s
                                 """,
                (to_delete, system_platform.rh_account_id),
            )

    @time(EVAL_PART_TIME.labels(part="mark_system_evaluated"))
    async def _mark_system_evaluated(self, cve_cache_count: int, system_platform: SystemPlatform, conn: AsyncConnection):
        """Mark system as evaluated, updating its cache and last evaluation"""
        last_evaluation, advisor_evaluated = sql.Identifier("last_evaluation"), sql.Identifier("advisor_evaluated")
        if system_platform.vmaas_json:
            last_evaluation = sql.Literal("now()")
        if system_platform.rule_results:
            advisor_evaluated = sql.Literal("now()")

        async with conn.cursor() as cur:
            await cur.execute(
                sql.SQL(
                    """UPDATE system_platform
                           SET last_evaluation = {},
                               advisor_evaluated = {},
                               cve_count_cache = %s
                           WHERE id = %s"""
                ).format(last_evaluation, advisor_evaluated),
                (cve_cache_count, system_platform.id),
            )

    async def _compare_sys_vulns(
        self, vulnerabilities_db: Dict[str, VulnerabilityDB], vulnerabilities: Dict[str, SystemVulnerabilitiesRow]
    ):
        """Compare vulnerabilities mark in DB with fresh evaluated vulnerabilities"""
        to_insert, to_update, to_delete = [], [], []
        for cve, vulnerability in vulnerabilities.items():
            vulnerability_db = vulnerabilities_db.pop(cve, None)
            # vulnerability is not in db, we need to insert it
            if not vulnerability_db:
                to_insert.append(vulnerability.format_db_dict())
                continue

            # vulnerability is in db, check if fields changed
            if vulnerability.should_update_db(vulnerability_db):
                to_update.append(vulnerability.format_db_dict())

        # remaining vulnerability_db map are cves that we do not know anything about anymore
        for cve, vulnerability_db in vulnerabilities_db.items():
            to_delete.append(vulnerability_db.sv_id)

        return to_insert, to_update, to_delete

    async def _evaluate_system(
        self, inventory_id: str, org_id: str, request_timestamp: Optional[datetime], recalc_event_id: Optional[int] = None
    ):
        """Evaluate vulnerabilities for single system, and update DB"""
        async with self.db_pool.connection() as conn:
            changed_packages = await self._get_changed_packages(recalc_event_id, conn)
            async with conn.transaction():
                system_platform = await self._lock_system(inventory_id, conn)
                if not system_platform:
                    INV_ID_NOT_FOUND.inc()
                    raise EvaluatorException(f"cannot find system: {inventory_id}, org_id: {org_id}, skipping evaluation")
                if not system_platform.vmaas_json and not system_platform.rule_results:
                    EMPTY_DATA_SKIP.inc()
                    LOGGER.error(
                        "skipping evaluation, due to empty vmaas_json and rule_results, system: %s, org_id: %s", inventory_id, org_id
                    )
                    return
                if request_timestamp and system_platform.last_evaluation and request_timestamp < system_platform.last_evaluation:
                    EVALUATED_EARLIER_SKIP.inc()
                    LOGGER.info("skipping evaluation, kafka message is older than system was lastly evaluated")
                    return
                if changed_packages and not self._needs_recalc(system_platform, changed_packages):
                    RECALC_PACKAGES_UNCHANGED_SKIP.inc()
                    LOGGER.info("skipping re-evaluation, no system packages changed in repos")
                    return

                # start both task asynchronously to speed up
                sys_vuln_rows_db, sys_vuln_rows = await asyncio.gather(
                    self._load_db_system_vulnerabilities(system_platform, conn),
                    self.evaluator_logic.evaluate_vulnerabilities(system_platform, conn, recalc_event_id=recalc_event_id),
                )

                to_insert, to_update, to_delete = await self._compare_sys_vulns(sys_vuln_rows_db, sys_vuln_rows)
                LOGGER.debug(
                    "system: %s, system_vulnerabilities changes, i: %s, u: %s, d: %s",
                    inventory_id,
                    len(to_insert),
                    len(to_update),
                    len(to_delete),
                )
                new_system_vulns = []
                if to_insert:
                    new_system_vulns = await self._insert_vulnerabilities(to_insert, conn)
                if to_update:
                    await self._update_vulnerabilities(to_update, conn)
                if to_delete:
                    await self._delete_vulnerabilities(to_delete, system_platform, conn)

                fixable_sys_vuln_rows = {cve: row for cve, row in sys_vuln_rows.items() if row.remediation_type_id > 0}
                await self._mark_system_evaluated(len(fixable_sys_vuln_rows), system_platform, conn)

                send_remediations_update(self.remediations_results, inventory_id, fixable_sys_vuln_rows)
                send_notifications(self.evaluator_results, new_system_vulns, [], [], system_platform.rh_account_id, org_id)
                EVAL_PERFORMED_COUNT.inc()

    async def evaluate_system(
        self, inventory_id: str, org_id: str, request_id: str, request_timestamp: datetime, recalc_event_id: Optional[int] = None
    ):
        """Evaluate single system"""
        EVAL_COUNT.inc()
        msg = {"platform_metadata": {"request_id": request_id}, "host": {"org_id": org_id, "id": inventory_id}}
        try:
            with EVAL_TIME.time():
                LOGGER.info("evaluating system: %s, org_id: %s", inventory_id, org_id)
                await self._evaluate_system(inventory_id, org_id, request_timestamp, recalc_event_id=recalc_event_id)
        except EvaluatorException as ex:
            LOGGER.error(str(ex))
            send_msg_to_payload_tracker(self.payload_tracker, msg, "error", status_msg="evaluation failed", loop=self.loop)
            return
        except VmaasErrorException as ex:
            LOGGER.error(str(ex))
            VMAAS_ERRORS_SKIP.inc()
            send_msg_to_payload_tracker(self.payload_tracker, msg, "error", status_msg="evaluation failed", loop=self.loop)
            return

        send_msg_to_payload_tracker(self.payload_tracker, msg, "success", status_msg="evaluation succeeded", loop=self.loop)
