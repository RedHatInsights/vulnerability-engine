"""
Notificator service.
Service sends notifications to the notifications backend.
"""
import asyncio
import json
import signal
from datetime import datetime, timedelta, timezone

from common import mqueue
from common.config import Config
from common.database_handler import setup_db_pool
from common.logging import get_logger, init_logging
from common.peewee_model import NotificationType
from common.status_app import create_status_app, create_status_runner

from .app import CacheHandler, create_notif_app_runner, create_notificator_app
from .notificator_queue import NotificatorQueue, QueueItem

CFG = Config()
LOGGER = get_logger(__name__)
NOTIFICATOR_PERIOD = 3 * 60   # 3 minutes


class NotificatorConditions:
    """Represents logic when CVE is notifiable"""

    def __init__(self, pool):
        self.db_pool = pool
        self.cve_map = None

    async def init(self):
        """Async constructor"""
        self.cve_map = await self._create_cve_map()

    async def _create_cve_map(self):
        """Creates and returns CVE map with needed information for conditions
           (fetches only CVEs which are known from vmaas_sync)"""
        res = {}
        async with self.db_pool.acquire() as conn:
            async with conn.transaction():
                rows = await conn.fetch("""SELECT DISTINCT(cm.id), cm.cve, COALESCE(cm.cvss2_score, cm.cvss3_score, 0.0) AS cvss_score,
                                                  cm.impact_id, cm.exploit_data,
                                                  CASE WHEN cm.id IN (SELECT cve_id FROM cve_rule_mapping AS crm
                                                                      JOIN insights_rule AS ir ON crm.rule_id = ir.id
                                                                      WHERE active = TRUE) THEN TRUE ELSE FALSE END AS is_rule,
                                                  cm.public_date
                                           FROM cve_metadata AS cm
                                           WHERE cm.public_date IS NOT NULL""")
                for cve_row in rows:
                    cve = {}
                    cve["cve"] = cve_row[1]
                    cve["cvss_score"] = cve_row[2]
                    cve["impact_id"] = cve_row[3]
                    cve["exploits"] = cve_row[4] is not None
                    cve["is_rule"] = cve_row[5]
                    cve["public_date"] = cve_row[6]
                    res[cve_row[0]] = cve
        return res

    async def _fetch_cve(self, cve_id):
        """Fetches single CVE to map"""
        async with self.db_pool.acquire() as conn:
            cve_row = await conn.fetchrow("""SELECT cm.id, cm.cve, COALESCE(cm.cvss2_score, cm.cvss3_score, 0.0) AS cvss_score,
                                                    cm.impact_id, cm.exploit_data,
                                                    CASE WHEN cm.id IN (SELECT cve_id FROM cve_rule_mapping AS crm
                                                                        JOIN insights_rule AS ir ON crm.rule_id = ir.id
                                                                        WHERE active = TRUE) THEN TRUE ELSE FALSE END AS is_rule,
                                                    cm.public_date
                                             FROM cve_metadata AS cm
                                             WHERE cm.id = $1 AND cm.public_date IS NOT NULL
                                             LIMIT 1""", cve_id)
            if cve_row:
                cve = {}
                cve["cve"] = cve_row[1]
                cve["cvss_score"] = cve_row[2]
                cve["impact_id"] = cve_row[3]
                cve["exploits"] = cve_row[4] is not None
                cve["is_rule"] = cve_row[5]
                cve["public_date"] = cve_row[6]
                self.cve_map[cve_row[0]] = cve
                return True
        return False

    def get_cve(self, cve_id):
        """Returns CVE dictionary from map or None"""
        if cve_id not in self.cve_map:
            return None
        return self.cve_map[cve_id]

    async def cve_exists(self, cve_id):
        """Checks if CVE exists in map"""
        if cve_id not in self.cve_map:
            await self._fetch_cve(cve_id)
        return cve_id in self.cve_map

    def is_fresh_cve(self, cve_id):
        """Checks if the CVE is fresh based on the freshness threshold"""
        current_date = datetime.now(timezone.utc).date()
        cve_deadline = current_date - timedelta(days=CFG.cve_freshness_threshold)
        cve = self.cve_map.get(cve_id)
        if not cve:
            return None
        return cve["public_date"].date() >= cve_deadline

    def is_high_cvss_cve(self, cve_id):
        """Checks if CVE has cvss >= 7.0"""
        cve = self.cve_map.get(cve_id)
        if not cve:
            return False
        return cve["cvss_score"] >= 7.0

    def is_critical_severity_cve(self, cve_id):
        """Checks if CVE has Critical severity"""
        cve = self.cve_map.get(cve_id)
        if not cve:
            return False
        return cve["impact_id"] == 7

    def is_rule_cve(self, cve_id):
        """Checks if CVE has rule mapped"""
        cve = self.cve_map.get(cve_id)
        if not cve:
            return False
        return cve["is_rule"] is True

    def is_exploitable_cve(self, cve_id):
        """Checks if CVE is exploitable"""
        cve = self.cve_map.get(cve_id)
        if not cve:
            return False
        return cve["exploits"] is True

    def make_events_for_cve(self, cve_id):
        """Builds and set of an notification types for notifications kafka based on CVE"""
        events = set()
        is_fresh = self.is_fresh_cve(cve_id)
        if is_fresh:
            if self.is_high_cvss_cve(cve_id):
                events.add(NotificationType.CVSS_NOTIFICATION)
            if self.is_critical_severity_cve(cve_id):
                events.add(NotificationType.SEVERITY_NOTIFICATION)
            if self.is_rule_cve(cve_id):
                events.add(NotificationType.RULE_NOTIFICATION)

        if self.is_exploitable_cve(cve_id):
            events.add(NotificationType.EXPLOITS_NOTIFICATION)
        return events


class Notificator:
    """Represents whole notificator component"""

    def __init__(self, loop):
        self.loop = loop
        self.results_topic = mqueue.MQReader(CFG.evaluator_results_topic)
        self.db_pool = None
        self.conditions = None
        self.queue_proc = None
        self.queue_proc_task = None

    async def init(self, pool, loop):
        """Async constructor"""
        self.db_pool = pool

        self.conditions = NotificatorConditions(self.db_pool)
        await self.conditions.init()

        self.queue_proc = NotificatorQueue(NOTIFICATOR_PERIOD, self.db_pool, self.conditions, loop)
        await self.queue_proc.init()

    async def stop(self):
        """Stops whole notificator service loop"""
        self.queue_proc_task.cancel()

        await self.results_topic.stop()
        await self.queue_proc.stop()
        self.loop.stop()

    async def _process_new_sys_vulns(self, new_sys_vulns, rh_account_id, acc_num, org_id):
        """Processes new system vulnerabilities sent by evaluator"""
        for info in new_sys_vulns:
            cve_id = info["cve_id"]
            sys_vuln_id = info["sys_vuln_id"]
            cve_exists = await self.conditions.cve_exists(cve_id)
            # if CVE is known to vulnerability and has notification events, add it to queue
            if cve_exists:
                cve = self.conditions.cve_map[cve_id]["cve"]
                events = self.conditions.make_events_for_cve(cve_id)
                if events:
                    item = QueueItem(cve, cve_id, rh_account_id, acc_num, org_id, events)
                    self.queue_proc.notif_cves_queue[sys_vuln_id] = item
            # if CVE is unknown, it needs to be left in second queue until vuln will discover the cve
            else:
                item = QueueItem(None, cve_id, rh_account_id, acc_num, org_id, [])
                self.queue_proc.unkno_cves_queue[sys_vuln_id] = item

    async def _process_mit_sys_vulns(self, mit_sys_vulns):
        """Processes mitigated system vulnerabilities sent by evaluator"""
        # if cve hit got mitigated, try to remove notification from all queues
        for info in mit_sys_vulns:
            sys_vuln_id = info["sys_vuln_id"]
            self.queue_proc.notif_cves_queue.pop(sys_vuln_id, None)
            self.queue_proc.unkno_cves_queue.pop(sys_vuln_id, None)

    async def _process_unmit_sys_vulns(self, unmit_sys_vulns, rh_account_id, acc_num, org_id):
        """Processes unmitigated system vulnerabilities sent by evaluator"""
        # if cves got unmitigated, process them as if they were new
        await self._process_new_sys_vulns(unmit_sys_vulns, rh_account_id, acc_num, org_id)

    async def process_message(self, msg):
        """Processes message from evaluator with system vulnerabilities"""
        LOGGER.debug("Recieved: %s", msg.value)
        try:
            msg_dict = json.loads(msg.value.decode('utf-8'))
        except json.decoder.JSONDecodeError:
            LOGGER.exception("Unable to parse message")
            return

        rh_account_id = msg_dict["rh_account_id"]
        acc_num = msg_dict["account_number"]
        org_id = msg_dict["org_id"]

        await self._process_new_sys_vulns(msg_dict["new_system_vulnerabilities_ids"], rh_account_id, acc_num, org_id)
        await self._process_mit_sys_vulns(msg_dict["mitigated_system_vulnerabilities_ids"])
        await self._process_unmit_sys_vulns(msg_dict["unmitigated_system_vulnerabilities_ids"], rh_account_id, acc_num, org_id)

    async def run(self):
        """Starts whole notificator component"""
        LOGGER.info("Connecting to notificator topics")
        await self.results_topic.start()
        await self.queue_proc.notifications_topic.start()

        self.queue_proc_task = asyncio.create_task(self.queue_proc.process_queue())

        def queue_proc_logger(task):
            try:
                task.result()
            except asyncio.CancelledError:
                pass
            except Exception as ex:  # pylint: disable=broad-except
                LOGGER.exception(ex)
                asyncio.create_task(self.queue_proc.process_queue())
        self.queue_proc_task.add_done_callback(queue_proc_logger)

        try:
            async for msg in self.results_topic.client:
                self.loop.create_task(self.process_message(msg))
        finally:
            await self.stop()


def main():
    """Main"""
    loop = asyncio.get_event_loop()

    status_app = create_status_app(LOGGER)
    _, status_site = create_status_runner(status_app, int(CFG.prometheus_port), LOGGER, loop)
    loop.run_until_complete(status_site.start())

    notificator_app = create_notificator_app(LOGGER, [(r"/api/v1/cache", CacheHandler)])
    _, notif_site = create_notif_app_runner(notificator_app, int(CFG.private_port), LOGGER, loop)
    loop.run_until_complete(notif_site.start())

    LOGGER.info("Initializing notificator service")
    db_pool = loop.run_until_complete(setup_db_pool(CFG))
    notificator = Notificator(loop)
    loop.run_until_complete(notificator.init(db_pool, loop))

    LOGGER.info("Starting notificator service")
    loop.create_task(notificator.run())

    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for sig in signals:
        loop.add_signal_handler(sig, lambda sig=sig: loop.create_task(notificator.stop()))

    loop.run_forever()
    LOGGER.info("Stopped notificator service")


if __name__ == "__main__":
    init_logging()
    main()
