#!/usr/bin/python3

import json
import logging
from os import getenv, listdir
from os.path import isfile, join

from tornado.ioloop import IOLoop
from tornado.web import Application, RequestHandler

def get_logger(name):
    """
    Set logging level and return logger.
    """
    logger = logging.getLogger(name)
    level = getenv('LOGGING_LEVEL', "INFO")
    logger.setLevel(getattr(logging, level, logging.INFO))
    return logger
LOGGER = get_logger(__name__)

# Where can I find user-test-data?
UPATH = '/mock/data/users'
# Where can I find inventory-test-data?
IPATH = '/mock/data/inventory'

class DataLoader:
    """Loads data from JSON files and makes it available to handlers"""
    def __init__(self):
        self.users = {}
        self.sessions = {}
        self.inventory = {}

    def load(self):
        """Load test data from /data/users and /data/inventory"""

        # Load data/users files
        ufiles = [join(UPATH, f) for f in listdir(UPATH) if isfile(join(UPATH,f))]
        for f in ufiles:
            with open(f, "r") as fp:
                # Each user is { 'login':<login>, 'password':<pwd>,'session':<sess-id>, 'inventory':[<sid-1, sid2, ...] }
                u_json = json.load(fp)
                u_data = {}
                for k in ['password','session','inventory']:
                    u_data[k] =u_json[k]
                self.users[u_json['login']] = u_data
                self.sessions[u_json['session']] = u_json['login']

        # Load data/inventory files
        ifiles = [join(IPATH, f) for f in listdir(IPATH) if isfile(join(IPATH,f))]
        for f in ifiles:
            with open(f, "r") as fp:
                # Each inv-file is { 'sid': <sid>, 'rpms': [<nevra-1>, <nevra-2>...] }
                sid_json = json.load(fp)
                self.inventory[sid_json['sid']] = sid_json['rpms']

# TODO: Ugly. There has to be a btter/more-pythonic way to do this
DATA = DataLoader()
DATA.load()

class InvalidSession(Exception):
    pass

class NotFound(Exception):
    pass

class BaseHandler(RequestHandler):
    """Base handler setting CORS headers."""

    def data_received(self, chunk):
        pass

    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.set_header("Access-Control-Allow-Headers", "Content-Type")

    def options(self): # pylint: disable=arguments-differ
        self.finish()

    def process(self, params):
        LOGGER.info('BaseHandler process')
        raise NotImplementedError("Subclass must implement abstract method process(params)")

    def handle_get(self, params):
        """Takes care of validation of input and execution of POST methods."""
        LOGGER.debug('BaseHandler handle_get')
        code = 400
        try:
            res = self.process(params)
            code = 200
        except ValueError as valuerr:
            res = str(valuerr)
            LOGGER.error('ValueError: %s', res)
            code = 400
        except InvalidSession as sesserr:
            res = str(sesserr)
            LOGGER.error('InvalidSession: %s', res)
            code = 403
        except NotFound as notfounderr:
            res = str(notfounderr)
            LOGGER.error('NotFound: %s', res)
            code = 404
        except Exception as err: # pylint: disable=broad-except
            err_id = err.__hash__()
            res = 'Internal server error <%s>: please include this error id in bug report.' % err_id
            code = 500
            LOGGER.error('UKNOWN ERROR ' + str(err))
            # FATAL - we should only get here if things have gone Horribly Worng
            raise

        self.set_status(code)
        self.write(res)
        self.flush()

class LoginHandler(BaseHandler):
    def process(self, params):
        LOGGER.debug('LoginHandler process')
        LOGGER.info('user/pass: ['+params['user']+'/'+params['passwd']+']')
        u = params['user']
        if u in DATA.users:
            if params['passwd'] == DATA.users[u]['password']:
                return DATA.users[u]['session']
            else:
                raise NotFound('Invalid passwd for user: ' + u)
        else:
            raise NotFound('Invalid user: ' + u)

    def get(self, *kwargs, **params):
        super().handle_get(params)

class InventoryHandler(BaseHandler):
    def process(self, params):
        LOGGER.debug('InventoryHandler process')
        s = params['session']
        if s in DATA.sessions:
            u = DATA.sessions[s]
            return str(DATA.users[u]['inventory'])
        else:
            raise InvalidSession('Invalid session: ' + s)

    def get(self, *kwargs, **params):
        super().handle_get(params)

class RpmHandler(BaseHandler):
    def process(self, params):
        LOGGER.debug('RpmHandler process')
        s = params['session']
        if s in DATA.sessions:
            u = DATA.sessions[s]
            inv = DATA.users[u]['inventory']
            sys = params['inventory']
            if sys in inv:
                return str(DATA.inventory[sys])
            else:
                raise NotFound('Inventory [' + sys + '] not found for user [' + u + ']')
        else:
            raise InvalidSession('Invalid session: ' + s)

    def get(self, *kwargs, **params):
        super().handle_get(params)

class NullHandler(RequestHandler):
      def get(self, *args, **kwargs):
          self.set_status(405)  # method not allowed

      def post(self, *args, **kwargs):
          self.write({})

class MockApplication(Application):
    def __init__(self):
        # /login/<user> - returns a session-id for that user, err if not-found
        # /session/<session-id> - ?
        # /inventory/<session-id> - returns all-inv-ids for user of <session-id>
        # /rpms/<session-id>/<inventory-id> - returns RPMDB for inventory-id if inv-id owned by user of sess-id
        handlers = [
            (r"/api/v1/login/(?P<user>[a-zA-Z0-9]+)/(?P<passwd>[a-zA-Z0-9]+)", LoginHandler),
            (r"/api/v1/session/?", NullHandler),
            (r"/api/v1/inventory/(?P<session>[a-zA-Z0-9]+)", InventoryHandler),
            (r"/api/v1/rpms/(?P<session>[a-zA-Z0-9]+)/(?P<inventory>[a-zA-Z0-9]+)", RpmHandler),
        ]
        Application.__init__(self, handlers)
        self.instance = IOLoop.instance()

    def start(self):
        self.instance.start()

def main():
    app = MockApplication()
    app.listen(8080)
    app.start()
    DATA.load()

if __name__ == '__main__':
    main()
