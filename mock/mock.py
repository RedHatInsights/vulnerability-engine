#!/usr/bin/python3

import logging
import os

from tornado.ioloop import IOLoop
from tornado.web import Application, RequestHandler

#
# Static data
# TODO: read all of this from a file/files?
#
# who gets to talk to us?
USERS = {'onesys':'1000', 'twosys':'2000', 'redsys':'3000', 'bluesys':'4000'}

# what login-session do we return? {sessid:user}
SESSIONS = {'1000' : 'onesys', '2000' : 'twosys', '3000' : 'redsys', '4000' : 'bluesys'}

# what systems do they have? {user:[sid,...]}
INVENTORY = {'onesys' : ['000001000'],
             'twosys' : ['000002001', '000002002'],
             'redsys' : ['000003001', '000003002', '000003003'],
             'bluesys' : ['000004000'] }

# what's on various sids? {sid:[nevra,....]}
# TODO: this DEFINITELY needs to come from files
RPMS = {
        '000001000' : ['able'],
        '000002001' : ['baker'],
        '000002002' : ['charlie'],
        '000003001' : ['delta'],
        '000003002' : ['echo'],
        '000003003' : ['foxtrot'],
        '000004000' : ['golf']
        }

def get_logger(name):
    """
    Set logging level and return logger.
    """
    logger = logging.getLogger(name)
    level = os.getenv('LOGGING_LEVEL', "INFO")
    logger.setLevel(getattr(logging, level, logging.INFO))
    return logger

LOGGER = get_logger(__name__)

class InvalidSession(Exception):
    pass

class NotFound(Exception):
    pass

class BaseHandler(RequestHandler):
    """Base handler setting CORS headers."""

    def data_received(self, chunk):
        pass

    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.set_header("Access-Control-Allow-Headers", "Content-Type")

    def options(self): # pylint: disable=arguments-differ
        self.finish()

    def process(self, params):
        LOGGER.info('BaseHandler process')
        raise NotImplementedError("Subclass must implement abstract method process(params)")

    def handle_get(self, params):
        """Takes care of validation of input and execution of POST methods."""
        LOGGER.debug('BaseHandler handle_get')
        code = 400
        try:
            res = self.process(params)
            code = 200
        except ValueError as valuerr:
            res = str(valuerr)
            LOGGER.error('ValueError: %s', res)
            code = 400
        except InvalidSession as sesserr:
            res = str(sesserr)
            LOGGER.error('InvalidSession: %s', res)
            code = 403
        except NotFound as notfounderr:
            res = str(notfounderr)
            LOGGER.error('NotFound: %s', res)
            code = 404
        except Exception as err: # pylint: disable=broad-except
            err_id = err.__hash__()
            res = 'Internal server error <%s>: please include this error id in bug report.' % err_id
            code = 500
            LOGGER.error('UKNOWN ERROR ' + str(err))

        self.set_status(code)
        self.write(res)
        self.flush()

class LoginHandler(BaseHandler):
    def process(self, params):
        LOGGER.debug('LoginHandler process')
        u = params['user']
        if u in USERS:
            return USERS[u]
        else:
            raise NotFound('Invalid user: ' + u)

    def get(self, *kwargs, **params):
        super().handle_get(params)

class InventoryHandler(BaseHandler):
    def process(self, params):
        LOGGER.debug('InventoryHandler process')
        s = params['session']
        if s in SESSIONS:
            u = SESSIONS[s]
            return str(INVENTORY[u])
        else:
            raise InvalidSession('Invalid session: ' + s)

    def get(self, *kwargs, **params):
        super().handle_get(params)

class RpmHandler(BaseHandler):
    def process(self, params):
        LOGGER.debug('RpmHandler process')
        s = params['session']
        if s in SESSIONS:
            u = SESSIONS[s]
            inv = INVENTORY[u]
            sys = params['inventory']
            if sys in inv:
                return str(RPMS[sys])
            else:
                raise NotFound('Inventory [' + sys + '] not found for user [' + u + ']')
        else:
            raise InvalidSession('Invalid session: ' + s)

    def get(self, *kwargs, **params):
        super().handle_get(params)

class NullHandler(RequestHandler):
      def get(self, *args, **kwargs):
          self.set_status(405)  # method not allowed

      def post(self, *args, **kwargs):
          self.write({})

class MockApplication(Application):
    def __init__(self):
        # /login/<user> - returns a session-id for that user, err if not-found
        # /session/<session-id> - ?
        # /inventory/<session-id> - returns all-inv-ids for user of <session-id>
        # /rpms/<session-id>/<inventory-id> - returns RPMDB for inventory-id if inv-id owned by user of sess-id
        handlers = [
            (r"/api/v1/login/(?P<user>[a-zA-Z0-9]+)", LoginHandler),
            (r"/api/v1/session/?", NullHandler),
            (r"/api/v1/inventory/(?P<session>[a-zA-Z0-9]+)", InventoryHandler),
            (r"/api/v1/rpms/(?P<session>[a-zA-Z0-9]+)/(?P<inventory>[a-zA-Z0-9]+)", RpmHandler),
        ]
        Application.__init__(self, handlers)
        self.instance = IOLoop.instance()

    def start(self):
        self.instance.start()

def main():
    app = MockApplication()
    app.listen(8080)
    app.start()

if __name__ == '__main__':
    main()
