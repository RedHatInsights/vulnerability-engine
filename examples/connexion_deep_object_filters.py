#!/usr/bin/env python3
"""
Deep object filtering done in connexion
"""

from collections import deque
from copy import deepcopy
import connexion


def inplace_filter(condition, deck):
    """Filters items in place so all references are pointing to filtered list as opposed to filter() which creates new list() instance"""
    for _ in range(len(deck)):
        item = deck.popleft()
        if condition(item):
            deck.append(item)


DATA = [
    {"id": 1, "details": {"sap": True, "text": "xxee"}},
    {"id": 2, "details": {"sap": True, "text": "eexx"}},
    {"id": 3, "details": {"sap": False, "text": "xxee"}},
    {"id": 4, "details": {"sap": False, "text": "eexx"}},
]

FILTER_DEFINITIONS = {
    "id": lambda retval, filter_value: inplace_filter(lambda x: x["id"] == filter_value, retval),
    "details": {
        "sap": lambda retval, filter_value: inplace_filter(lambda x: x["details"]["sap"] == filter_value, retval),
        "text": lambda retval, filter_value: inplace_filter(lambda x: x["details"]["text"] == filter_value, retval),
    },
}


def walk_filters(retval, node, path):
    """walk through filters dictionary"""
    for key, item in node.items():
        if isinstance(item, dict):
            walk_filters(retval, item, path + [key])
        else:
            filter_ = FILTER_DEFINITIONS
            for elem in path:
                filter_ = filter_[elem]
            filter_[key](retval, item)


def getData(**kwargs):  # pylint: disable=invalid-name
    """Return data"""
    retval = deque(deepcopy(DATA))
    walk_filters(retval, kwargs["filter"], [])
    return list(retval)


def create_app():
    """Creates an aplication object"""
    app = connexion.App("Connexion deep filtering", options={"swagger_ui": True})
    app.add_api("connexion_deep_object_filters.yaml")
    app.app.url_map.strict_slashes = False

    return app


application = create_app()  # pylint: disable=invalid-name


if __name__ == "__main__":
    application.run(host="0.0.0.0", port=8080)
