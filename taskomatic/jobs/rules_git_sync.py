#!/usr/bin/env python3
"""
Importer for insights rules from insights-content git
"""

from datetime import datetime
import os
import tempfile
from functools import reduce
import traceback

from git import Repo
from git.cmd import GitCommandError
from psycopg2.extras import execute_values
import yaml

from common.config import Config
from common.logging import get_logger, init_logging
from common.utils import send_slack_notification
from taskomatic.jobs.common import get_conn

LOGGER = get_logger(__name__)
CFG = Config()

CONTENT_GIT_NAME = "content_git"
PLAYBOOKS_GIT_NAME = "playbooks_git"


def store_versions(conn, content_version, playbooks_version):
    """
    Store SHA of latest imported commit and URL of git repositories used

    Args:
        content_version str: sha of HEAD of insights-content-vulnerability
        playbooks_version str: sha of HEAD of insights-playbooks
    """
    cur = conn.cursor()

    cur.execute("""UPDATE content_version SET insights_content_vulnerability = %(content_version)s,
                                               insights_content_vulnerability_repo = %(content_repo)s,
                                               insights_playbooks = %(playbooks_version)s,
                                               insights_playbooks_repo = %(playbooks_repo)s""",
                {'content_version': content_version, 'content_repo': CFG.content_git_repo,
                 'playbooks_version': playbooks_version, 'playbooks_repo': CFG.playbooks_git_repo})

    conn.commit()

    cur.close()


def import_cves_names(conn, to_import):
    """
    Add celebrity names of CVEs to CVEs

    Args:
        to_import dict: Dict of CVE names, cve is the key, celebrity name is the value
    """
    cur = conn.cursor()

    cur.execute("SELECT cve FROM cve_metadata WHERE celebrity_name IS NOT NULL")
    for cve in cur.fetchall():
        if cve not in to_import:
            cur.execute("UPDATE cve_metadata SET celebrity_name = NULL WHERE cve = %(cve)s", {'cve': cve})
            conn.commit()
    for cve in to_import:
        cur.execute("UPDATE cve_metadata set celebrity_name = %(name)s WHERE cve = %(cve)s", {'cve': cve, 'name': to_import[cve]})
        conn.commit()

    cur.close()


def import_into_db(conn, rules_dict, rules_only_dict):
    """Imports rules into database"""
    cur = conn.cursor()

    to_delete = []
    to_disable = []
    to_enable = []
    to_insert = []
    to_update = []
    to_update_names = []
    to_update_rules_only = []
    to_update_rules_only_names = []

    cur.execute("""SELECT id, name, active from insights_rule""")
    for rule_id, rule_name, active in cur.fetchall():
        if rule_name in rules_only_dict:
            to_update_rules_only.append(rule_id)
            to_update_rules_only_names.append(rule_name)
        elif rule_name in rules_dict:
            to_update.append(rule_id)
            to_update_names.append(rule_name)
            if not active and rules_dict[rule_name]['active']:
                to_enable.append(rule_id)
            elif active and not rules_dict[rule_name]['active']:
                to_disable.append(rule_id)

    to_insert = rules_dict.keys() - to_update_names
    to_insert_rules_only_names = rules_only_dict.keys() - to_update_rules_only_names

    if to_insert:
        rule_insert(conn, cur, to_insert, rules_dict)
    if to_update:
        rule_update(conn, cur, to_update_names, rules_dict)
    if to_delete:
        rule_delete(conn, cur, to_delete)
    if to_enable:
        rule_enable(conn, cur, to_enable)
    if to_disable:
        rule_disable(conn, cur, to_disable)
    if to_insert_rules_only_names:
        rule_only_insert(conn, cur, to_insert_rules_only_names, rules_only_dict)
    if to_update_rules_only:
        rule_only_update(conn, cur, to_update_rules_only_names, rules_only_dict)

    cur.close()


def update_playbooks(cur, to_insert, to_delete):
    """Updates playbooks associated with rules as they have no unique identifiers, it's better to delete them and repopulate

    Args:
        cur: database cursor
        to_insert ([list(tuple)]): List of tuples containing playbook data
        to_delete ([tuple]): List of rules which should have their playbook data deleted and repoplated
    """
    if to_delete:
        cur.execute("""DELETE FROM playbook WHERE rule_id IN (SELECT id from insights_rule WHERE name IN %s)""",
                    (to_delete,))
    for record in to_insert:
        cur.execute("""INSERT INTO playbook (rule_id, play, version, description)
                       VALUES ((SELECT id FROM insights_rule where name = %s), %s, %s, %s)""", record)


def rule_delete(conn, cur, to_delete):
    """Delete rules"""
    rule_disable(conn, cur, to_delete)
    LOGGER.info("Deleting %s rules.", len(to_delete))
    cur.execute("""DELETE FROM playbook WHERE rule_id IN (%s)""", tuple(to_delete))
    cur.execute("""DELETE FROM insights_rule WHERE id IN (%s)""", tuple(to_delete))
    conn.commit()


def rule_disable(conn, cur, to_disable):
    """Disable rule"""
    LOGGER.info("Disabling %s rules.", len(to_disable))
    execute_values(cur, """UPDATE insights_rule AS ir SET active = 'F' FROM (VALUES %s) AS v(id) WHERE ir.id = v.id""",
                   [(x,) for x in to_disable], page_size=len(to_disable))
    conn.commit()


def rule_enable(conn, cur, to_enable):
    """Enable rule"""
    LOGGER.info("Enabling %s rules.", len(to_enable))
    execute_values(cur, """UPDATE insights_rule AS ir SET active = 'T' FROM (VALUES %s) AS v(id) WHERE ir.id = v.id""",
                   [(x,) for x in to_enable], page_size=len(to_enable))
    conn.commit()


def prep_playbooks(rules_dict):
    """Helper function to extract playbooks from rules data dictionary

    Args:
        rules_dict ([dict]): Rules data dictionary

    Returns:
        [list(tuple)]: List of tuples for the SQL command in update_playbooks function
    """
    playbooks = []
    for rule in rules_dict:
        playbooks.extend([(rule, playbook['play'], playbook['version'],
                           yaml.safe_load(playbook['play'])[0].get('name', f"Playbook for {rules_dict[rule]['id']}"))
                          for playbook in rules_dict[rule]['playbooks']])
    return playbooks


def rule_insert(conn, cur, to_insert_names, rules_dict):
    """Insert existing rules"""

    to_insert = [(
        (rules_dict[rule]['id']), (rules_dict[rule]['description']), (rules_dict[rule]['summary']),
        (rules_dict[rule]['reason']), (rules_dict[rule]['resolution']), (rules_dict[rule]['more_info']), (rules_dict[rule]['reboot_required']),
        (rules_dict[rule]['playbook_count']), (rules_dict[rule]['change_risk']), (rules_dict[rule]['kbase_node_id']), (rules_dict[rule]['active']),
        (rules_dict[rule]['rule_impact']), (rules_dict[rule]['publish_date']),
    ) for rule in to_insert_names]

    LOGGER.info("Inserting %s.", ", ".join([insert[0] for insert in to_insert]))

    execute_values(cur, """INSERT INTO insights_rule (name, description_text, summary_text, reason_text, resolution_text, more_info_text,
                                                      reboot_required, playbook_count, change_risk,
                                                      kbase_node_id, active, rule_impact, publish_date) VALUES %s
                           ON CONFLICT (name) DO UPDATE SET description_text = EXCLUDED.description_text, summary_text = EXCLUDED.summary_text,
                           reason_text = EXCLUDED.reason_text, resolution_text = EXCLUDED.resolution_text, more_info_text = EXCLUDED.more_info_text,
                           reboot_required = EXCLUDED.reboot_required, playbook_count = EXCLUDED.playbook_count, change_risk = EXCLUDED.change_risk,
                           kbase_node_id = EXCLUDED.kbase_node_id, active = EXCLUDED.active, rule_impact = EXCLUDED.rule_impact,
                           publish_date = EXCLUDED.publish_date""",
                   to_insert, template='(%s, %s, %s, %s, %s, %s, %s, %s::integer, %s::integer, %s::integer, %s, %s::integer, %s::timestamp)',
                   page_size=len(to_insert))

    insert_rule_cves(conn, cur, to_insert_names, rules_dict)
    update_playbooks(cur, prep_playbooks(rules_dict), tuple({x[0] for x in to_insert}))
    conn.commit()


def insert_rule_cves(conn, cur, to_insert_names, rules_dict):
    """Insert rule CVEs and its mappings"""
    cve_id_mapping = {}
    cur.execute("""SELECT id, cve FROM cve_metadata""")
    for cve_id, cve_name in cur.fetchall():
        cve_id_mapping[cve_name] = cve_id

    for rule_name in to_insert_names:
        rule = rules_dict[rule_name]
        for cve in rule['cves']:
            if cve not in cve_id_mapping:
                cur.execute("""INSERT INTO cve_metadata (cve, description, impact_id) VALUES %s ON CONFLICT (cve) DO UPDATE SET cve = %s
                RETURNING id AS inserted""", ((cve, 'unknown', 0,), cve))
                conn.commit()
                inserted = cur.fetchone()
                cve_id_mapping[cve] = inserted[0]
            cur.execute("""INSERT INTO cve_rule_mapping (cve_id, rule_id) VALUES (%s, (SELECT id from insights_rule WHERE name = %s))
                           ON CONFLICT DO NOTHING""", (cve_id_mapping[cve], rule['id']))
    conn.commit()


def rule_update(conn, cur, to_update_names, rules_dict):
    """Update existing rules"""

    to_update = [(
        (rules_dict[rule]['id']), (rules_dict[rule]['description']), (rules_dict[rule]['summary']),
        (rules_dict[rule]['reason']), (rules_dict[rule]['resolution']), (rules_dict[rule]['more_info']), (rules_dict[rule]['reboot_required']),
        (rules_dict[rule]['playbook_count']), (rules_dict[rule]['change_risk']), (rules_dict[rule]['kbase_node_id']), (rules_dict[rule]['rule_impact']),
        (rules_dict[rule]['publish_date'])
    ) for rule in to_update_names]

    LOGGER.info("Updating %s.", ", ".join([update[0] for update in to_update]))

    execute_values(cur, """UPDATE insights_rule AS ir SET description_text = v.description, summary_text = v.summary,
                    reason_text = v.reason, resolution_text = v.resolution, more_info_text = v.more_info,
                    reboot_required = v.reboot_required, playbook_count = v.playbook_count, change_risk = v.change_risk,
                    kbase_node_id = v.kbase_node_id, rule_impact = v.rule_impact, publish_date = v.publish_date FROM (VALUES %s)
                    AS v(name, description, summary, reason, resolution, more_info, reboot_required, playbook_count, change_risk, kbase_node_id,
                     rule_impact, publish_date)
                    WHERE v.name = ir.name""",
                   to_update, template='(%s, %s, %s, %s, %s, %s, %s, %s::integer, %s::integer, %s::integer, %s::integer, %s::timestamp)',
                   page_size=len(to_update))

    rule_id_mapping = {}
    cur.execute("""SELECT id, name FROM insights_rule""")
    for rule_id, rule_name in cur.fetchall():
        rule_id_mapping[rule_name] = rule_id

    rule_ids = [rule_id_mapping[elem[0]] for elem in to_update]

    cve_rule_tuples = []
    for rule_id in rule_ids:
        cur.execute("""SELECT cve.id FROM cve_metadata AS cve
                JOIN cve_rule_mapping AS crm ON crm.cve_id = cve.id
                JOIN insights_rule AS ir ON ir.id = crm.rule_id WHERE ir.id = %s""", (rule_id,))
        cve_rule_tuples.extend([(cve_id[0], rule_id) for cve_id in cur.fetchall()])

    if cve_rule_tuples:
        execute_values(cur, """INSERT INTO cve_rule_mapping (cve_id, rule_id) VALUES %s ON CONFLICT DO NOTHING""",
                       cve_rule_tuples, template="(%s, %s)", page_size=len(cve_rule_tuples))

    update_playbooks(cur, prep_playbooks(rules_dict), tuple({x[0] for x in to_update}))
    conn.commit()


def rule_only_insert(conn, cur, to_insert_rule_only, rules_only_dict):
    """Insert rules without errkey into db"""
    to_insert = [((rules_only_dict[rule]['id']), (rules_only_dict[rule]['active']), (True)) for rule in to_insert_rule_only]

    LOGGER.info("Inserting rules only %s.", ", ".join([insert[0] for insert in to_insert]))

    execute_values(cur, """INSERT INTO insights_rule (name, active, rule_only) VALUES %s
                           ON CONFLICT (name) DO UPDATE SET active = EXCLUDED.active, rule_only = EXCLUDED.rule_only
                        """, to_insert, template="(%s, %s, %s)", page_size=len(to_insert))
    conn.commit()

    insert_rule_cves(conn, cur, to_insert_rule_only, rules_only_dict)


def rule_only_update(conn, cur, to_update_rule_only, rules_only_dict):
    """Update rules without errkey in db"""
    to_update = [(rules_only_dict[rule]['id'], rules_only_dict[rule]['active']) for rule in to_update_rule_only]

    LOGGER.info("Updating rules only %s.", ", ".join([update[0] for update in to_update]))

    execute_values(cur, """UPDATE insights_rule AS ir SET active = v.active
                           FROM (VALUES %s) AS v(name, active)
                           where v.name = ir.name
                        """, to_update, template="(%s, %s)", page_size=len(to_update))

    rule_id_mapping = {}
    cur.execute("""SELECT id, name FROM insights_rule""")
    for rule_id, rule_name in cur.fetchall():
        rule_id_mapping[rule_name] = rule_id

    rule_ids = [rule_id_mapping[elem[0]] for elem in to_update]

    cve_rule_tuples = []
    for rule_id in rule_ids:
        cur.execute("""SELECT cve.id FROM cve_metadata AS cve
                JOIN cve_rule_mapping AS crm ON crm.cve_id = cve.id
                JOIN insights_rule AS ir ON ir.id = crm.rule_id WHERE ir.id = %s""", (rule_id,))
        cve_rule_tuples.extend([(cve_id[0], rule_id) for cve_id in cur.fetchall()])

    if cve_rule_tuples:
        execute_values(cur, """INSERT INTO cve_rule_mapping (cve_id, rule_id) VALUES %s ON CONFLICT DO NOTHING""",
                       cve_rule_tuples, template="(%s, %s)", page_size=len(cve_rule_tuples))
    conn.commit()


def resolution_risk_map(config_file):
    """Returns mapping of resolution risk to number"""
    with open(config_file) as file_desc:
        data = yaml.safe_load(file_desc)
    return data['resolution_risk']


def impact_string_map(config_file):
    """Returns mapping of impact string to number"""
    with open(config_file) as file_desc:
        data = yaml.safe_load(file_desc)
    return data['severity']


def sync(tmpdirname, content_version, playbooks_version):  # pylint: disable=too-many-branches, too-many-statements
    """Sync from dirs function"""

    content_git = f"{tmpdirname}/{CONTENT_GIT_NAME}"
    playbooks_git = f"{tmpdirname}/{PLAYBOOKS_GIT_NAME}"
    securiry_rules_dir = '{}/content'.format(content_git)
    playbooks_dir = '{}/playbooks/security'.format(playbooks_git)
    for git_dir in (securiry_rules_dir, playbooks_dir):
        if not os.path.isdir(git_dir):
            LOGGER.error("%s directory does not exist", git_dir)
            return

    risk_map = resolution_risk_map(os.path.join(content_git, 'content/config.yaml'))
    impact_map = impact_string_map(os.path.join(content_git, 'content/config.yaml'))

    conn = get_conn()

    cves_names = {}

    # pylint: disable=too-many-nested-blocks
    for file_name in os.listdir(securiry_rules_dir):
        dir_name = '{}/{}'.format(securiry_rules_dir, file_name)
        if os.path.isdir(dir_name):
            try:
                with open(os.path.join(dir_name, 'plugin.yaml'), 'r') as stream:
                    plugin_info = yaml.safe_load(stream)

                to_import = {}
                all_keys_cves = set()
                for nested_file in os.listdir(dir_name):
                    full_nested_path = os.path.join(dir_name, nested_file)
                    if os.path.isdir(full_nested_path):
                        with open(os.path.join(full_nested_path, 'metadata.yaml'), 'r') as stream:
                            metadata = yaml.safe_load(stream)
                        rule_playbook_dir = os.path.join(playbooks_dir, file_name, nested_file, 'rhel_host')
                        playbooks = []
                        if os.path.isdir(rule_playbook_dir):
                            for play in os.listdir(rule_playbook_dir):
                                if play.endswith('_fixit.yml'):
                                    with open(os.path.join(rule_playbook_dir, play)) as play_stream:
                                        playbooks.append({'play': play_stream.read(), 'version': playbooks_version})
                        rule = {
                            'active': metadata.get('status') == 'active',
                            'change_risk': risk_map.get(metadata.get('resolution_risk'), 1),
                            'cves': metadata.get('cves'),
                            'description': plugin_info.get('name') + ': ' + metadata.get('description'),
                            'id': '{}|{}'.format(file_name, nested_file),
                            'kbase_node_id': plugin_info.get('node_id') if plugin_info.get('node_id') else None,
                            'playbook_count': len(playbooks),
                            'playbooks': playbooks,
                            'publish_date': datetime.strptime(metadata['publish_date'], '%Y-%m-%d %H:%M:%S') if 'publish_date' in metadata else None,
                            'reboot_required': plugin_info.get('reboot_required'),
                            'rule_impact': impact_map.get(metadata.get('severity'), 1)
                        }
                        for cve in metadata.get('cves'):
                            all_keys_cves.add(cve)

                        for info_file, attribute in [('summary.md', 'summary'), ('reason.md', 'reason'),
                                                     ('resolution.md', 'resolution'), ('more_info.md', 'more_info')]:
                            if os.path.exists(os.path.join(full_nested_path, info_file)):
                                with open(os.path.join(full_nested_path, info_file)) as file_desc:
                                    rule[attribute] = file_desc.read()
                            else:
                                with open(os.path.join(dir_name, info_file)) as file_desc:
                                    rule[attribute] = file_desc.read()
                        to_import[rule['id']] = rule

                # create overall rule only without errorkey to store pass data
                rule_only = {}
                is_any_active = reduce(lambda was, rule: was if was else rule["active"], list(to_import.values()), False)
                rule_only["active"] = is_any_active
                rule_only["cves"] = list(all_keys_cves)
                rule_only["id"] = file_name
                import_into_db(conn, to_import, {rule_only["id"]: rule_only})
                for cve in all_keys_cves:
                    if plugin_info.get('name') is not None:
                        cves_names[cve] = plugin_info.get('name')

            except Exception:  # pylint: disable=broad-except
                LOGGER.exception('Error during rule parsing: ')
                send_slack_notification('Error in rules_git_sync: {}'.format(traceback.format_exc()))

    store_versions(conn, content_version, playbooks_version)
    import_cves_names(conn, cves_names)
    conn.close()


def clone_repo(git_repo, repo_dir_name):
    """Clone single git repo"""
    if not git_repo:
        LOGGER.error("Git repo for %s not set.", repo_dir_name)
        return False
    git_repo = git_repo.replace("github.com", "%s@github.com" % CFG.git_token) if CFG.git_token else git_repo
    try:
        repo = Repo.clone_from(git_repo, repo_dir_name, depth=1)
    except GitCommandError:
        LOGGER.exception("Error cloning repo: ")
        return False
    return repo.head.object.hexsha


def clone_repos(tmpdirname):
    """Clone git repos to temp dir"""
    results = (
        clone_repo(CFG.content_git_repo, f"{tmpdirname}/{CONTENT_GIT_NAME}"),
        clone_repo(CFG.playbooks_git_repo, f"{tmpdirname}/{PLAYBOOKS_GIT_NAME}"),
    )
    return all(results), results


def run():
    """Application entrypoint"""
    LOGGER.info('Started rules_git_sync job.')
    with tempfile.TemporaryDirectory() as tmpdirname:
        LOGGER.info("Cloning repos.")
        success, revisions = clone_repos(tmpdirname)
        if success:
            LOGGER.info("Cloning repos successful, starting sync.")
            sync(tmpdirname, revisions[0], revisions[1])
    LOGGER.info('Finished rules_git_sync job.')


if __name__ == '__main__':
    init_logging()
    run()
