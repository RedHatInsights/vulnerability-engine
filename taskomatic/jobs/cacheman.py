#!/usr/bin/env python3
"""
Periodic account-CVE systems affected cache maintenance
"""

from psycopg2.extras import execute_values

from common.bounded_executor import BoundedExecutor
from common.config import Config
from common.database_handler import DatabasePool, DatabasePoolConnection
from common.logging import get_logger, init_logging
from common.utils import validate_cve_cache_keepalive
from taskomatic.jobs.common import get_conn

LOGGER = get_logger(__name__)

CFG = Config()

CACHE_WORKERS = 4


def _materialize_cve_cache(cur, account_id, account_name, current_cache):
    LOGGER.debug("Materializing cache for account '%s' started.", account_name)
    cur.execute(
        """SELECT sv.cve_id,
                          COUNT(*) AS systems_affected,
                          SUM(CASE WHEN sv.status_id != cad.status_id THEN 1 ELSE 0 END) AS systems_status_divergent
                   FROM system_vulnerabilities_active sv INNER JOIN
                        system_platform sp ON (sv.system_id = sp.id AND
                                               sp.rh_account_id = %s AND
                                               sp.opt_out = false AND
                                               sp.stale = false AND
                                               sp.when_deleted IS NULL AND
                                               coalesce(sp.host_type, 'null') != 'edge') INNER JOIN
                        inventory.hosts ih ON sp.inventory_id = ih.id LEFT JOIN
                        cve_account_data cad ON (sv.cve_id = cad.cve_id AND
                                                 cad.rh_account_id = %s)
                   WHERE sv.rh_account_id = %s AND
                         (sv.when_mitigated IS NULL OR (sv.mitigation_reason IS NULL AND
                                                        sv.rule_id IN (SELECT id FROM insights_rule WHERE active = true AND
                                                                                                          rule_only = false)))
                   GROUP BY sv.cve_id""",
        (
            account_id,
            account_id,
            account_id,
        ),
    )

    current_cve_cache = current_cache.get(account_id, {}).get("cve_cache", {})
    to_insert = []
    to_update = []
    for cve_id, systems_affected, systems_status_divergent in cur.fetchall():
        cve_cache = current_cve_cache.get(cve_id)
        if not cve_cache:
            to_insert.append((account_id, cve_id, systems_affected, systems_status_divergent))
        else:
            if cve_cache[0] != systems_affected or cve_cache[1] != systems_status_divergent:
                to_update.append((account_id, cve_id, systems_affected, systems_status_divergent))
            current_cve_cache.pop(cve_id)
    to_delete = list(current_cve_cache.keys())

    LOGGER.debug("Account '%s' - to_insert: %s", account_name, len(to_insert))
    if to_insert:
        execute_values(
            cur,
            """INSERT INTO cve_account_cache (rh_account_id, cve_id, systems_affected, systems_status_divergent)
                               VALUES %s""",
            to_insert,
            page_size=len(to_insert),
        )

    LOGGER.debug("Account '%s' - to_update: %s", account_name, len(to_update))
    if to_update:
        execute_values(
            cur,
            """UPDATE cve_account_cache AS cac
                               SET systems_affected = v.systems_affected,
                                   systems_status_divergent = v.systems_status_divergent
                               FROM (VALUES %s) AS v(rh_account_id, cve_id, systems_affected, systems_status_divergent)
                               WHERE v.rh_account_id = cac.rh_account_id AND
                                     v.cve_id = cac.cve_id""",
            to_update,
            page_size=len(to_update),
        )

    LOGGER.debug("Account '%s' - to_delete: %s", account_name, len(to_delete))
    if to_delete:
        cur.execute("""DELETE FROM cve_account_cache WHERE rh_account_id = %s AND cve_id IN %s""", (account_id, tuple(to_delete)))

    LOGGER.info("Materializing cache for account '%s' finished.", account_name)


def _materialize_rule_cache(cur, account_id, account_name, current_cache):
    LOGGER.debug("Materializing rule cache for account '%s' started.", account_name)
    cur.execute(
        """
        SELECT sv.rule_id, COUNT(*)
        FROM system_vulnerabilities_active AS sv
        JOIN system_platform AS sp ON (sv.system_id = sp.id AND
                                       sp.rh_account_id = %s AND
                                       sp.opt_out = FALSE AND
                                       sp.stale = FALSE AND
                                       sp.when_deleted IS NULL AND
                                       COALESCE(sp.host_type, 'NULL') != 'edge')
        INNER JOIN inventory.hosts ih ON sp.inventory_id = ih.id
        WHERE sv.rh_account_id = %s AND
              sv.rule_id IN (SELECT ir.id FROM insights_rule AS ir WHERE ir.active = TRUE AND NOT ir.rule_only) AND
              sv.mitigation_reason IS NULL
        GROUP BY sv.rule_id
        """,
        (account_id, account_id),
    )

    current_rule_cache = current_cache.get(account_id, {}).get("rule_cache", {})

    to_insert = []
    to_update = []
    for rule_id, system_count in cur.fetchall():
        cached_systems = current_rule_cache.get(rule_id, None)
        if not cached_systems:
            to_insert.append((account_id, rule_id, system_count))
        else:
            if cached_systems != system_count:
                to_update.append((account_id, rule_id, system_count))
            current_rule_cache.pop(rule_id)
    to_delete = list(current_rule_cache.keys())

    LOGGER.debug("Account '%s', rule cache - to_insert: %s", account_name, len(to_insert))
    if to_insert:
        execute_values(
            cur,
            """INSERT INTO rule_account_cache (rh_account_id, rule_id, systems_affected)
                               VALUES %s""",
            to_insert,
            page_size=len(to_insert),
        )

    LOGGER.debug("Account '%s', rule cache - to_update: %s", account_name, len(to_update))
    if to_update:
        execute_values(
            cur,
            """UPDATE rule_account_cache AS rac
                               SET systems_affected = v.systems_affected
                               FROM (VALUES %s) AS v(rh_account_id, rule_id, systems_affected)
                               WHERE rac.rh_account_id = v.rh_account_id AND
                                     rac.rule_id = v.rule_id""",
            to_update,
            page_size=len(to_update),
        )

    LOGGER.debug("Account '%s', rule cache - to_delete: %s", account_name, len(to_delete))
    if to_delete:
        cur.execute("""DELETE FROM rule_account_cache WHERE rh_account_id = %s AND rule_id IN %s""", (account_id, tuple(to_delete)))

    LOGGER.debug("Materializing rule cache for account '%s' finished.", account_name)


def _materialize_caches(account_id, account_name, current_cache):
    with DatabasePoolConnection() as conn:
        with conn.cursor() as cur:
            _materialize_cve_cache(cur, account_id, account_name, current_cache)
            _materialize_rule_cache(cur, account_id, account_name, current_cache)

            cur.execute("""UPDATE rh_account SET cve_cache_from = now() WHERE id = %s""", (account_id,))
        conn.commit()


def run():
    """Application entrypoint"""
    LOGGER.info("Started cacheman job.")

    conn = get_conn()
    cur = conn.cursor()

    current_cache = {}

    cur.execute(
        """SELECT rh_account_id, cve_id, systems_affected, systems_status_divergent
                   FROM cve_account_cache"""
    )
    for rh_account_id, cve_id, systems_affected, systems_status_divergent in cur.fetchall():
        current_cache.setdefault(rh_account_id, {}).setdefault("cve_cache", {})[cve_id] = (systems_affected, systems_status_divergent)

    cur.execute("""SELECT rh_account_id, rule_id, systems_affected FROM rule_account_cache""")
    for rh_account_id, rule_id, systems_affected in cur.fetchall():
        current_cache.setdefault(rh_account_id, {}).setdefault("rule_cache", {})[rule_id] = systems_affected

    cur.execute("""SELECT id FROM rh_account WHERE cve_cache_from IS NOT NULL""")
    for (rh_account_id,) in cur.fetchall():
        current_cache.setdefault(rh_account_id, {})["cache_enabled"] = True

    cur.execute(
        """SELECT sp.rh_account_id, a.account_number, a.cve_cache_from,
                          GREATEST(MAX(sp.last_evaluation), MAX(sp.advisor_evaluated), MAX(sp.when_deleted),
                                   MAX(a.last_status_change)) AS last_system_change,
                          a.cve_cache_keepalive,
                          COUNT(*) AS total_systems
                   FROM system_platform sp INNER JOIN
                        rh_account a on sp.rh_account_id = a.id
                   GROUP BY sp.rh_account_id, a.account_number, a.cve_cache_from, a.cve_cache_keepalive
                   HAVING COUNT(*) >= %s""",
        (CFG.cache_minimal_account_systems,),
    )
    accounts = [
        (account_id, account_name, cve_cache_from, last_system_change, cve_cache_keepalive)
        for account_id, account_name, cve_cache_from, last_system_change, cve_cache_keepalive, _ in cur.fetchall()
        if validate_cve_cache_keepalive(cve_cache_keepalive, 2)
    ]
    LOGGER.info("Accounts with enabled cache: %s", len(accounts))
    accounts_to_refresh = [account for account in accounts if account[3] and (not account[2] or account[3] > account[2])]
    LOGGER.info("Accounts requiring cache refresh: %s", len(accounts_to_refresh))

    # Process accounts in parallel
    with DatabasePool(CACHE_WORKERS):
        executor = BoundedExecutor(CACHE_WORKERS, max_workers=CACHE_WORKERS)
        futures = []
        for account_id, account_name, _, _, _ in accounts_to_refresh:
            futures.append(executor.submit(_materialize_caches, account_id, account_name, current_cache))
        for future in futures:
            future.result()
        executor.shutdown()
    # Pop out cached accounts after all workers are done
    for account_id, _, _, _, _ in accounts:
        current_cache.pop(account_id, None)

    LOGGER.info("Accounts to disable cache: %s", len(current_cache))
    if current_cache:
        cur.execute("""DELETE FROM cve_account_cache WHERE rh_account_id IN %s""", (tuple(current_cache.keys()),))
        cur.execute("""DELETE FROM rule_account_cache WHERE rh_account_id IN %s""", (tuple(current_cache.keys()),))
        cur.execute("""UPDATE rh_account SET cve_cache_from = NULL WHERE id IN %s""", (tuple(current_cache.keys()),))

    conn.commit()

    cur.close()
    conn.close()
    LOGGER.info("Finished cacheman job.")


if __name__ == "__main__":
    init_logging()
    run()
