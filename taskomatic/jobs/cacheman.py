#!/usr/bin/env python3
"""
Periodic account-CVE systems affected cache maintenance
"""
import json

from psycopg2.extras import execute_values
from psycopg2.sql import SQL

from common.bounded_executor import BoundedExecutor
from common.config import Config
from common.database_handler import DatabasePool
from common.database_handler import DatabasePoolConnection
from common.feature_flags import EDGE_PARITY_FEATURE
from common.feature_flags import initialize_unleash
from common.feature_flags import UNLEASH
from common.logging import get_logger
from common.logging import init_logging
from common.utils import validate_cve_cache_keepalive
from taskomatic.jobs.common import get_conn

LOGGER = get_logger(__name__)

CFG = Config()

CACHE_WORKERS = 4


def _host_type_condition(all_host_types):
    if all_host_types:
        return SQL("")
    return SQL(" AND coalesce(sp.host_type, 'null') != 'edge'")


def _inventory_groups_condition(group_ids):
    if not group_ids:
        return SQL(" AND %s"), True

    include_ungrouped = False
    groups = []
    for group in group_ids:
        if group == []:
            include_ungrouped = True
        else:
            groups.append(json.dumps(json.dumps(group)))
    groups = "{" + ",".join(groups) + "}"
    if include_ungrouped:
        return SQL(" AND (ih.groups @> ANY(%s::jsonb[]) OR ih.groups = '[]')"), groups
    return SQL(" AND ih.groups @> ANY(%s::jsonb[])"), groups


def _select_count_affected(account_id, group_ids, all_host_types=False):
    host_type_cond = _host_type_condition(all_host_types)
    groups_cond, groups_arg = _inventory_groups_condition(group_ids)

    return (
        SQL(
            """
            SELECT sv.cve_id,
                   COUNT(*) FILTER (WHERE sv.remediation_type_id != 0) AS systems_affected,
                   SUM(CASE WHEN COALESCE(scd.status_id, 0) != cad.status_id AND sv.remediation_type_id != 0 THEN 1 ELSE 0 END)
                       AS systems_status_divergent,
                   COUNT(*) FILTER (WHERE sv.remediation_type_id = 0) AS systems_affected_unpatched,
                   SUM(CASE WHEN COALESCE(scd.status_id, 0) != cad.status_id AND sv.remediation_type_id = 0 THEN 1 ELSE 0 END)
                       AS systems_status_divergent_unpatched,
                   BOOL_OR(sv.advisory_available) AS advisory_available
            FROM system_vulnerabilities_active sv INNER JOIN
                 system_platform sp ON (sv.system_id = sp.id AND
                                        sp.rh_account_id = %s AND
                                        sp.opt_out = false AND
                                        sp.stale = false AND
                                        sp.when_deleted IS NULL{host_type_cond}) INNER JOIN
                 inventory.hosts ih ON sp.inventory_id = ih.id LEFT JOIN
                 cve_account_data cad ON (sv.cve_id = cad.cve_id AND
                                          cad.rh_account_id = %s) LEFT JOIN
                 system_cve_data scd ON (sv.system_id = scd.system_id AND
                                         sv.cve_id = scd.cve_id)
            WHERE sv.rh_account_id = %s AND
                  (sv.when_mitigated IS NULL OR (sv.mitigation_reason IS NULL AND
                                                 sv.rule_id IN (SELECT id FROM insights_rule WHERE active = true AND
                                                                rule_only = false))) {groups_cond}
            GROUP BY sv.cve_id
            """
        ).format(host_type_cond=host_type_cond, groups_cond=groups_cond),
        [account_id, account_id, account_id, groups_arg],
    )


def _select_count_unpatched(account_id, group_ids, all_host_types=False):
    host_type_cond = _host_type_condition(all_host_types)
    groups_cond, groups_arg = _inventory_groups_condition(group_ids)

    return (
        SQL(
            """
            SELECT vpc.cve_id,
                   0 AS systems_affected,
                   0 AS systems_status_divergent,
                   COUNT(DISTINCT svp.system_id) AS systems_affected_unpatched,
                   SUM(CASE WHEN COALESCE(scd.status_id, 0) != cad.status_id THEN 1 ELSE 0 END)
                       AS systems_status_divergent_unpatched,
                   FALSE AS advisory_available
            FROM system_vulnerable_package svp INNER JOIN
                 system_platform sp ON (svp.system_id = sp.id AND
                                        sp.rh_account_id = %s AND
                                        sp.opt_out = false AND
                                        sp.stale = false AND
                                        sp.when_deleted IS NULL{host_type_cond}) INNER JOIN
                 inventory.hosts ih ON sp.inventory_id = ih.id INNER JOIN
                 vulnerable_package_cve vpc ON svp.vulnerable_package_id = vpc.vulnerable_package_id LEFT JOIN
                 cve_account_data cad ON (vpc.cve_id = cad.cve_id AND
                                          cad.rh_account_id = %s) LEFT JOIN
                 system_cve_data scd ON (svp.system_id = scd.system_id AND
                                         vpc.cve_id = scd.cve_id)
            WHERE svp.rh_account_id = %s {groups_cond}
            GROUP BY vpc.cve_id
            """
        ).format(host_type_cond=host_type_cond, groups_cond=groups_cond),
        [account_id, account_id, account_id, groups_arg],
    )


def _materialize_cve_cache(cur, account_id, account_name, group_ids, current_cache, all_host_types=False):
    LOGGER.debug("Materializing cache for account '%s' started.", account_name)

    count_affected_sq, affected_params = _select_count_affected(account_id, group_ids, all_host_types)
    count_unpatched_sq, unpatched_params = _select_count_unpatched(account_id, group_ids, all_host_types)

    main_sq = """
        SELECT cve_id,
               SUM(systems_affected) AS systems_affected,
               SUM(systems_status_divergent) AS systems_status_divergent,
               SUM(systems_affected_unpatched) AS systems_affected_unpatched,
               SUM(systems_status_divergent_unpatched) AS systems_status_divergent_unpatched,
               BOOL_OR(advisory_available) AS advisory_available
        FROM ({} UNION {}) AS t
        GROUP BY cve_id
        """

    cur.execute(
        SQL(main_sq).format(count_affected_sq, count_unpatched_sq),
        tuple(affected_params + unpatched_params),
    )

    current_cve_cache = current_cache.get(account_id, {}).get("cve_cache", {})
    to_insert = []
    to_update = []
    for (
        cve_id,
        systems_affected,
        systems_status_divergent,
        systems_affected_unpatched,
        systems_status_divergent_unpatched,
        advisory_available,
    ) in cur.fetchall():
        cve_cache = current_cve_cache.get(cve_id)
        if not cve_cache:
            to_insert.append(
                (
                    account_id,
                    cve_id,
                    systems_affected,
                    systems_status_divergent,
                    systems_affected_unpatched,
                    systems_status_divergent_unpatched,
                    advisory_available,
                )
            )
        else:
            if (
                cve_cache[0] != systems_affected
                or cve_cache[1] != systems_status_divergent
                or cve_cache[2] != systems_affected_unpatched
                or cve_cache[3] != systems_status_divergent_unpatched
                or cve_cache[4] != advisory_available
            ):
                to_update.append(
                    (
                        account_id,
                        cve_id,
                        systems_affected,
                        systems_status_divergent,
                        systems_affected_unpatched,
                        systems_status_divergent_unpatched,
                        advisory_available,
                    )
                )
            current_cve_cache.pop(cve_id)
    to_delete = list(current_cve_cache.keys())

    LOGGER.debug("Account '%s' - to_insert: %s", account_name, len(to_insert))
    if to_insert:
        execute_values(
            cur,
            """INSERT INTO cve_account_cache (rh_account_id, cve_id, systems_affected, systems_status_divergent,
                                              systems_affected_unpatched, systems_status_divergent_unpatched,
                                              advisory_available)
               VALUES %s""",
            to_insert,
            page_size=len(to_insert),
        )

    LOGGER.debug("Account '%s' - to_update: %s", account_name, len(to_update))
    if to_update:
        execute_values(
            cur,
            """UPDATE cve_account_cache AS cac
               SET systems_affected = v.systems_affected,
                   systems_status_divergent = v.systems_status_divergent,
                   systems_affected_unpatched = v.systems_affected_unpatched,
                   systems_status_divergent_unpatched = v.systems_status_divergent_unpatched,
                   advisory_available = v.advisory_available
               FROM (VALUES %s) AS v(
                   rh_account_id,
                   cve_id,
                   systems_affected,
                   systems_status_divergent,
                   systems_affected_unpatched,
                   systems_status_divergent_unpatched,
                   advisory_available
               )
               WHERE v.rh_account_id = cac.rh_account_id AND
                     v.cve_id = cac.cve_id""",
            to_update,
            page_size=len(to_update),
            template="(%s, %s, %s, %s, %s, %s, %s::BOOLEAN)",
        )

    LOGGER.debug("Account '%s' - to_delete: %s", account_name, len(to_delete))
    if to_delete:
        cur.execute("""DELETE FROM cve_account_cache WHERE rh_account_id = %s AND cve_id IN %s""", (account_id, tuple(to_delete)))

    LOGGER.info("Materializing cache for account '%s' finished.", account_name)


def _materialize_rule_cache(cur, account_id, account_name, group_ids, current_cache, all_host_types=False):
    host_type_cond = _host_type_condition(all_host_types)
    groups_cond, groups_arg = _inventory_groups_condition(group_ids)

    LOGGER.debug("Materializing rule cache for account '%s' started.", account_name)
    main_sq = """
            SELECT sv.rule_id, COUNT(*)
        FROM system_vulnerabilities_active AS sv
        JOIN system_platform AS sp ON (sv.system_id = sp.id AND
                                       sp.rh_account_id = %s AND
                                       sp.opt_out = FALSE AND
                                       sp.stale = FALSE AND
                                       sp.when_deleted IS NULL{host_type_cond})
        INNER JOIN inventory.hosts ih ON sp.inventory_id = ih.id
        WHERE sv.rh_account_id = %s AND
              sv.rule_id IN (SELECT ir.id FROM insights_rule AS ir WHERE ir.active = TRUE AND NOT ir.rule_only) AND
              sv.mitigation_reason IS NULL
              {groups_cond}
        GROUP BY sv.rule_id
    """
    cur.execute(SQL(main_sq).format(host_type_cond=host_type_cond, groups_cond=groups_cond), [account_id, account_id, groups_arg])

    current_rule_cache = current_cache.get(account_id, {}).get("rule_cache", {})

    to_insert = []
    to_update = []
    for rule_id, system_count in cur.fetchall():
        cached_systems = current_rule_cache.get(rule_id, None)
        if not cached_systems:
            to_insert.append((account_id, rule_id, system_count))
        else:
            if cached_systems != system_count:
                to_update.append((account_id, rule_id, system_count))
            current_rule_cache.pop(rule_id)
    to_delete = list(current_rule_cache.keys())

    LOGGER.debug("Account '%s', rule cache - to_insert: %s", account_name, len(to_insert))
    if to_insert:
        execute_values(
            cur,
            """INSERT INTO rule_account_cache (rh_account_id, rule_id, systems_affected)
                               VALUES %s""",
            to_insert,
            page_size=len(to_insert),
        )

    LOGGER.debug("Account '%s', rule cache - to_update: %s", account_name, len(to_update))
    if to_update:
        execute_values(
            cur,
            """UPDATE rule_account_cache AS rac
                               SET systems_affected = v.systems_affected
                               FROM (VALUES %s) AS v(rh_account_id, rule_id, systems_affected)
                               WHERE rac.rh_account_id = v.rh_account_id AND
                                     rac.rule_id = v.rule_id""",
            to_update,
            page_size=len(to_update),
        )

    LOGGER.debug("Account '%s', rule cache - to_delete: %s", account_name, len(to_delete))
    if to_delete:
        cur.execute("""DELETE FROM rule_account_cache WHERE rh_account_id = %s AND rule_id IN %s""", (account_id, tuple(to_delete)))

    LOGGER.debug("Materializing rule cache for account '%s' finished.", account_name)


def _materialize_caches(account_id, account_name, group_ids, current_cache, all_host_types=False):
    with DatabasePoolConnection() as conn:
        with conn.cursor() as cur:
            _materialize_cve_cache(cur, account_id, account_name, group_ids, current_cache, all_host_types)
            _materialize_rule_cache(cur, account_id, account_name, group_ids, current_cache, all_host_types)

            cur.execute("""UPDATE rh_account SET cve_cache_from = now() WHERE id = %s""", (account_id,))
        conn.commit()


def run():
    """Application entrypoint"""
    LOGGER.info("Started cacheman job.")

    conn = get_conn()
    cur = conn.cursor()

    current_cache = {}

    cur.execute(
        """SELECT rh_account_id, cve_id, systems_affected, systems_status_divergent,
                  systems_affected_unpatched, systems_status_divergent_unpatched,
                  advisory_available
           FROM cve_account_cache"""
    )
    for (
        rh_account_id,
        cve_id,
        systems_affected,
        systems_status_divergent,
        systems_affected_unpatched,
        systems_status_divergent_unpatched,
        advisory_available,
    ) in cur.fetchall():
        current_cache.setdefault(rh_account_id, {}).setdefault("cve_cache", {})[cve_id] = (
            systems_affected,
            systems_status_divergent,
            systems_affected_unpatched,
            systems_status_divergent_unpatched,
            advisory_available,
        )

    cur.execute("""SELECT rh_account_id, rule_id, systems_affected FROM rule_account_cache""")
    for rh_account_id, rule_id, systems_affected in cur.fetchall():
        current_cache.setdefault(rh_account_id, {}).setdefault("rule_cache", {})[rule_id] = systems_affected

    cur.execute("""SELECT id FROM rh_account WHERE cve_cache_from IS NOT NULL""")
    for (rh_account_id,) in cur.fetchall():
        current_cache.setdefault(rh_account_id, {})["cache_enabled"] = True

    cur.execute(
        """SELECT sp.rh_account_id, a.account_number, a.cve_cache_from,
                          GREATEST(MAX(sp.last_evaluation), MAX(sp.advisor_evaluated), MAX(sp.when_deleted),
                                   MAX(a.last_status_change)) AS last_system_change,
                          a.cve_cache_keepalive,
                          a.cve_cache_groups,
                          COUNT(*) AS total_systems
                   FROM system_platform sp INNER JOIN
                        rh_account a on sp.rh_account_id = a.id
                   GROUP BY sp.rh_account_id, a.account_number, a.cve_cache_from, a.cve_cache_keepalive, a.cve_cache_groups
                   HAVING COUNT(*) >= %s""",
        (CFG.cache_minimal_account_systems,),
    )
    accounts = [
        (account_id, account_name, cve_cache_from, last_system_change, cve_cache_keepalive, cve_cache_groups)
        for account_id, account_name, cve_cache_from, last_system_change, cve_cache_keepalive, cve_cache_groups, _ in cur.fetchall()
        if validate_cve_cache_keepalive(cve_cache_keepalive, 2)
    ]
    LOGGER.info("Accounts with enabled cache: %s", len(accounts))
    accounts_to_refresh = [account for account in accounts if account[3] and (not account[2] or account[3] > account[2])]
    LOGGER.info("Accounts requiring cache refresh: %s", len(accounts_to_refresh))

    all_host_types = UNLEASH.is_enabled(EDGE_PARITY_FEATURE)
    if all_host_types:
        LOGGER.info("Including all host types (Edge Parity feature)")

    # Process accounts in parallel
    with DatabasePool(CACHE_WORKERS):
        executor = BoundedExecutor(CACHE_WORKERS, max_workers=CACHE_WORKERS)
        futures = []
        for account_id, account_name, _, _, _, cve_cache_groups in accounts_to_refresh:
            futures.append(executor.submit(_materialize_caches, account_id, account_name, cve_cache_groups, current_cache, all_host_types))
        for future in futures:
            future.result()
        executor.shutdown()
    # Pop out cached accounts after all workers are done
    for account_id, _, _, _, _, _ in accounts:
        current_cache.pop(account_id, None)

    LOGGER.info("Accounts to disable cache: %s", len(current_cache))
    if current_cache:
        cur.execute("""DELETE FROM cve_account_cache WHERE rh_account_id IN %s""", (tuple(current_cache.keys()),))
        cur.execute("""DELETE FROM rule_account_cache WHERE rh_account_id IN %s""", (tuple(current_cache.keys()),))
        cur.execute("""UPDATE rh_account SET cve_cache_from = NULL WHERE id IN %s""", (tuple(current_cache.keys()),))

    conn.commit()

    cur.close()
    conn.close()
    LOGGER.info("Finished cacheman job.")


if __name__ == "__main__":
    init_logging()
    initialize_unleash()
    run()
