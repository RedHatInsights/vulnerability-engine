#!/usr/bin/env python3
"""
Periodic account-CVE systems affected cache maintenance
"""

from psycopg2.extras import execute_values

from common.bounded_executor import BoundedExecutor
from common.config import Config
from common.database_handler import DatabasePool, DatabasePoolConnection
from common.logging import get_logger, init_logging
from common.utils import validate_cve_cache_keepalive
from taskomatic.jobs.common import get_conn

LOGGER = get_logger(__name__)

CFG = Config()

CACHE_WORKERS = 4


def _materialize_account_cache(account_id, account_name, current_cache):
    LOGGER.debug("Materializing cache for account '%s' started.", account_name)
    with DatabasePoolConnection() as conn:
        with conn.cursor() as cur:
            cur.execute("""SELECT sv.cve_id,
                                  COUNT(*) AS systems_affected,
                                  SUM(CASE WHEN sv.status_id != cad.status_id THEN 1 ELSE 0 END) AS systems_status_divergent
                           FROM system_vulnerabilities_active sv INNER JOIN
                                system_platform sp ON (sv.system_id = sp.id AND
                                                       sp.rh_account_id = %s AND
                                                       sp.opt_out = false AND
                                                       sp.stale = false AND
                                                       sp.when_deleted IS NULL AND
                                                       sp.host_type != 'edge') INNER JOIN
                                inventory.hosts ih ON sp.inventory_id = ih.id LEFT JOIN
                                cve_account_data cad ON (sv.cve_id = cad.cve_id AND
                                                         cad.rh_account_id = %s)
                           WHERE sv.rh_account_id = %s AND
                                 (sv.mitigation_reason IS NULL OR sv.rule_id IN (SELECT id FROM insights_rule WHERE active = false AND NOT rule_only)) AND
                                 (sv.when_mitigated IS NULL OR sv.rule_id IN (SELECT id FROM insights_rule WHERE active = true AND NOT rule_only))
                           GROUP BY sv.cve_id""",
                        (account_id, account_id, account_id,))

            to_insert = []
            to_update = []
            for cve_id, systems_affected, systems_status_divergent in cur.fetchall():
                cve_cache = current_cache.get(account_id, {}).get(cve_id)
                if not cve_cache:
                    to_insert.append((account_id, cve_id, systems_affected, systems_status_divergent))
                else:
                    if cve_cache[0] != systems_affected or cve_cache[1] != systems_status_divergent:
                        to_update.append((account_id, cve_id, systems_affected, systems_status_divergent))
                    current_cache[account_id].pop(cve_id)
            to_delete = list(current_cache.get(account_id, {}))

            LOGGER.debug("Account '%s' - to_insert: %s", account_name, len(to_insert))
            if to_insert:
                execute_values(cur, """INSERT INTO cve_account_cache (rh_account_id, cve_id, systems_affected, systems_status_divergent)
                                       VALUES %s""",
                               to_insert, page_size=len(to_insert))

            LOGGER.debug("Account '%s' - to_update: %s", account_name, len(to_update))
            if to_update:
                execute_values(cur, """UPDATE cve_account_cache AS cac
                                       SET systems_affected = v.systems_affected,
                                           systems_status_divergent = v.systems_status_divergent
                                       FROM (VALUES %s) AS v(rh_account_id, cve_id, systems_affected, systems_status_divergent)
                                       WHERE v.rh_account_id = cac.rh_account_id AND
                                             v.cve_id = cac.cve_id""",
                               to_update, page_size=len(to_update))

            LOGGER.debug("Account '%s' - to_delete: %s", account_name, len(to_delete))
            if to_delete:
                cur.execute("""DELETE FROM cve_account_cache WHERE rh_account_id = %s AND cve_id IN %s""", (account_id, tuple(to_delete)))

            cur.execute("""UPDATE rh_account SET cve_cache_from = now() WHERE id = %s""", (account_id,))
        conn.commit()
    LOGGER.info("Materializing cache for account '%s' finished.", account_name)


def run():
    """Application entrypoint"""
    LOGGER.info("Started cacheman job.")

    conn = get_conn()
    cur = conn.cursor()

    current_cache = {}
    cur.execute("""SELECT rh_account_id, cve_id, systems_affected, systems_status_divergent
                   FROM cve_account_cache""")
    for rh_account_id, cve_id, systems_affected, systems_status_divergent in cur.fetchall():
        current_cache.setdefault(rh_account_id, {})[cve_id] = (systems_affected, systems_status_divergent)

    cur.execute("""SELECT sp.rh_account_id, a.name, a.cve_cache_from,
                          GREATEST(MAX(sp.last_evaluation), MAX(sp.advisor_evaluated), MAX(sp.when_deleted),
                                   MAX(a.last_status_change)) AS last_system_change,
                          a.cve_cache_keepalive,
                          COUNT(*) AS total_systems
                   FROM system_platform sp INNER JOIN
                        rh_account a on sp.rh_account_id = a.id
                   GROUP BY sp.rh_account_id, a.name, a.cve_cache_from, a.cve_cache_keepalive
                   HAVING COUNT(*) >= %s""", (CFG.cache_minimal_account_systems,))
    accounts = [(account_id, account_name, cve_cache_from, last_system_change, cve_cache_keepalive)
                for account_id, account_name, cve_cache_from, last_system_change, cve_cache_keepalive, _ in cur.fetchall()
                if validate_cve_cache_keepalive(cve_cache_keepalive, 2)]
    LOGGER.info("Accounts with enabled cache: %s", len(accounts))
    accounts_to_refresh = [account for account in accounts if account[3] and (not account[2] or account[3] > account[2])]
    LOGGER.info("Accounts requiring cache refresh: %s", len(accounts_to_refresh))

    # Process accounts in parallel
    with DatabasePool(CACHE_WORKERS):
        executor = BoundedExecutor(CACHE_WORKERS, max_workers=CACHE_WORKERS)
        futures = []
        for account_id, account_name, _, _, _ in accounts_to_refresh:
            futures.append(executor.submit(_materialize_account_cache, account_id, account_name, current_cache))
        for future in futures:
            future.result()
        executor.shutdown()
    # Pop out cached accounts after all workers are done
    for account_id, _, _, _, _ in accounts:
        current_cache.pop(account_id, None)

    LOGGER.info("Accounts to disable cache: %s", len(current_cache))
    for account_id in current_cache:
        cur.execute("""DELETE FROM cve_account_cache WHERE rh_account_id = %s""", (account_id,))
        cur.execute("""UPDATE rh_account SET cve_cache_from = NULL WHERE id = %s""", (account_id,))
        conn.commit()

    cur.close()
    conn.close()
    LOGGER.info("Finished cacheman job.")


if __name__ == "__main__":
    init_logging()
    run()
