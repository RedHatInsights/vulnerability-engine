#!/usr/bin/env python3
"""
Periodic check whether cached counts are OK, if not and SLACK_WEBHOOK is given, sends message to slack
"""

import os
import requests

import psycopg2

from common.logging import get_logger, init_logging

DB_NAME = os.getenv('POSTGRESQL_DATABASE')
DB_USER = os.getenv('POSTGRESQL_USER')
DB_PASS = os.getenv('POSTGRESQL_PASSWORD')
DB_HOST = os.getenv('POSTGRESQL_HOST')
DB_PORT = int(os.getenv('POSTGRESQL_PORT', '5432'))
SLACK_WEBHOOK = os.getenv('SLACK_WEBHOOK')
VULNERABILITY_ENV = os.getenv('VULNERABILITY_ENV', 'dev')

LOGGER = get_logger(__name__)


def check_account(cur, account_id, account_name):
    """Checks cachedcounts for given account"""
    LOGGER.debug('Checking account %s', account_name)

    passed = True
    cur.execute("""SELECT sv.cve_id, cm.cve, count(*) from system_vulnerabilities sv
                   INNER JOIN cve_metadata cm on sv.cve_id = cm.id
                   LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                   WHERE sv.system_id IN
                   (SELECT id FROM system_platform WHERE rh_account_id = %(account_id)s AND when_deleted is NULL AND opt_out = 'F' and stale = 'F')
                   AND (sv.when_mitigated IS NULL OR ir.active = 'T')
                   GROUP by sv.cve_id, cm.cve""",
                {'account_id': account_id})
    real_cve_counts = cur.fetchall()

    cur.execute("""SELECT cad.cve_id, cad.systems_affected FROM cve_account_data cad
                   WHERE cad.rh_account_id = %(account_id)s""", {'account_id': account_id})
    cached_cve_counts = dict(cur.fetchall())

    for cve_id, cve_name, real_count in real_cve_counts:
        cached_count = cached_cve_counts.get(cve_id, 0)
        if real_count != cached_count:
            LOGGER.error('Counts does not match for %s in org %s: %s (cached) vs. %s (real)', cve_name, account_name, cached_count, real_count)
            passed = False

    cur.execute("""SELECT id, inventory_id, cve_count_cache FROM system_platform WHERE rh_account_id = %(account_id)s AND when_deleted is NULL
                   AND opt_out = 'F' AND stale = 'F'""", {'account_id': account_id})
    systems = cur.fetchall()

    for system_id, inventory_id, cached_count in systems:
        cur.execute("""SELECT count(*) FROM system_vulnerabilities sv
                       LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                       WHERE sv.system_id = %(system_id)s AND (sv.when_mitigated IS NULL OR ir.active = 'T')""", {'system_id': system_id})
        real_count = cur.fetchone()[0]
        if cached_count != real_count:
            LOGGER.error('Counts does not match for system %s in org %s: %s (cached) vs. %s (real)', inventory_id, account_name, cached_count, real_count)
            passed = False

    LOGGER.debug('Account {} OK'.format(account_name) if passed else 'Account {} NOT OK'.format(account_name))
    return passed


def run():
    """Application entrypoint"""
    LOGGER.info('Started cache_check job')
    conn = psycopg2.connect(dbname=DB_NAME, user=DB_USER, password=DB_PASS, host=DB_HOST, port=DB_PORT)
    cur = conn.cursor()

    cur.execute("""SELECT id, name from rh_account""")
    accounts = cur.fetchall()

    passed = True
    for row in accounts:
        passed = passed and check_account(cur, row[0], row[1])

    if not passed:
        LOGGER.error('Cached counts check did NOT pass')  # I see what you did there Gandalf
        if SLACK_WEBHOOK:
            requests.post(SLACK_WEBHOOK, json={'text': '[{}] Mismatch between cached and real counts detected'.format(VULNERABILITY_ENV)},
                          headers={'Content-type': 'application/json'})

    cur.close()
    conn.close()
    LOGGER.info('Finished cache_check job')


if __name__ == '__main__':
    init_logging()
    run()
