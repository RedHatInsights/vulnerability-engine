#!/usr/bin/env python3
"""
Periodic check whether cached counts are OK, if not and SLACK_WEBHOOK is given, sends message to slack
"""

import argparse
import os

import psycopg2
import requests

from common.logging import get_logger, init_logging

DB_NAME = os.getenv('POSTGRESQL_DATABASE')
DB_USER = os.getenv('POSTGRESQL_USER')
DB_PASS = os.getenv('POSTGRESQL_PASSWORD')
DB_HOST = os.getenv('POSTGRESQL_HOST')
DB_PORT = int(os.getenv('POSTGRESQL_PORT', '5432'))
SLACK_WEBHOOK = os.getenv('SLACK_WEBHOOK')
VULNERABILITY_ENV = os.getenv('VULNERABILITY_ENV', 'dev')

LOGGER = get_logger(__name__)


def check_account(conn, cur, account_id, account_name, options):
    """Checks cachedcounts for given account"""
    LOGGER.debug('Checking account %s', account_name)

    passed = True
    cur.execute("""SELECT cm.cve, count(*) as real, cad.systems_affected from system_vulnerabilities sv
                   INNER JOIN cve_metadata cm on sv.cve_id = cm.id
                   LEFT OUTER JOIN cve_account_data cad on sv.cve_id = cad.cve_id
                   LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                   WHERE sv.system_id IN
                   (SELECT id FROM system_platform WHERE rh_account_id = %(account_id)s AND when_deleted is NULL AND opt_out = 'F' and stale = 'F')
                   AND cad.rh_account_id = %(account_id)s
                   AND (sv.mitigation_reason IS NULL OR ir.active = 'F')
                   AND (sv.when_mitigated IS NULL OR ir.active = 'T')
                   GROUP by cm.cve, cad.systems_affected""",
                {'account_id': account_id})
    cve_counts = cur.fetchall()

    for cve_name, real_count, cached_count in cve_counts:
        if cached_count is None:
            cached_count = 0
        if real_count != cached_count:
            if options.fix:
                cur.execute("SELECT refresh_cve_account_cached_counts(%s, %s)", (cve_name, account_name,))
                conn.commit()
                LOGGER.info('[FIXED] Counts does not match for %s in org %s: %s (cached) vs. %s (real)', cve_name, account_name, cached_count, real_count)
            else:
                LOGGER.error('Counts does not match for %s in org %s: %s (cached) vs. %s (real)', cve_name, account_name, cached_count, real_count)
                passed = False

    cur.execute("""SELECT id, inventory_id, cve_count_cache FROM system_platform WHERE rh_account_id = %(account_id)s AND when_deleted is NULL
                   AND opt_out = 'F' AND stale = 'F'""", {'account_id': account_id})
    systems = cur.fetchall()

    for system_id, inventory_id, cached_count in systems:
        cur.execute("""SELECT count(*) FROM system_vulnerabilities sv
                       LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                       WHERE sv.system_id = %(system_id)s
                       AND (sv.mitigation_reason IS NULL OR ir.active = 'F')
                       AND (sv.when_mitigated IS NULL OR ir.active = 'T')""",
                    {'system_id': system_id})
        real_count = cur.fetchone()[0]
        if cached_count != real_count:
            if options.fix:
                cur.execute("SELECT refresh_system_cached_counts(%s)", (inventory_id,))
                conn.commit()
                LOGGER.info('[FIXED] Counts does not match for system %s in org %s: %s (cached) vs. %s (real)',
                            inventory_id, account_name, cached_count, real_count)
            else:
                LOGGER.error('Counts does not match for system %s in org %s: %s (cached) vs. %s (real)', inventory_id, account_name, cached_count, real_count)
                passed = False

    LOGGER.debug('Account {} OK'.format(account_name) if passed else 'Account {} NOT OK'.format(account_name))
    return passed


def run():
    """Application entrypoint"""
    LOGGER.info('Started cache_check job')
    parser = argparse.ArgumentParser()
    parser.add_argument("--fix", action="store_true", help="fix found inconsistencies")
    options = parser.parse_args()

    conn = psycopg2.connect(dbname=DB_NAME, user=DB_USER, password=DB_PASS, host=DB_HOST, port=DB_PORT)
    cur = conn.cursor()

    cur.execute("""SELECT id, name FROM rh_account ORDER BY name""")
    accounts = cur.fetchall()

    passed = True
    for row in accounts:
        passed = passed and check_account(conn, cur, row[0], row[1], options)

    if not passed:
        LOGGER.error('Cached counts check did NOT pass')  # I see what you did there Gandalf
        if SLACK_WEBHOOK:
            requests.post(SLACK_WEBHOOK, json={'text': '[{}] Mismatch between cached and real counts detected'.format(VULNERABILITY_ENV)},
                          headers={'Content-type': 'application/json'})

    cur.close()
    conn.close()
    LOGGER.info('Finished cache_check job')


if __name__ == '__main__':
    init_logging()
    run()
