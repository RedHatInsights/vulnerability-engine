"""Platform mock upload module."""
import base64
import datetime
import hashlib
import json
import os
import signal
import uuid

from insights.core import archives, dr
from insights.core.archives import InvalidContentType
from insights.core.context import HostArchiveContext
from insights.core.hydration import create_context
from insights.specs import Specs
from insights.parsers.dnf_modules import DnfModules
from insights.parsers.installed_rpms import Installed
from insights.parsers.yum_repos_d import YumReposD
from tornado.ioloop import IOLoop
from tornado.web import Application, RequestHandler

from common.logging import init_logging, get_logger
from common import mqueue

LOGGER = get_logger(__name__)
STORAGE_PATH = "/tmp/storage"


class UploadHandler(RequestHandler):
    """Upload Handler."""

    def data_received(self, chunk):
        pass

    @staticmethod
    def _get_system_profile(archive_path):
        profile = {}
        default_packages = (
            "insights.specs.default",
            "insights.specs.insights_archive",
            "insights.combiners",
            "insights.parsers"
        )
        for pkg in default_packages:
            dr.load_components(pkg)
        broker = dr.Broker()
        try:
            with archives.extract(archive_path) as ex:
                ctx = create_context(ex.tmp_dir, HostArchiveContext)
                broker[ctx.__class__] = ctx
                broker = dr.run(components=[Specs.machine_id, Installed, DnfModules, YumReposD],
                                broker=broker)
                if Specs.machine_id in broker:
                    profile["id"] = broker[Specs.machine_id].content[0].strip()
                profile["installed_packages"] = []
                if Installed in broker:
                    pkglist = broker[Installed]
                    for pkg_name in pkglist.packages:
                        pkg = pkglist.get_max(pkg_name)
                        profile["installed_packages"].append(pkg.nevra)

                profile["yum_repos"] = []
                if YumReposD in broker:
                    repolist = broker[YumReposD]
                    for repo_file in repolist:
                        if repo_file.file_name == 'redhat.repo':
                            for repo in repo_file:
                                if repo_file[repo].get('enabled', '1').lower() in ('1', 'true', 'enabled', 'yes', 'on'):
                                    profile["yum_repos"].append(repo)
                            break

                profile["dnf_modules"] = []
                if DnfModules in broker:
                    for module in broker[DnfModules]:
                        for module_name in module.sections():
                            profile["dnf_modules"].append({'name': module_name,
                                                           'stream': module.get(module_name, 'stream')})
        except InvalidContentType:
            LOGGER.error("Unable to parse archive.")
        return profile

    def _get_rh_account(self):
        if "x-rh-identity" not in self.request.headers:
            return "0"
        encoded_value = self.request.headers["x-rh-identity"]
        decoded_value = base64.b64decode(encoded_value).decode("utf-8")
        identity = json.loads(decoded_value)
        return identity.get("identity", {}).get("account_number", "0")

    def _get_upload_multiplier(self):
        if "x-upload-multiplier" not in self.request.headers:
            return 1
        multiplier = self.request.headers["x-upload-multiplier"]
        return int(multiplier) if multiplier.isdigit() else 1

    def post(self):
        """Answer POST request.
           curl -X POST -F "file=@./file.tar.gz" http://localhost:8100/api/v1/upload
           curl -X POST -F "file=@./file.tar.gz" -H "x-upload-multiplier: 10" http://localhost:8100/api/v1/upload
        """
        if self.request.files and "file" in self.request.files:
            sha1 = hashlib.sha1(self.request.files["file"][0]["body"]).hexdigest()
            file_name = "%s.tar.gz" % sha1
            file_path = os.path.join(STORAGE_PATH, file_name)
            if not os.path.exists(file_path):
                with open(file_path, "wb") as open_file:
                    open_file.write(self.request.files["file"][0]["body"])
            if sha1 in self.application.archive_to_profile_cache:
                profile = self.application.archive_to_profile_cache[sha1]
            else:
                profile = self._get_system_profile(file_path)
                self.application.archive_to_profile_cache[sha1] = profile
                self.application.inventory_id_to_profile_cache[profile.get("id", None)] = profile
            download_url = "http://platform_mock:8000/api/v1/download/%s" % file_name
            rh_account = self._get_rh_account()
            timestamp = datetime.datetime.utcnow().isoformat()
            upload_message = {"host": {"id": profile.get("id", None), "account": rh_account,
                                       "display_name": sha1 + ".example.com",
                                       "system_profile": {
                                           "installed_packages": profile["installed_packages"],
                                           "yum_repos": [{"id": r, "name": r, "enabled": True} for r in profile["yum_repos"]],
                                           "dnf_modules": profile["dnf_modules"]}
                                       },
                              "platform_metadata": {"request_id": str(uuid.uuid1()), "url": download_url,
                                                    "b64_identity": self.request.headers.get("x-rh-identity", "")},
                              "timestamp": timestamp,
                              "type": "created"
                              }
            for _ in range(self._get_upload_multiplier()):
                self.application.upload_queue.send(upload_message)
            LOGGER.info("New upload: %s", upload_message)
        else:
            self.set_status(400)
        self.finish()


class DownloadHandler(RequestHandler):
    """Download Handler."""

    def data_received(self, chunk):
        pass

    def get(self, path):
        """Answer GET request."""
        file_path = os.path.join(STORAGE_PATH, path)
        if not os.path.isfile(file_path):
            self.set_status(404)
        else:
            self.set_header("Content-Type", "application/octet-stream")
            with open(file_path, "rb") as open_file:
                self.write(open_file.read())
        self.finish()


class DeleteHandler(RequestHandler):
    """Delete Handler."""

    def data_received(self, chunk):
        pass

    def delete(self, inventory_id):
        """Answer DELETE request."""
        delete_message = {"type": "delete", "id": inventory_id}
        self.application.events_queue.send(delete_message)
        LOGGER.info("Delete: %s", delete_message)
        self.finish()


class RbacHandler(RequestHandler):
    """RBAC mock"""

    def data_received(self, chunk):
        pass

    def get(self):
        """Answer GET request"""
        self.write(json.dumps({'meta': {'count': 1, 'limit': 10, 'offset': 0},
                               'links': {'first': '/api/rbac/v1/access/?application=vulnerability&limit=1000&offset=0',
                                         'next': None, 'previous': None, 'last': '/api/rbac/v1/access/?application=vulnerability&limit=1000&offset=0'},
                               'data': [{'permission': 'vulnerability:*:*', 'resourceDefinitions': []}]}))


class InventoryHandler(RequestHandler):
    """Inventory mock"""

    def data_received(self, chunk):
        pass

    def get(self, inventory_id):
        """Answer GET request"""
        if inventory_id not in self.application.inventory_id_to_profile_cache:
            self.set_status(404)
        else:
            prof = self.application.inventory_id_to_profile_cache[inventory_id]
            self.set_header("Content-Type", "application/json")
            self.write(
                json.dumps({"results": [{
                    "id": inventory_id,
                    "system_profile": {
                        "installed_packages": prof["installed_packages"],
                        "yum_repos": [{"id": r, "name": r, "enabled": True} for r in prof["yum_repos"]],
                        "dnf_modules": prof["dnf_modules"]}
                }]}))
        self.finish()


class ServerApplication(Application):
    """Platform mock application."""

    def __init__(self):
        handlers = [
            (r"/api/v1/upload/?", UploadHandler),
            (r"/api/v1/download/(.+)", DownloadHandler),
            (r"/api/v1/delete/(.+)", DeleteHandler),
            (r"/api/rbac/v1/access.+", RbacHandler),
            (r"/api/inventory/v1/hosts/(.+)/system_profile", InventoryHandler),
        ]
        Application.__init__(self, handlers)
        self.instance = IOLoop.instance()
        self.upload_queue = mqueue.MQWriter(mqueue.UPLOAD_TOPIC, bootstrap_servers="localhost:9092")
        self.events_queue = mqueue.MQWriter(mqueue.EVENTS_TOPIC, bootstrap_servers="localhost:9092")
        self.archive_to_profile_cache = {}
        self.inventory_id_to_profile_cache = {}

    def start(self):
        """Start platform mock server."""
        self.instance.start()

    async def stop(self):
        """Stop platform mock server."""
        await self.upload_queue.stop()
        await self.events_queue.stop()
        self.instance.stop()


def main():
    """Main platform mock entrypoint."""
    init_logging()
    if not os.path.exists(STORAGE_PATH):
        os.makedirs(STORAGE_PATH)
    LOGGER.info("Starting platform mock.")
    app = ServerApplication()
    app.listen(8000)

    def terminate(*_):
        """Trigger shutdown."""
        LOGGER.info("Signal received, stopping application.")
        IOLoop.instance().add_callback_from_signal(app.stop)

    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for sig in signals:
        signal.signal(sig, terminate)

    app.start()
    LOGGER.info("Shutting down.")


if __name__ == '__main__':
    main()
