#!/usr/bin/env python3
'''Kafka traffic generator'''

import argparse
import base64
import json
import random
import sys
import uuid

from data.misc import CPU_FLAGS, ENABLED_SERVICES, INSTALLED_SERVICES, KERNEL_MODULES, RUNNING_PROCESSES
from data.packages import LEN_PACKAGES, PACKAGES
from data.rules import RULES
from data.yum_repos import AVAILABLE_REPOS, ENABLED_REPOS, LEN_AVAILABLE_REPOS



class Generator:
    '''Base message generator class'''

    @staticmethod
    def _generate_host_dict(inventory_id: str, account_id: str) -> dict:
        return {
            'id': inventory_id,
            'display_name': inventory_id,
            'ansible_host': None,
            'account': account_id,
            'insights_id': inventory_id,
            'rhel_machine_id': None,
            'subscription_manager_id': None,
            'satellite_id': None,
            'fqdn': None,
            'bios_uuid': None,
            'ip_addresses': None,
            'mac_addresses': [
                'fa:16:3e:72:a6:99',
                '00:00:00:00:00:00'
            ],
            'external_id': None,
            'created': '2020-03-20T11:04:57.434527+00:00',
            'updated': '2020-04-14T10:11:33.231512+00:00',
            'stale_timestamp': '3020-04-15T12:11:33.168053+00:00',
            'stale_warning_timestamp': '3020-04-22T12:11:33.168053+00:00',
            'culled_timestamp': '3020-04-29T12:11:33.168053+00:00',
            'tags': [],
            'system_profile': {
                'os_release': '7.5',
                'satellite_managed': False,
                'os_kernel_version': '3.10.0'
            },
            'reporter': 'puptoo'
        }

    @staticmethod
    def _generate_identity(account_id: str) -> str:
        return base64.b64encode(json.dumps({
            'identity': {
                'account_number': account_id,
                'type': 'User',
                'user': {
                    'username': 'jdoe@acme.com',
                    'email': 'jdoe@acme.com',
                    'first_name': 'john',
                    'last_name': 'doe',
                    'is_active': True,
                    'is_org_admin': True,
                    'is_internal': False,
                    'locale': 'en_US'
                },
                'internal': {
                    'org_id': 3340851,
                    'auth_type': 'basic-auth',
                    'auth_time': 6300
                }
            },
            'entitlements': {
                'insights': {
                    'is_entitled': True
                }
            }
        }).encode('utf-8')).decode('utf-8')

    @staticmethod
    def _generate_platform_metadata_dict(account_id: str) -> dict:
        return {
            'account': account_id,
            'b64_identity': Generator._generate_identity(account_id),
            'category': 'something',
            'elapsed_time': 1586859092.4174569,
            'extras': {},
            'host': {},
            'id': None,
            'metadata': {
                'reporter': '',
                'stale_timestamp': '0001-01-01T00:00:00Z'
            },
            'payload_id': None,
            'principal': '5894300',
            'request_id': '018c78be10954bf689974590c19da741',
            'satellite_managed': None,
            'service': 'advisor',
            'size': 195324,
            'timestamp': '2020-04-14T10:09:34.578526029Z',
            'url': r'https://XXXXXXXXXXXXX.s3.amazonaws.com/018c78be10954bf689974590c19da741?X',
            'validation': None,
            'test': None
        }


class AdvisorGenerator(Generator):
    '''Generator of messages coming from advisor engine'''

    @staticmethod
    def generate_msg(inventory_id: str, account_id: str):
        '''Generates message with given params'''
        passed, reports = AdvisorGenerator._generate_hits()
        return json.dumps({
            'input': {
                'host': Generator._generate_host_dict(inventory_id, account_id),
                'platform_metadata': Generator._generate_platform_metadata_dict(account_id),
                'timestamp': '2020-04-14T10:11:33.255024+00:00',
                'type': 'updated'
            },
            'results': {
                'fingerprints': [],
                'pass': passed,
                'reports': reports,
                'system': None,
            }
        })

    @staticmethod
    def _generate_hits():
        passed = []
        reports = []
        for rule in RULES:
            key = random.choice(list(RULES[rule].keys()))
            if key == 'pass':
                passed.append(RULES[rule][key])
            else:
                reports.append(RULES[rule][key])
        return passed, reports


class UploadGenerator(Generator):
    '''Generator of upload messages'''


    def __init__(self, pkg_len_func):
        self.pkg_len_func = pkg_len_func

    def generate_msg(self, inventory_id: str, account_id: str):
        '''Generates message with given params'''
        return json.dumps({
            'host': self._generate_extended_host_dict(inventory_id, account_id),
            'platform_metadata': Generator._generate_platform_metadata_dict(account_id),
            'timestamp': '2020-04-21T04:36:13.694341+00:00',
            'type': 'updated'
        })

    def _generate_extended_host_dict(self, inventory_id: str, account_id: str):
        host_dict = Generator._generate_host_dict(inventory_id, account_id)
        host_dict['system_profile'].update({
            'captured_date': '2019-11-19T22:13:22+00:00',
            'bios_vendor': 'SeaBIOS',
            'infrastructure_type': 'virtual',
            'bios_release_date': '04/01/2014',
            'arch': 'x86_64',
            'number_of_cpus': 1,
            'insights_egg_version': '3.0.133-1',
            'running_processes': RUNNING_PROCESSES,
            'enabled_services': ENABLED_SERVICES,
            'insights_client_version': '3.0.9-1.el7',
            'cpu_flags': CPU_FLAGS,
            'installed_products': [
                {
                    'id': '230'
                }
            ],
            'network_interfaces': [
                {
                    'ipv6_addresses': [
                        '::1'
                    ],
                    'state': 'UNKNOWN',
                    'ipv4_addresses': [
                        '127.0.0.1'
                    ],
                    'type': 'loopback',
                    'mac_address': '00:00:00:00:00:00',
                    'name': 'lo',
                    'mtu': 65536
                },
                {
                    'ipv6_addresses': [
                        'fe80::f816:3eff:fe72:a699'
                    ],
                    'state': 'UP',
                    'ipv4_addresses': [
                        '10.0.149.122'
                    ],
                    'type': 'ether',
                    'mac_address': 'fa:16:3e:72:a6:99',
                    'name': 'eth0',
                    'mtu': 1500
                }
            ],
            'kernel_modules': KERNEL_MODULES,
            'infrastructure_vendor': 'kvm',
            'number_of_sockets': 1,
            'system_memory_bytes': 1927180288,
            'yum_repos': ENABLED_REPOS + random.sample(AVAILABLE_REPOS, random.randrange(0, LEN_AVAILABLE_REPOS)),
            'bios_version': '1.11.0-2.el7',
            'cores_per_socket': 1,
            'last_boot_time': '2019-11-19T21:47:22',
            'installed_packages': [random.choice(PACKAGES[pkg_name]) for pkg_name in random.sample(PACKAGES.keys(), self.pkg_len_func()())],
            'installed_services': INSTALLED_SERVICES
        })
        return host_dict


def main():
    '''main'''
    parser = argparse.ArgumentParser()
    parser.add_argument('-a', '--account', type=str, default='0', help='Account to be used, defaults to 0.')
    parser.add_argument('-c', '--count', type=int, help='Number of messages to be generated, defaults to 1.')
    parser.add_argument('-r', '--rules', action='store_true', help='Generate advisor engine message instead.')
    parser.add_argument('-u', '--use-ids', type=str, help='Use inventory IDs from a file, when combined with -c option generates lower number of both, '
                        'otherwise uses all IDs in file. Each line represents one inventory ID.')
    parser.add_argument('-w', '--write-ids', type=str, help='Write used inventory IDs into given file. Each line represents one inventory ID.')
    parser.add_argument('-m', '--min-pkgs', type=int, help='Minimum packages for a system message, starting from 0. Only applicable when -r is not present.')
    parser.add_argument('-n', '--max-pkgs', type=int, help='Maximum packages for a system message, '
                                                           'up to max packages in DB. Only applicable when -r is not present.')

    options = parser.parse_args()

    if not options.count and not options.use_ids:
        options.count = 1

    if options.use_ids:
        with open(options.use_ids, 'r') as read_file:
            ids_to_use = [line.strip() for line in read_file.readlines()]
        if options.count:
            options.count = min(options.count, len(ids_to_use))
        else:
            options.count = len(ids_to_use)

    options.min_pkgs = max(0, options.min_pkgs) if options.min_pkgs else 0
    options.max_pkgs = min(options.max_pkgs, LEN_PACKAGES) if options.max_pkgs else LEN_PACKAGES
    if options.min_pkgs > options.max_pkgs:
        sys.stderr.write('min-pkgs has to be lower than max-pkgs')
        sys.exit(1)

    pkg_len_func = lambda: options.min_pkgs if options.min_pkgs == options.max_pkgs else lambda: random.randrange(options.min_pkgs, options.max_pkgs)

    gen = AdvisorGenerator if options.rules else UploadGenerator(pkg_len_func)
    inventory_ids = []
    for i in range(options.count):
        inventory_id = ids_to_use[i] if options.use_ids else str(uuid.uuid4())
        inventory_ids.append(inventory_id)
        print(gen.generate_msg(inventory_id, options.account))

    if options.write_ids:
        with open(options.write_ids, 'w') as write_file:
            write_file.write('\n'.join(inventory_ids))


if __name__ == '__main__':
    main()
