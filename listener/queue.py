"""
Listener Queue
"""
import asyncio

from asyncpg.pool import Pool

from common.mqueue import MQWriter
from common.logging import get_logger
from common.utils import send_msg_to_payload_tracker
from .common import InventoryMsgType, QueueItem, CFG, create_task_and_log
from .processor import ListenerItemProcessor

LOGGER = get_logger(__name__)


class ListenerQueue:
    """Listener async queue for message waiting"""

    def __init__(self, db_pool: Pool, payload_tracker: MQWriter, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self._queue = {}
        self.item_processor = ListenerItemProcessor(db_pool, payload_tracker)
        self.payload_tracker = payload_tracker
        self.loop = loop

    async def init(self):
        """Async constructor"""
        await self.item_processor.init()

    async def stop(self):
        """Stop queue"""
        await self.item_processor.stop()

    def push_inventory_msg(self, org_id: str, inventory_id: str, inventory_msg: dict, msg_type: InventoryMsgType):
        """"Push listener message to queue"""
        # on system delete attempt to delete all waiting messages from queue
        # and also execute it immediately
        if msg_type is InventoryMsgType.DELETE:
            del self._queue[(org_id, inventory_id)]

            item = QueueItem(inventory_msg, msg_type, None)
            self.loop.create_task(self.item_processor.process_item(item))
            return

        # otherwise push to waiting queue
        is_updated = False

        item = self._queue.get((org_id, inventory_id))
        if not item:
            item = QueueItem(inventory_msg, msg_type, None)
        else:
            is_updated = True
            item.inventory_msg = inventory_msg
            item.inventory_msg_type = msg_type

        self._queue[(org_id, inventory_id)] = item
        LOGGER.debug("Pushing listener msg to queue for system: %s, org_id: %s", inventory_id, org_id)

        if item.advisor_msg and msg_type is not InventoryMsgType.UNKNOWN:
            LOGGER.debug("Obtained both messages for system: %s, account: %s, releasing lock", inventory_id, org_id)
            item.second_msg_event.set()
        elif not is_updated:
            send_msg_to_payload_tracker(self.payload_tracker, inventory_msg, "received")
            create_task_and_log(self._start_item_processing(org_id, inventory_id), LOGGER, self.loop)

    def push_advisor_msg(self, org_id: str, inventory_id: str, advisor_msg: dict):
        """Push advisor message to queue"""
        is_updated = False
        item = self._queue.get((org_id, inventory_id))
        if not item:
            item = QueueItem(None, InventoryMsgType.UNKNOWN, advisor_msg)
        else:
            is_updated = True
            item.advisor_msg = advisor_msg

        self._queue[(org_id, inventory_id)] = item
        LOGGER.debug("Pushing advisor msg to queue for system: %s, org_id: %s", inventory_id, org_id)

        if item.inventory_msg and item.inventory_msg_type is not InventoryMsgType.UNKNOWN:
            LOGGER.debug("Obtained both messages for system: %s, account: %s, releasing lock", inventory_id, org_id)
            item.second_msg_event.set()
        elif not is_updated:
            send_msg_to_payload_tracker(self.payload_tracker, advisor_msg["input"], "received")
            create_task_and_log(self._start_item_processing(org_id, inventory_id), LOGGER, self.loop)

    async def _start_item_processing(self, org_id: str, inventory_id: str):
        """Single queue item coroutine"""
        item = self._queue[(org_id, inventory_id)]
        LOGGER.debug("Starting waiting for %s msg for system: %s, account: %s", "inventory" if item.advisor_msg else "advisor",
                     inventory_id, org_id)

        try:
            await asyncio.wait_for(item.second_msg_event.wait(), CFG.listener_messages_timeout_sec)
        except asyncio.TimeoutError:
            LOGGER.debug("Timeouted waiting for message for system: %s, account: %s", inventory_id, org_id)
        del self._queue[(org_id, inventory_id)]
        create_task_and_log(self.item_processor.process_item(item), LOGGER, self.loop)
