"""
Listener main component
"""
import asyncio
import json
import signal

from aiokafka.structs import ConsumerRecord
from psycopg_pool import AsyncConnectionPool

from common.logging import init_logging, get_logger
from common.status_app import create_status_app, create_status_runner
from common.utils import (a_ensure_minimal_schema_version, validate_kafka_msg, send_msg_to_payload_tracker,
                          create_task_and_log)
from common.mqueue import MQReader, MQWriter
from common.database_handler import setup_async_db_pool
from .common import (CFG, PROMETHEUS_PORT, PROCESS_MESSAGES, SKIPPED_MESSAGES,
                     MESSAGE_PARSE_ERROR, InventoryMsgType, AdvisorMsg, InventoryMsg)
from .advisor_processor import AdvisorMsgProcessor
from .inventory_processor import InventoryMsgProcessor

LOGGER = get_logger(__name__)


class InvalidInventoryMsg(Exception):
    """Raised on invalid inventory message validation"""


class InvalidAdvisorMsg(Exception):
    """Raised on invalid advisor message validation"""


class InventoryMsgValidator:
    """Inventory kafka message validator"""

    _created_updated_msg_fields = {
        "host": ["id", "org_id", "system_profile", "display_name", "reporter"],
        "timestamp": [],
        "type": [],
    }

    _upload_msg_fields = {
        "platform_metadata": [],
    }

    _delete_msg_fields = {
        "id": [],
        "org_id": [],
        "type": [],
    }

    def __init__(self, payload_tracker: MQWriter):
        """Constructor"""
        self.payload_tracker = payload_tracker

    def _validate_created_updated(self, msg: dict):
        """Validates CREATED/UPDATED inventory kafka message"""
        if not validate_kafka_msg(msg, self._created_updated_msg_fields):
            SKIPPED_MESSAGES.inc()
            raise InvalidInventoryMsg("inventory created message does not contain expected fields")
        if msg.get("platform_metadata"):
            if not validate_kafka_msg(msg, self._upload_msg_fields):
                SKIPPED_MESSAGES.inc()
                raise InvalidInventoryMsg("inventory created message does not contain expected fields")

    def _validate_deleted(self, msg: dict):
        """Validates DELETE inventory kafka message"""
        if not validate_kafka_msg(msg, self._delete_msg_fields):
            SKIPPED_MESSAGES.inc()
            raise InvalidInventoryMsg("inventory deleted message does not contain expected fields")

    def validate_message(self, msg: dict) -> InventoryMsgType:
        """Validate inventory message, returns its type. Increments
           prometheus counters"""
        if msg.get("type") == "created":
            self._validate_created_updated(msg)
            return InventoryMsgType.CREATED
        if msg.get("type") == "updated":
            self._validate_created_updated(msg)
            return InventoryMsgType.UPDATED
        if msg.get("type") == "delete":
            self._validate_deleted(msg)
            return InventoryMsgType.DELETE
        raise InvalidInventoryMsg(f"obtained unknown inventory event type: {msg.get('type', 'missing event type')}")


class AdvisorMsgValidator:
    """Advisor message validator"""

    _required_msg_fields = {
        "input": [{"host": ["reporter", ("id", False)]}]
    }

    def __init__(self, payload_tracker):
        """Constructor"""
        self.payload_tracker = payload_tracker

    def validate_message(self, msg: dict):
        """Validates message and returns result, also increments prometheus counters"""
        if not validate_kafka_msg(msg, self._required_msg_fields):
            SKIPPED_MESSAGES.inc()
            raise InvalidAdvisorMsg("advisor message does not contain expected fields")


class Listener:
    """Main listener class"""

    def __init__(self, db_pool: AsyncConnectionPool, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self.consumer = MQReader([CFG.advisor_results_topic, CFG.events_topic])
        self.payload_tracker = MQWriter(CFG.payload_tracker_topic)

        self.inventory_msg_validator = InventoryMsgValidator(self.payload_tracker)
        self.advisor_msg_validator = AdvisorMsgValidator(self.payload_tracker)

        self.inventory_msg_processor = InventoryMsgProcessor(db_pool, self.payload_tracker, loop)
        self.advisor_msg_processor = AdvisorMsgProcessor(db_pool, self.payload_tracker, loop)

        self.max_messages_semaphore = asyncio.BoundedSemaphore(CFG.max_loaded_listener_msgs)
        self.loop = loop
        self.db_pool = db_pool

    async def init(self):
        """Async constructor"""
        await self.inventory_msg_processor.init()

    def _send_payload_tracker_error(self, msg: dict, reason: str):
        # since messages come separetely, inform separetly user about error in message
        send_msg_to_payload_tracker(self.payload_tracker, msg, "error", status_msg=reason)

    async def _consume_inventory_msg(self, msg: dict) -> InventoryMsgType:
        """Consumes inventory message"""
        try:
            msg_type = self.inventory_msg_validator.validate_message(msg)
        except InvalidInventoryMsg as exc:
            LOGGER.error("obtained invalid inventory msg: %s", exc)
            try:
                self._send_payload_tracker_error(msg, "obtained invalid inventory msg")
            except KeyError:
                pass
            return InventoryMsgType.UNKNOWN

        await self.inventory_msg_processor.process_msg(InventoryMsg(msg_type, msg))
        return msg_type

    async def consume_inventory_msg(self, msg: dict):
        """Consume inventory message, semaphore wrapper"""
        try:
            await self._consume_inventory_msg(msg)
        finally:
            self.max_messages_semaphore.release()

    async def _consume_advisor_msg(self, msg: dict):
        """Consumes advisor message"""
        try:
            self.advisor_msg_validator.validate_message(msg)
        except InvalidAdvisorMsg as exc:
            LOGGER.error("obtained invalid advisor msg: %s", exc)
            try:
                self._send_payload_tracker_error(msg["input"], "obtained invalid advisor msg")
            except KeyError:
                pass
            return

        await self.advisor_msg_processor.process_msg(AdvisorMsg(msg))

    async def consume_advisor_msg(self, msg: dict):
        """Consume advisor message, semaphore wrapper"""
        try:
            await self._consume_advisor_msg(msg)
        finally:
            self.max_messages_semaphore.release()

    def _consume_message(self, msg: ConsumerRecord):
        """Consumes single message from advisor or inventory"""
        try:
            msg_dict = json.loads(msg.value.decode("utf-8"))
        except json.decoder.JSONDecodeError as exc:
            MESSAGE_PARSE_ERROR.inc()
            LOGGER.exception("Unable to parse message: %s", exc)
            return

        if msg_dict.get("host") or msg_dict.get("type") == "delete":
            create_task_and_log(self.consume_inventory_msg(msg_dict), LOGGER, self.loop)
            PROCESS_MESSAGES.inc()
        elif msg_dict.get("input"):
            create_task_and_log(self.consume_advisor_msg(msg_dict), LOGGER, self.loop)
            PROCESS_MESSAGES.inc()
        else:
            LOGGER.exception("Unknown message obtained: %s", msg)
            SKIPPED_MESSAGES.inc()

    async def start_listening(self):
        """Listens for advisor/inventory messages and consumes them"""
        async for msg in self.consumer.client:
            await self.max_messages_semaphore.acquire()
            self._consume_message(msg)

    async def stop(self):
        """Stops whole listener process"""
        LOGGER.info("Stopping the service")

        await self.consumer.stop()
        await self.payload_tracker.stop()
        await self.inventory_msg_processor.stop()
        await self.advisor_msg_processor.stop()
        self.loop.stop()

    async def run(self):
        """Stars the listener service"""
        await self.consumer.start()
        await self.inventory_msg_processor.start()
        await self.advisor_msg_processor.start()
        await self.payload_tracker.start()

        async with self.db_pool:
            await self.init()
            await self.start_listening()
            await self.stop()


def main():
    """Main"""
    init_logging()
    loop = asyncio.get_event_loop()

    status_app = create_status_app(LOGGER)
    _, status_site = create_status_runner(status_app, int(PROMETHEUS_PORT), LOGGER, loop)
    loop.run_until_complete(status_site.start())

    loop.run_until_complete(a_ensure_minimal_schema_version())

    LOGGER.info("Starting listener service")
    db_pool = setup_async_db_pool(CFG)
    listener = Listener(db_pool, loop)

    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for sig in signals:
        loop.add_signal_handler(
            sig, lambda sig=sig: loop.create_task(listener.stop()))

    loop.create_task(listener.run())
    loop.run_forever()
    LOGGER.info("Stopped listener service")


if __name__ == "__main__":
    main()
