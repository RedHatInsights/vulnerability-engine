"""
Listener main component
"""
import asyncio
import json
import signal

from aiokafka.structs import ConsumerRecord
from psycopg_pool import AsyncConnectionPool

from common.logging import init_logging, get_logger
from common.status_app import create_status_app, create_status_runner
from common.utils import a_ensure_minimal_schema_version, validate_kafka_msg, send_msg_to_payload_tracker
from common.mqueue import MQReader, MQWriter
from common.identity import get_identity, is_entitled_insights
from common.database_handler import setup_async_db_pool
from .common import (CFG, PROMETHEUS_PORT, SKIPPED_MESSAGES, INVALID_IDENTITY, MISSING_INSIGHTS_ENTITLEMENT,
                     MESSAGE_PARSE_ERROR, InventoryMsgType, create_task_and_log)
from .queue import ListenerQueue

LOGGER = get_logger(__name__)


class InvalidInventoryMsg(Exception):
    """Raised on invalid inventory message validation"""


class InvalidAdvisorMsg(Exception):
    """Raised on invalid advisor message validation"""


class InventoryMsgValidator:
    """Inventory kafka message validator"""

    _created_updated_msg_fields = {
        "host": ["id", "org_id", "system_profile", "display_name", ("insights_id", False)],
        "timestamp": [],
        "type": [],
    }

    _upload_msg_fields = {
        "platform_metadata": ["b64_identity", "url"],
    }

    _delete_msg_fields = {
        "id": [],
        "org_id": [],
        "type": [],
        "insights_id": [],
    }

    def __init__(self, payload_tracker: MQWriter):
        """Constructor"""
        self.payload_tracker = payload_tracker

    def _validate_created_updated(self, msg: dict):
        """Validates CREATED/UPDATED inventory kafka message"""
        if not validate_kafka_msg(msg, self._created_updated_msg_fields):
            SKIPPED_MESSAGES.inc()
            raise InvalidInventoryMsg("inventory created message does not contain expected fields")
        if msg.get("platform_metadata"):
            if not validate_kafka_msg(msg, self._upload_msg_fields):
                SKIPPED_MESSAGES.inc()
                raise InvalidInventoryMsg("inventory created message does not contain expected fields")
            identity = get_identity(msg["platform_metadata"]["b64_identity"])
            if identity is None:
                INVALID_IDENTITY.inc()
                raise InvalidInventoryMsg("obtained invalid identity inside inventory created message")
            if not is_entitled_insights(identity, allow_missing_section=True):
                MISSING_INSIGHTS_ENTITLEMENT.inc()
                raise InvalidInventoryMsg("missing insights entitlement inside obtained inventory created message")

    def _validate_deleted(self, msg: dict):
        """Validates DELETE inventory kafka message"""
        if not validate_kafka_msg(msg, self._delete_msg_fields):
            SKIPPED_MESSAGES.inc()
            raise InvalidInventoryMsg("inventory deleted message does not contain expected fields")

    def validate_message(self, msg: dict) -> InventoryMsgType:
        """Validate inventory message, returns its type. Increments
           prometheus counters"""
        if msg.get("type") == "created":
            self._validate_created_updated(msg)
            return InventoryMsgType.CREATED
        if msg.get("type") == "updated":
            self._validate_created_updated(msg)
            return InventoryMsgType.UPDATED
        if msg.get("type") == "delete":
            self._validate_deleted(msg)
            return InventoryMsgType.DELETE
        raise InvalidInventoryMsg(f"obtained unknown inventory event type: {msg.get('type', 'missing event type')}")


class AdvisorMsgValidator:
    """Advisor message validator"""

    _required_msg_fields = {
        "input": [{"host": [("insights_id", False)]}]
    }

    def __init__(self, payload_tracker):
        """Constructor"""
        self.payload_tracker = payload_tracker

    def validate_message(self, msg: dict):
        """Validates message and returns result, also increments prometheus counters"""
        if not validate_kafka_msg(msg, self._required_msg_fields):
            SKIPPED_MESSAGES.inc()
            raise InvalidAdvisorMsg("advisor message does not contain expected fields")
        identity = get_identity(msg["input"]["platform_metadata"]["b64_identity"])
        if identity is None:
            INVALID_IDENTITY.inc()
            raise InvalidAdvisorMsg("obtained invalid identity inside advisor created message")
        if not is_entitled_insights(identity, allow_missing_section=True):
            MISSING_INSIGHTS_ENTITLEMENT.inc()
            raise InvalidAdvisorMsg("missing insights entitlement inside obtained advisor created message")


class Listener:
    """Main listener class"""

    def __init__(self, db_pool: AsyncConnectionPool, loop: asyncio.BaseEventLoop):
        """Constructor"""
        self.consumer = MQReader(CFG.listener_ingress_topic)
        self.payload_tracker = MQWriter(CFG.payload_tracker_topic)

        self.inventory_msg_validator = InventoryMsgValidator(self.payload_tracker)
        self.advisor_msg_validator = AdvisorMsgValidator(self.payload_tracker)

        self.loop = loop
        self.db_pool = db_pool

        self.queue = ListenerQueue(db_pool, self.payload_tracker, loop)
        self._queue_task = None

    async def init(self):
        """Async constructor"""
        await self.queue.init()

    def _send_payload_tracker_error(self, msg: dict, reason: str):
        # since messages come separetely, inform separetly user about error in message
        send_msg_to_payload_tracker(self.payload_tracker, msg, "received")
        send_msg_to_payload_tracker(self.payload_tracker, msg, "error", status_msg=reason)

    def _consume_inventory_msg(self, msg: dict) -> InventoryMsgType:
        """Consumes inventory message"""
        try:
            msg_type = self.inventory_msg_validator.validate_message(msg)
        except InvalidInventoryMsg as exc:
            LOGGER.error("obtained invalid inventory msg: %s, msg: %s", exc, msg)
            try:
                self._send_payload_tracker_error(msg, str(exc))
            except KeyError:
                pass
            self.queue.max_messages_semaphore.release()
            return InventoryMsgType.UNKNOWN

        if msg_type is InventoryMsgType.CREATED or msg_type is InventoryMsgType.UPDATED:
            self.queue.push_inventory_msg(msg["host"]["org_id"], msg["host"]["id"], msg, msg_type)
        elif msg_type is InventoryMsgType.DELETE:
            self.queue.push_inventory_msg(msg["org_id"], msg["id"], msg, msg_type)
        return msg_type

    def _consume_advisor_msg(self, msg: dict):
        """Consumes advisor message"""
        try:
            self.advisor_msg_validator.validate_message(msg)
        except InvalidAdvisorMsg as exc:
            LOGGER.error("obtained invalid advisor msg: %s, msg: %s", exc, msg)
            try:
                self._send_payload_tracker_error(msg["input"], str(exc))
            except KeyError:
                pass
            self.queue.max_messages_semaphore.release()
            return

        self.queue.push_advisor_msg(msg["input"]["host"]["org_id"], msg["input"]["host"]["id"], msg)

    async def _start_listening(self):
        async for msg in self.consumer.client:
            await self.queue.max_messages_semaphore.acquire()
            create_task_and_log(self.consume_message(msg), LOGGER, self.loop)

    async def stop(self):
        """Stops whole listener process"""
        LOGGER.info("Stopping the service")

        await self.queue.stop()
        await self.consumer.stop()
        await self.payload_tracker.stop()
        self.loop.stop()

    async def run(self):
        """Stars the listener service"""
        await self.consumer.start()

        async with self.db_pool:
            await self.init()
            await self._start_listening()
            await self.stop()

    async def consume_message(self, msg: ConsumerRecord):
        """Consumes single message from advisor or inventory"""
        try:
            msg_dict = json.loads(msg.value.decode("utf-8"))
        except json.decoder.JSONDecodeError as exc:
            MESSAGE_PARSE_ERROR.inc()
            LOGGER.exception("Unable to parse message: %s", exc)
            self.queue.max_messages_semaphore.release()
            return

        if msg_dict.get("host") or msg_dict.get("type") == "delete":
            self._consume_inventory_msg(msg_dict)
        elif msg_dict.get("input"):
            self._consume_advisor_msg(msg_dict)
        else:
            LOGGER.exception("Unknown message obtained: %s", msg)
            self.queue.max_messages_semaphore.release()
            SKIPPED_MESSAGES.inc()


def main():
    """Main"""
    init_logging()
    loop = asyncio.get_event_loop()

    status_app = create_status_app(LOGGER)
    _, status_site = create_status_runner(status_app, int(PROMETHEUS_PORT), LOGGER, loop)
    loop.run_until_complete(status_site.start())

    loop.run_until_complete(a_ensure_minimal_schema_version())

    LOGGER.info("Starting listener service")
    db_pool = setup_async_db_pool(CFG)
    listener = Listener(db_pool, loop)

    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)
    for sig in signals:
        loop.add_signal_handler(
            sig, lambda sig=sig: loop.create_task(listener.stop()))

    loop.create_task(listener.run())
    loop.run_forever()
    LOGGER.info("Stopped listener service")


if __name__ == "__main__":
    main()
