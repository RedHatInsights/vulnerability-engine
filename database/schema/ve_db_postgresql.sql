-- ---------------------------------------------------------------------------
-- Vulnerability Engine DB Users
--
-- Users are created in ve_db_user_create_postgresql.sql.  Permissions
-- are granted here.  Throughout this file, write access is granted to
-- specific users on specific tables just after the table is defined.
-- The goal is to have one user per Vulnerability Engine component, and
-- that user should be the only user allowed to write to tables for which
-- the component is responsible.  In the bottom section, read access is
-- granted on all tables to all users.
--
-- NOTE: If a table uses a sequence, make sure to grant USAGE, SELECT, UPDATE
-- on the sequence to the user.  SERIAL and BIGSERIAL are create table time
-- macros around sequences.
-- ---------------------------------------------------------------------------

-- This value must equal the version number of the upgrade_script that
-- upgrades an old schema version to match the schema defined herein.
--
-- So using a variable here causes our unit tests to fail because the unit
-- tests initialize its test database by reading this file and executing
-- it.  So I'm moving the table definition and insert up to here to make
-- it easier to find by someone creating an update for the schema.
--\set schema_version 1
-- db_version
CREATE TABLE IF NOT EXISTS db_version (
  name TEXT NOT NULL,
  version INT NOT NULL,
  PRIMARY KEY (name)
) TABLESPACE pg_default;

-- set the schema version directly in the insert statement here!!
INSERT INTO db_version (name, version) VALUES ('schema_version', 10);
-- INSERT INTO db_version (name, version) VALUES ('schema_version', :schema_version);



-- ---------------------------------------------------------------------------
-- Functions
-- ---------------------------------------------------------------------------

-- empty
CREATE OR REPLACE FUNCTION empty(t TEXT)
  RETURNS BOOLEAN as
$empty$
  BEGIN
    RETURN t ~ '^[[:space:]]*$';
  END;
$empty$
  LANGUAGE 'plpgsql';

-- set_first_reported
CREATE OR REPLACE FUNCTION set_first_reported()
  RETURNS TRIGGER AS
$set_first_reported$
  BEGIN
    IF NEW.first_reported IS NULL THEN
      NEW.first_reported := CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
  END;
$set_first_reported$
  LANGUAGE 'plpgsql';

-- set_last_updated
CREATE OR REPLACE FUNCTION set_last_updated()
  RETURNS TRIGGER AS
$set_last_updated$
  BEGIN
    IF (TG_OP = 'UPDATE') OR
       NEW.last_updated IS NULL THEN
      NEW.last_updated := CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
  END;
$set_last_updated$
  LANGUAGE 'plpgsql';

-- check_unchanged
CREATE OR REPLACE FUNCTION check_unchanged()
  RETURNS TRIGGER AS
$check_unchanged$
  BEGIN
    IF (TG_OP = 'INSERT') AND
       NEW.unchanged_since IS NULL THEN
      NEW.unchanged_since := CURRENT_TIMESTAMP;
    END IF;
    IF (TG_OP = 'UPDATE') AND
       NEW.json_checksum <> OLD.json_checksum THEN
      NEW.unchanged_since := CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
  END;
$check_unchanged$
  LANGUAGE 'plpgsql';

-- opt_out_system_update_cache
CREATE OR REPLACE FUNCTION opt_out_system_update_cache()
  RETURNS TRIGGER AS
$opt_out_system_update_cache$
  BEGIN
    IF (TG_OP = 'UPDATE') AND NEW.last_evaluation IS NOT NULL THEN
      -- system opted out
      IF OLD.opt_out = FALSE AND NEW.opt_out = TRUE THEN
        -- decrement affected cve counts for system
        WITH to_update_cves AS (
          SELECT casc.cve
          FROM cve_affected_systems_cache casc INNER JOIN
               system_vulnerabilities sv ON casc.cve = sv.cve
          WHERE casc.rh_account = NEW.rh_account AND
                sv.inventory_id = NEW.inventory_id AND
                sv.when_mitigated IS NULL
          ORDER BY casc.cve
          FOR UPDATE OF casc
        )
        UPDATE cve_affected_systems_cache casc
        SET systems_affected = systems_affected - 1,
            direct_systems_affected = CASE WHEN NEW.satellite_managed THEN direct_systems_affected ELSE direct_systems_affected - 1 END
        FROM to_update_cves
        WHERE casc.cve = to_update_cves.cve AND
              casc.rh_account = NEW.rh_account;
        -- delete zero cve counts
        DELETE FROM cve_affected_systems_cache
        WHERE rh_account = NEW.rh_account AND
              systems_affected = 0;

      -- system opted in
      ELSIF OLD.opt_out = TRUE AND NEW.opt_out = FALSE THEN
        -- increment affected cve counts for system
        WITH to_update_cves AS (
          SELECT casc.cve
          FROM cve_affected_systems_cache casc INNER JOIN
               system_vulnerabilities sv ON casc.cve = sv.cve
          WHERE casc.rh_account = NEW.rh_account AND
                sv.inventory_id = NEW.inventory_id AND
                sv.when_mitigated IS NULL
          ORDER BY casc.cve
          FOR UPDATE OF casc
        )
        UPDATE cve_affected_systems_cache casc
        SET systems_affected = systems_affected + 1,
            direct_systems_affected = CASE when NEW.satellite_managed THEN direct_systems_affected ELSE direct_systems_affected + 1 END
        FROM to_update_cves
        WHERE casc.cve = to_update_cves.cve AND
              casc.rh_account = NEW.rh_account;
        -- insert cache if not exists
        INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT sv.cve, NEW.rh_account, 1, CASE WHEN NEW.satellite_managed THEN 0 ELSE 1 END
        FROM system_vulnerabilities sv
        WHERE sv.inventory_id = NEW.inventory_id AND
              sv.when_mitigated IS NULL AND
              NOT EXISTS (
                SELECT 1 FROM cve_affected_systems_cache
                WHERE rh_account = NEW.rh_account AND
                      cve = sv.cve
              )
        ON CONFLICT (cve, rh_account) DO UPDATE SET
          systems_affected = cve_affected_systems_cache.systems_affected + EXCLUDED.systems_affected,
          direct_systems_affected = cve_affected_systems_cache.direct_systems_affected + EXCLUDED.direct_systems_affected;
      END IF;
    END IF;
    RETURN NEW;
  END;
$opt_out_system_update_cache$
  LANGUAGE 'plpgsql';

-- satellite_managed_system_update_cache
CREATE OR REPLACE FUNCTION satellite_managed_system_update_cache()
  RETURNS TRIGGER AS
$satellite_managed_system_update_cache$
  BEGIN
    IF (TG_OP = 'UPDATE') AND NEW.last_evaluation IS NOT NULL THEN
      -- system started to be managed by satellite
      IF OLD.satellite_managed = FALSE AND NEW.satellite_managed = TRUE THEN
        -- decrement affected cve counts for satellite managed system
        WITH to_update_cves AS (
          SELECT casc.cve
          FROM cve_affected_systems_cache casc INNER JOIN
               system_vulnerabilities sv ON casc.cve = sv.cve
          WHERE casc.rh_account = NEW.rh_account AND
                sv.inventory_id = NEW.inventory_id AND
                sv.when_mitigated IS NULL
          ORDER BY casc.cve
          FOR UPDATE OF casc
        )
        UPDATE cve_affected_systems_cache casc
        SET direct_systems_affected = direct_systems_affected - 1
        FROM to_update_cves
        WHERE casc.cve = to_update_cves.cve AND
              casc.rh_account = NEW.rh_account;

      -- system stopped to managed by satellite
      ELSIF OLD.satellite_managed = TRUE AND NEW.satellite_managed = FALSE THEN
        -- increment affected cve counts for system
        WITH to_update_cves AS (
          SELECT casc.cve
          FROM cve_affected_systems_cache casc INNER JOIN
               system_vulnerabilities sv ON casc.cve = sv.cve
          WHERE casc.rh_account = NEW.rh_account AND
                sv.inventory_id = NEW.inventory_id AND
                sv.when_mitigated IS NULL
          ORDER BY casc.cve
          FOR UPDATE OF casc
        )
        UPDATE cve_affected_systems_cache casc
        SET direct_systems_affected = direct_systems_affected + 1
        FROM to_update_cves
        WHERE casc.cve = to_update_cves.cve AND
              casc.rh_account = NEW.rh_account;
      END IF;
    END IF;
    RETURN NEW;
  END;
$satellite_managed_system_update_cache$
  LANGUAGE 'plpgsql';

-- refresh_all_cached_counts
-- WARNING: executing this procedure takes long time,
--          use only when necessary, e.g. during upgrade to populate initial caches
CREATE OR REPLACE FUNCTION refresh_all_cached_counts()
  RETURNS void AS
$refresh_all_cached_counts$
  BEGIN
    -- update cve count for ordered systems
    WITH to_update_systems AS (
      SELECT sp.inventory_id
      FROM system_platform sp
      ORDER BY sp.rh_account, sp.inventory_id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve) FROM system_vulnerabilities sv
      WHERE sv.inventory_id = sp.inventory_id AND sv.when_mitigated IS NULL
    )
    FROM to_update_systems
    WHERE sp.inventory_id = to_update_systems.inventory_id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.rh_account, casc.cve
      FROM cve_affected_systems_cache casc
      ORDER BY casc.rh_account, casc.cve
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve, sp.rh_account, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL
      GROUP BY sv.cve, sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve, rh_account, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE (cve, rh_account) NOT IN (SELECT cve, rh_account FROM current_counts);
  END;
$refresh_all_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_account_cached_counts(rh_account_in varchar)
  RETURNS void AS
$refresh_account_cached_counts$
  BEGIN
    -- update cve count for ordered systems
    WITH to_update_systems AS (
      SELECT sp.inventory_id
      FROM system_platform sp
      WHERE sp.rh_account = rh_account_in
      ORDER BY sp.inventory_id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve) FROM system_vulnerabilities sv
      WHERE sv.inventory_id = sp.inventory_id AND sv.when_mitigated IS NULL
    )
    FROM to_update_systems
    WHERE sp.inventory_id = to_update_systems.inventory_id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.cve
      FROM cve_affected_systems_cache casc
      WHERE casc.rh_account = rh_account_in
      ORDER BY casc.cve
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sp.rh_account = rh_account_in
      GROUP BY sv.cve
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve, rh_account_in, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE cve NOT IN (SELECT cve FROM current_counts)
      AND rh_account = rh_account_in;
  END;
$refresh_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_cached_counts(cve_in varchar)
  RETURNS void AS
$refresh_cve_cached_counts$
  BEGIN
    -- update system count for cve
    WITH locked_rows AS (
      SELECT casc.rh_account
      FROM cve_affected_systems_cache casc
      WHERE casc.cve = cve_in
      ORDER BY casc.rh_account
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sp.rh_account, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sv.cve = cve_in
      GROUP BY sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve_in, rh_account, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE rh_account NOT IN (SELECT rh_account FROM current_counts)
      AND cve = cve_in;
  END;
$refresh_cve_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_account_cached_counts(cve_in varchar, rh_account_in varchar)
  RETURNS void AS
$refresh_cve_account_cached_counts$
  BEGIN
    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.rh_account, casc.cve
      FROM cve_affected_systems_cache casc
      WHERE casc.cve = cve_in AND
            casc.rh_account = rh_account_in
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve, sp.rh_account, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sv.cve = cve_in AND
            sp.rh_account = rh_account_in
      GROUP BY sv.cve, sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve_in, rh_account_in, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE NOT EXISTS (SELECT 1 FROM current_counts)
      AND cve = cve_in
      AND rh_account = rh_account_in;
  END;
$refresh_cve_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_system_cached_counts(inventory_id_in varchar)
  RETURNS void AS
$refresh_system_cached_counts$
  BEGIN
    -- update cve count for system
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve) FROM system_vulnerabilities sv
      WHERE sv.inventory_id = sp.inventory_id AND sv.when_mitigated IS NULL
    ) WHERE sp.inventory_id = inventory_id_in;
  END;
$refresh_system_cached_counts$
  LANGUAGE 'plpgsql';


-- ----------------------------------------------------------------------------
-- Tables
-- ----------------------------------------------------------------------------

-- db_upgrade_log
CREATE TABLE IF NOT EXISTS db_upgrade_log (
  id SERIAL,
  version INT NOT NULL,
  status TEXT NOT NULL,
  script TEXT,
  returncode INT,
  stdout TEXT,
  stderr TEXT,
  last_updated TIMESTAMP WITH TIME ZONE NOT NULL
) TABLESPACE pg_default;

CREATE INDEX ON db_upgrade_log(version);

CREATE TRIGGER db_upgrade_log_set_last_updated
  BEFORE INSERT OR UPDATE ON db_upgrade_log
  FOR EACH ROW EXECUTE PROCEDURE set_last_updated();

-- system_platform
CREATE TABLE IF NOT EXISTS system_platform (
  inventory_id TEXT NOT NULL, CHECK (NOT empty(inventory_id)),
  rh_account TEXT NOT NULL, CHECK (NOT empty(rh_account)),
  first_reported TIMESTAMP WITH TIME ZONE NOT NULL,
  s3_url TEXT,
  vmaas_json TEXT,
  json_checksum TEXT,
  satellite_managed BOOLEAN NOT NULL DEFAULT FALSE,
  last_updated TIMESTAMP WITH TIME ZONE NOT NULL,
  unchanged_since TIMESTAMP WITH TIME ZONE NOT NULL,
  last_evaluation TIMESTAMP WITH TIME ZONE,
  opt_out BOOLEAN NOT NULL DEFAULT FALSE,
  cve_count_cache INT NOT NULL DEFAULT 0,
  UNIQUE (inventory_id)
) TABLESPACE pg_default;

CREATE INDEX ON system_platform(rh_account);

CREATE TRIGGER system_platform_set_first_reported
  BEFORE INSERT ON system_platform
  FOR EACH ROW EXECUTE PROCEDURE set_first_reported();

CREATE TRIGGER system_platform_set_last_updated
  BEFORE INSERT OR UPDATE ON system_platform
  FOR EACH ROW EXECUTE PROCEDURE set_last_updated();

CREATE TRIGGER system_platform_check_unchanged
  BEFORE INSERT OR UPDATE ON system_platform
  FOR EACH ROW EXECUTE PROCEDURE check_unchanged();

CREATE TRIGGER system_platform_opt_out_cache
  AFTER UPDATE OF opt_out ON system_platform
  FOR EACH ROW EXECUTE PROCEDURE opt_out_system_update_cache();

CREATE TRIGGER system_platform_satellite_managed_cache
  AFTER UPDATE OF satellite_managed ON system_platform
  FOR EACH ROW EXECUTE PROCEDURE satellite_managed_system_update_cache();

GRANT SELECT, INSERT, UPDATE, DELETE ON system_platform TO ve_db_user_listener;
-- evaluator needs to update last_evaluation
GRANT UPDATE ON system_platform TO ve_db_user_evaluator;
-- manager needs to update cache
GRANT UPDATE (cve_count_cache) ON system_platform TO ve_db_user_manager;

-- cve_impact
CREATE TABLE IF NOT EXISTS cve_impact (
  id INT NOT NULL,
  name TEXT NOT NULL UNIQUE, CHECK (NOT empty(name)),
  PRIMARY KEY (id)
)TABLESPACE pg_default;

INSERT INTO cve_impact (id, name) VALUES
  (0, 'NotSet'), (1, 'None'), (2, 'Low'), (3, 'Medium'), (4, 'Moderate'),
  (5, 'Important'), (6, 'High'), (7, 'Critical');


-- cve_metadata
CREATE TABLE IF NOT EXISTS cve_metadata (
  cve TEXT NOT NULL, CHECK (NOT empty(cve)),
  description TEXT NOT NULL, CHECK (NOT empty(description)),
  impact_id INT NOT NULL,
  public_date TIMESTAMP WITH TIME ZONE NULL,
  modified_date TIMESTAMP WITH TIME ZONE NULL,
  cvss3_score NUMERIC(5,3),
  cvss3_metrics TEXT,
  cvss2_score NUMERIC(5,3),
  cvss2_metrics TEXT,
  PRIMARY KEY (cve),
  CONSTRAINT impact_id
    FOREIGN KEY (impact_id)
    REFERENCES cve_impact (id)
) TABLESPACE pg_default;

CREATE INDEX ON cve_metadata(impact_id);
CREATE INDEX ON cve_metadata(cvss3_score);
CREATE INDEX ON cve_metadata(cvss2_score);

GRANT SELECT, INSERT, UPDATE, DELETE ON cve_metadata TO ve_db_user_evaluator;
GRANT SELECT, INSERT, UPDATE, DELETE ON cve_metadata TO ve_db_user_vmaas_sync;


-- status table
CREATE TABLE IF NOT EXISTS status (
  id INT NOT NULL,
  name TEXT NOT NULL UNIQUE, CHECK (NOT empty(name)),
  PRIMARY KEY (id)
)TABLESPACE pg_default;

INSERT INTO status (id, name) VALUES
  (0, 'Not Reviewed'), (1, 'In-Review'), (2, 'On-Hold'), (3, 'Scheduled for Patch'), (4, 'Resolved'),
  (5, 'No Action - Risk Accepted'), (6, 'Resolved via Mitigation (e.g. done without deploying a patch)') ;


-- system_vulnerabilities
CREATE TABLE IF NOT EXISTS system_vulnerabilities (
  id SERIAL,
  inventory_id TEXT NOT NULL, CHECK (NOT empty(inventory_id)),
  cve TEXT NOT NULL, CHECK (NOT empty(cve)),
  first_reported TIMESTAMP WITH TIME ZONE NOT NULL,
  when_mitigated TIMESTAMP WITH TIME ZONE DEFAULT NULL,
  status_id INT DEFAULT 0,
  PRIMARY KEY (id),
  UNIQUE (inventory_id, cve),
  CONSTRAINT system_platform_inventory_id
    FOREIGN KEY (inventory_id)
    REFERENCES system_platform (inventory_id),
  CONSTRAINT cve_metadata_cve
    FOREIGN KEY (cve)
    REFERENCES cve_metadata (cve),
  CONSTRAINT status_id
    FOREIGN KEY (status_id)
    REFERENCES status (id)
) TABLESPACE pg_default;

CREATE INDEX ON system_vulnerabilities(cve);
CREATE INDEX ON system_vulnerabilities(status_id);

CREATE TRIGGER system_vulnerabilities_set_first_reported BEFORE INSERT ON system_vulnerabilities
  FOR EACH ROW EXECUTE PROCEDURE set_first_reported();

GRANT SELECT, INSERT, UPDATE, DELETE ON system_vulnerabilities TO ve_db_user_evaluator;
-- manager needs to be able to update things like 'status' on a sysid/cve combination
GRANT UPDATE ON system_vulnerabilities TO ve_db_user_manager;
-- manager needs to be able to update opt_out column
GRANT UPDATE (opt_out) ON system_platform TO ve_db_user_manager;
-- listener deletes systems
GRANT DELETE ON system_vulnerabilities TO ve_db_user_listener;


-- cve_affected_systems_cache
CREATE TABLE IF NOT EXISTS cve_affected_systems_cache (
  cve TEXT NOT NULL, CHECK (NOT empty(cve)),
  rh_account TEXT NOT NULL, CHECK (NOT empty(cve)),
  systems_affected INT NOT NULL DEFAULT 0,
  direct_systems_affected INT NOT NULL DEFAULT 0,
  UNIQUE (cve, rh_account),
  CONSTRAINT cve_metadata_cve
    FOREIGN KEY (cve)
    REFERENCES cve_metadata (cve)
) TABLESPACE pg_default;

CREATE INDEX ON cve_affected_systems_cache(rh_account);

-- manager user needs to change this table for opt-out functionality
GRANT SELECT, INSERT, UPDATE, DELETE ON cve_affected_systems_cache TO ve_db_user_manager;
-- evaluator user needs to change this table
GRANT SELECT, INSERT, UPDATE, DELETE ON cve_affected_systems_cache TO ve_db_user_evaluator;
-- listner user needs to change this table when deleting system or updating sat_managed status
GRANT SELECT, INSERT, UPDATE, DELETE ON cve_affected_systems_cache TO ve_db_user_listener;


CREATE TABLE IF NOT EXISTS deleted_systems (
  inventory_id TEXT NOT NULL, CHECK (NOT empty(inventory_id)),
  when_deleted TIMESTAMP WITH TIME ZONE NOT NULL,
  UNIQUE (inventory_id)
) TABLESPACE pg_default;

CREATE INDEX ON deleted_systems(when_deleted);

GRANT SELECT, INSERT, UPDATE, DELETE ON deleted_systems TO ve_db_user_listener;


-- repo
CREATE TABLE IF NOT EXISTS repo (
  id SERIAL,
  name TEXT NOT NULL UNIQUE, CHECK (NOT empty(name)),
  PRIMARY KEY (id)
) TABLESPACE pg_default;

GRANT SELECT, INSERT, UPDATE, DELETE ON repo TO ve_db_user_listener;


-- system_repo
CREATE TABLE IF NOT EXISTS system_repo (
  inventory_id TEXT NOT NULL, CHECK (NOT empty(inventory_id)),
  repo_id INT NOT NULL,
  UNIQUE (inventory_id, repo_id),
  CONSTRAINT inventory_id
    FOREIGN KEY (inventory_id)
    REFERENCES system_platform (inventory_id),
  CONSTRAINT repo_id
    FOREIGN KEY (repo_id)
    REFERENCES repo (id)
) TABLESPACE pg_default;

CREATE INDEX ON system_repo(inventory_id);
CREATE INDEX ON system_repo(repo_id);

GRANT SELECT, INSERT, UPDATE, DELETE ON system_repo TO ve_db_user_listener;

-- ----------------------------------------------------------------------------
-- Read access for all users
-- ----------------------------------------------------------------------------

-- user for evaluator component
GRANT SELECT ON ALL TABLES IN SCHEMA public TO ve_db_user_evaluator;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO ve_db_user_evaluator;

-- user for listener component
GRANT SELECT ON ALL TABLES IN SCHEMA public TO ve_db_user_listener;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO ve_db_user_listener;

-- user for UI manager component
GRANT SELECT ON ALL TABLES IN SCHEMA public TO ve_db_user_manager;

-- user for VMaaS sync component
GRANT SELECT ON ALL TABLES IN SCHEMA public TO ve_db_user_vmaas_sync;
