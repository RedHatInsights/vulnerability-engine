-- system_platform table

ALTER TABLE system_platform ADD COLUMN id SERIAL;

ALTER TABLE system_platform ADD PRIMARY KEY(id);

ALTER TABLE system_vulnerabilities ADD COLUMN system_id INT;

UPDATE system_vulnerabilities sv SET system_id = sub.id FROM (SELECT id, inventory_id FROM system_platform) AS sub WHERE sv.inventory_id = sub.inventory_id;

ALTER TABLE system_vulnerabilities ALTER system_id SET NOT NULL;

ALTER TABLE system_vulnerabilities DROP CONSTRAINT system_platform_inventory_id;

ALTER TABLE system_vulnerabilities ADD CONSTRAINT system_platform_id FOREIGN KEY (system_id) REFERENCES system_platform(id);

ALTER TABLE system_vulnerabilities DROP inventory_id;

ALTER TABLE system_repo ADD system_id INT;

UPDATE system_repo sr SET system_id = sub.id FROM (SELECT id, inventory_id FROM system_platform) AS sub WHERE sr.inventory_id = sub.inventory_id;

ALTER TABLE system_repo ADD CONSTRAINT system_platform_id FOREIGN KEY (system_id) REFERENCES system_platform(id);

ALTER TABLE system_repo DROP inventory_id;

ALTER TABLE system_repo ALTER system_id SET NOT NULL;

ALTER TABLE system_repo ADD CONSTRAINT system_repo_system_id_repo_id_key UNIQUE (system_id, repo_id);

CREATE INDEX ON system_repo(system_id);

-- cve_metadata table

ALTER TABLE cve_metadata ADD COLUMN id SERIAL;

ALTER TABLE system_vulnerabilities ADD COLUMN cve_id INT;

UPDATE system_vulnerabilities sv SET cve_id = sub.id FROM (SELECT id, cve FROM cve_metadata) AS sub WHERE sv.cve = sub.cve;

ALTER TABLE system_vulnerabilities ALTER cve_id SET NOT NULL;

ALTER TABLE system_vulnerabilities DROP CONSTRAINT cve_metadata_cve;

ALTER TABLE system_vulnerabilities DROP COLUMN cve;

ALTER TABLE cve_affected_systems_cache ADD COLUMN cve_id INT;

UPDATE cve_affected_systems_cache casc SET cve_id = sub.id FROM (SELECT id, cve FROM cve_metadata) AS sub WHERE casc.cve = sub.cve;

ALTER TABLE cve_affected_systems_cache ALTER cve_id SET NOT NULL;

ALTER TABLE cve_affected_systems_cache DROP CONSTRAINT cve_metadata_cve;

ALTER TABLE cve_affected_systems_cache DROP COLUMN cve;

ALTER TABLE cve_metadata DROP CONSTRAINT cve_metadata_pkey;

ALTER TABLE cve_metadata ADD UNIQUE (cve);

ALTER TABLE cve_metadata ADD PRIMARY KEY(id);

ALTER TABLE system_vulnerabilities ADD CONSTRAINT cve_metadata_cve_id FOREIGN KEY (cve_id) REFERENCES cve_metadata(id);

ALTER TABLE system_vulnerabilities ADD CONSTRAINT system_vulnerabilities_system_id_cve_id_key UNIQUE (system_id, cve_id);

ALTER TABLE cve_affected_systems_cache ADD CONSTRAINT cve_metadata_cve_id FOREIGN KEY (cve_id) REFERENCES cve_metadata(id);

ALTER TABLE cve_affected_systems_cache ADD CONSTRAINT cve_affected_systems_cache_cve_id_rh_account_key UNIQUE (cve_id, rh_account);

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO ve_db_user_evaluator;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO ve_db_user_listener;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO ve_db_user_vmaas_sync;

-- opt_out_system_update_cache
CREATE OR REPLACE FUNCTION opt_out_system_update_cache()
  RETURNS TRIGGER AS
$opt_out_system_update_cache$
  BEGIN
    IF (TG_OP = 'UPDATE') AND NEW.last_evaluation IS NOT NULL THEN
      -- system opted out
      IF OLD.opt_out = FALSE AND NEW.opt_out = TRUE THEN
        -- decrement affected cve counts for system
        WITH to_update_cves AS (
          SELECT casc.cve_id
          FROM cve_affected_systems_cache casc INNER JOIN
               system_vulnerabilities sv ON casc.cve_id = sv.cve_id
          WHERE casc.rh_account = NEW.rh_account AND
                sv.system_id = NEW.id AND
                sv.when_mitigated IS NULL
          ORDER BY casc.cve_id
          FOR UPDATE OF casc
        )
        UPDATE cve_affected_systems_cache casc
        SET systems_affected = systems_affected - 1
        FROM to_update_cves
        WHERE casc.cve_id = to_update_cves.cve_id AND
              casc.rh_account = NEW.rh_account;
        -- delete zero cve counts
        DELETE FROM cve_affected_systems_cache
        WHERE rh_account = NEW.rh_account AND
              systems_affected = 0;

      -- system opted in
      ELSIF OLD.opt_out = TRUE AND NEW.opt_out = FALSE THEN
        -- increment affected cve counts for system
        WITH to_update_cves AS (
          SELECT casc.cve_id
          FROM cve_affected_systems_cache casc INNER JOIN
               system_vulnerabilities sv ON casc.cve_id = sv.cve_id
          WHERE casc.rh_account = NEW.rh_account AND
                sv.system_id = NEW.id AND
                sv.when_mitigated IS NULL
          ORDER BY casc.cve_id
          FOR UPDATE OF casc
        )
        UPDATE cve_affected_systems_cache casc
        SET systems_affected = systems_affected + 1
        FROM to_update_cves
        WHERE casc.cve_id = to_update_cves.cve_id AND
              casc.rh_account = NEW.rh_account;
        -- insert cache if not exists
        INSERT INTO cve_affected_systems_cache (cve_id, rh_account, systems_affected)
        SELECT sv.cve_id, NEW.rh_account, 1
        FROM system_vulnerabilities sv
        WHERE sv.system_id = NEW.id AND
              sv.when_mitigated IS NULL AND
              NOT EXISTS (
                SELECT 1 FROM cve_affected_systems_cache
                WHERE rh_account = NEW.rh_account AND
                      cve_id = sv.cve_id
              )
        ON CONFLICT (cve_id, rh_account) DO UPDATE SET
          systems_affected = cve_affected_systems_cache.systems_affected + EXCLUDED.systems_affected;
      END IF;
    END IF;
    RETURN NEW;
  END;
$opt_out_system_update_cache$
  LANGUAGE 'plpgsql';

-- refresh_all_cached_counts
-- WARNING: executing this procedure takes long time,
--          use only when necessary, e.g. during upgrade to populate initial caches
CREATE OR REPLACE FUNCTION refresh_all_cached_counts()
  RETURNS void AS
$refresh_all_cached_counts$
  BEGIN
    -- update cve count for ordered systems
    WITH to_update_systems AS (
      SELECT sp.id
      FROM system_platform sp
      ORDER BY sp.rh_account, sp.id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve_id) FROM system_vulnerabilities sv
      WHERE sv.system_id = sp.id AND sv.when_mitigated IS NULL
    )
    FROM to_update_systems
    WHERE sp.id = to_update_systems.id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.rh_account, casc.cve_id
      FROM cve_affected_systems_cache casc
      ORDER BY casc.rh_account, casc.cve_id
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve_id, sp.rh_account, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL
      GROUP BY sv.cve_id, sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve_id, rh_account, systems_affected)
        SELECT cve_id, rh_account, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE (cve_id, rh_account) NOT IN (SELECT cve_id, rh_account FROM current_counts);
  END;
$refresh_all_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_account_cached_counts(rh_account_in varchar)
  RETURNS void AS
$refresh_account_cached_counts$
  BEGIN
    -- update cve count for ordered systems
    WITH to_update_systems AS (
      SELECT sp.id
      FROM system_platform sp
      WHERE sp.rh_account = rh_account_in
      ORDER BY sp.id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve_id) FROM system_vulnerabilities sv
      WHERE sv.system_id = sp.id AND sv.when_mitigated IS NULL
    )
    FROM to_update_systems
    WHERE sp.id = to_update_systems.id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.cve_id
      FROM cve_affected_systems_cache casc
      WHERE casc.rh_account = rh_account_in
      ORDER BY casc.cve_id
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve_id, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sp.rh_account = rh_account_in
      GROUP BY sv.cve_id
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve_id, rh_account, systems_affected)
        SELECT cve_id, rh_account_in, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE cve_id NOT IN (SELECT cve_id FROM current_counts)
      AND rh_account = rh_account_in;
  END;
$refresh_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_cached_counts(cve_in varchar)
  RETURNS void AS
$refresh_cve_cached_counts$
  DECLARE
    cve_md_id INT;
  BEGIN
    -- update system count for cve
    SELECT id FROM cve_metadata WHERE cve = cve_in INTO cve_md_id;
    WITH locked_rows AS (
      SELECT casc.rh_account
      FROM cve_affected_systems_cache casc
      WHERE casc.cve_id = cve_md_id
      ORDER BY casc.rh_account
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sp.rh_account, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sv.cve_id = cve_md_id
      GROUP BY sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve_id, rh_account, systems_affected)
        SELECT cve_md_id, rh_account, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE rh_account NOT IN (SELECT rh_account FROM current_counts)
      AND cve_id = cve_md_id;
  END;
$refresh_cve_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_account_cached_counts(cve_in varchar, rh_account_in varchar)
  RETURNS void AS
$refresh_cve_account_cached_counts$
  DECLARE
    cve_md_id INT;
  BEGIN
    -- update system count for ordered cves
    SELECT id FROM cve_metadata WHERE cve = cve_in INTO cve_md_id;
    WITH locked_rows AS (
      SELECT casc.rh_account, casc.cve_id
      FROM cve_affected_systems_cache casc
      WHERE casc.cve_id = cve_md_id AND
            casc.rh_account = rh_account_in
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve_id, sp.rh_account, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sv.cve_id = cve_md_id AND
            sp.rh_account = rh_account_in
      GROUP BY sv.cve_id, sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve_id, rh_account, systems_affected)
        SELECT cve_md_id, rh_account_in, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE NOT EXISTS (SELECT 1 FROM current_counts)
      AND cve_id = cve_md_id
      AND rh_account = rh_account_in;
  END;
$refresh_cve_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_system_cached_counts(inventory_id_in varchar)
  RETURNS void AS
$refresh_system_cached_counts$
  BEGIN
    -- update cve count for system
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve_id) FROM system_vulnerabilities sv
      WHERE sv.system_id = sp.id AND sv.when_mitigated IS NULL
    ) WHERE sp.inventory_id = inventory_id_in;
  END;
$refresh_system_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION delete_system(inventory_id_in varchar)
  RETURNS TABLE (deleted_inventory_id TEXT) AS
$delete_system$
  BEGIN
    -- opt out to refresh cache and then delete
    WITH locked_row AS (
      SELECT id
      FROM system_platform
      WHERE inventory_id = inventory_id_in
      FOR UPDATE
    )
    UPDATE system_platform SET opt_out = true
    WHERE inventory_id = inventory_id_in;
    DELETE FROM system_vulnerabilities
    WHERE system_id = (SELECT id from system_platform WHERE inventory_id = inventory_id_in);
    DELETE FROM system_repo
    WHERE system_id = (SELECT id from system_platform WHERE inventory_id = inventory_id_in);
    RETURN QUERY DELETE FROM system_platform
    WHERE inventory_id = inventory_id_in
    RETURNING inventory_id;
  END;
$delete_system$
  LANGUAGE 'plpgsql';
