-- opt_out_system_update_cache
CREATE OR REPLACE FUNCTION opt_out_system_update_cache()
  RETURNS TRIGGER AS
$opt_out_system_update_cache$
  BEGIN
    IF (TG_OP = 'UPDATE') AND (NEW.last_evaluation IS NOT NULL OR NEW.advisor_evaluated IS NOT NULL) THEN
      -- system opted out
      IF OLD.opt_out = FALSE AND OLD.stale = FALSE AND (NEW.opt_out = TRUE OR NEW.stale = TRUE) THEN
        -- decrement affected cve counts for system
        WITH to_update_cves AS (
          SELECT cad.cve_id, cad.status_id AS global_status_id, sv.status_id
          FROM cve_account_data cad INNER JOIN
               system_vulnerabilities sv ON cad.cve_id = sv.cve_id LEFT OUTER JOIN
               insights_rule ir ON sv.rule_id = ir.id
          WHERE cad.rh_account_id = NEW.rh_account_id AND
                sv.system_id = NEW.id AND
                (sv.mitigation_reason IS NULL OR ir.active = 'F') AND
                (sv.when_mitigated IS NULL OR ir.active = 'T')
          ORDER BY cad.cve_id
          FOR UPDATE OF cad
        -- decrement systems_affected and systems_status_divergent in case status is different
        ), update_divergent AS (
          UPDATE cve_account_data cad
          SET systems_affected = systems_affected - 1,
              systems_status_divergent = systems_status_divergent - 1
          FROM to_update_cves
          WHERE cad.cve_id = to_update_cves.cve_id AND
                cad.rh_account_id = NEW.rh_account_id AND
                to_update_cves.global_status_id != to_update_cves.status_id
        )
        -- decrement only systems_affected in case status is same
        UPDATE cve_account_data cad
        SET systems_affected = systems_affected - 1
        FROM to_update_cves
        WHERE cad.cve_id = to_update_cves.cve_id AND
              cad.rh_account_id = NEW.rh_account_id AND
              to_update_cves.global_status_id = to_update_cves.status_id;
        -- delete zero cve counts
        DELETE FROM cve_account_data
        WHERE rh_account_id = NEW.rh_account_id AND
              systems_affected = 0;

      -- system opted in
      ELSIF (OLD.opt_out = TRUE OR OLD.stale = TRUE) AND NEW.opt_out = FALSE AND NEW.stale = FALSE THEN
        -- increment affected cve counts for system
        WITH to_update_cves AS (
          SELECT cad.cve_id, cad.status_id AS global_status_id, sv.status_id
          FROM cve_account_data cad INNER JOIN
               system_vulnerabilities sv ON cad.cve_id = sv.cve_id LEFT OUTER JOIN
               insights_rule ir ON sv.rule_id = ir.id
          WHERE cad.rh_account_id = NEW.rh_account_id AND
                sv.system_id = NEW.id AND
                (sv.mitigation_reason IS NULL OR ir.active = 'F') AND
                (sv.when_mitigated IS NULL OR ir.active = 'T')
          ORDER BY cad.cve_id
          FOR UPDATE OF cad
        -- increment systems_affected and systems_status_divergent in case status is different
        ), update_divergent AS (
          UPDATE cve_account_data cad
          SET systems_affected = systems_affected + 1,
              systems_status_divergent = systems_status_divergent + 1
          FROM to_update_cves
          WHERE cad.cve_id = to_update_cves.cve_id AND
                cad.rh_account_id = NEW.rh_account_id AND
                to_update_cves.global_status_id != to_update_cves.status_id
        )
        -- increment only systems_affected in case status is same
        UPDATE cve_account_data cad
        SET systems_affected = systems_affected + 1
        FROM to_update_cves
        WHERE cad.cve_id = to_update_cves.cve_id AND
              cad.rh_account_id = NEW.rh_account_id AND
              to_update_cves.global_status_id = to_update_cves.status_id;
        -- insert cache if not exists
        INSERT INTO cve_account_data (cve_id, rh_account_id, systems_affected)
        SELECT sv.cve_id, NEW.rh_account_id, 1
        FROM system_vulnerabilities sv LEFT OUTER JOIN
             insights_rule ir ON sv.rule_id = ir.id
        WHERE sv.system_id = NEW.id AND
              (sv.mitigation_reason IS NULL OR ir.active = 'F') AND
              (sv.when_mitigated IS NULL OR ir.active = 'T') AND
              NOT EXISTS (
                SELECT 1 FROM cve_account_data
                WHERE rh_account_id = NEW.rh_account_id AND
                      cve_id = sv.cve_id
              )
        ON CONFLICT (cve_id, rh_account_id) DO UPDATE SET
          systems_affected = cve_account_data.systems_affected + EXCLUDED.systems_affected;
      END IF;
    END IF;
    RETURN NEW;
  END;
$opt_out_system_update_cache$
  LANGUAGE 'plpgsql';

-- refresh_all_cached_counts
-- WARNING: executing this procedure takes long time,
--          use only when necessary, e.g. during upgrade to populate initial caches
CREATE OR REPLACE FUNCTION refresh_all_cached_counts()
  RETURNS void AS
$refresh_all_cached_counts$
  BEGIN
    -- update cve count for ordered systems
    WITH to_update_systems AS (
      SELECT sp.id
      FROM system_platform sp
      ORDER BY sp.rh_account_id, sp.id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve_id) FROM system_vulnerabilities sv LEFT OUTER JOIN
                                insights_rule ir ON sv.rule_id = ir.id
      WHERE sv.system_id = sp.id AND (sv.mitigation_reason IS NULL OR ir.active = 'F') AND (sv.when_mitigated IS NULL OR ir.active = 'T')
    )
    FROM to_update_systems
    WHERE sp.id = to_update_systems.id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT cad.rh_account_id, cad.cve_id
      FROM cve_account_data cad
      ORDER BY cad.rh_account_id, cad.cve_id
      FOR UPDATE OF cad
    ), current_counts AS (
      SELECT sv.cve_id, sp.rh_account_id, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id LEFT OUTER JOIN
           insights_rule ir ON sv.rule_id = ir.id
      WHERE sp.when_deleted IS NULL AND
            (sp.last_evaluation IS NOT NULL OR sp.advisor_evaluated IS NOT NULL) AND
            (sp.opt_out = FALSE AND sp.stale = FALSE) AND
            (sv.mitigation_reason IS NULL OR ir.active = 'F') AND
            (sv.when_mitigated IS NULL OR
            ir.active = 'T')
      GROUP BY sv.cve_id, sp.rh_account_id
    ), upserted AS (
      INSERT INTO cve_account_data (cve_id, rh_account_id, systems_affected)
        SELECT cve_id, rh_account_id, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account_id) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_account_data WHERE (cve_id, rh_account_id) NOT IN (SELECT cve_id, rh_account_id FROM current_counts);
  END;
$refresh_all_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_account_cached_counts(rh_account_in varchar)
  RETURNS void AS
$refresh_account_cached_counts$
  DECLARE
    rh_account_id_in INT;
  BEGIN
    -- update cve count for ordered systems
    SELECT id FROM rh_account WHERE name = rh_account_in INTO rh_account_id_in;
    WITH to_update_systems AS (
      SELECT sp.id
      FROM system_platform sp
      WHERE sp.rh_account_id = rh_account_id_in
      ORDER BY sp.id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve_id) FROM system_vulnerabilities sv LEFT OUTER JOIN
                                insights_rule ir ON sv.rule_id = ir.id
      WHERE sv.system_id = sp.id AND (sv.mitigation_reason IS NULL OR ir.active = 'F') AND (sv.when_mitigated IS NULL OR ir.active = 'T')
    )
    FROM to_update_systems
    WHERE sp.id = to_update_systems.id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT cad.cve_id
      FROM cve_account_data cad
      WHERE cad.rh_account_id = rh_account_id_in
      ORDER BY cad.cve_id
      FOR UPDATE OF cad
    ), current_counts AS (
      SELECT sv.cve_id, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id LEFT OUTER JOIN
           insights_rule ir ON sv.rule_id = ir.id
      WHERE sp.when_deleted IS NULL AND
            (sp.last_evaluation IS NOT NULL OR sp.advisor_evaluated IS NOT NULL) AND
            (sp.opt_out = FALSE AND sp.stale = FALSE) AND
            (sv.mitigation_reason IS NULL OR ir.active = 'F') AND
            (sv.when_mitigated IS NULL OR
            ir.active = 'T') AND
            sp.rh_account_id = rh_account_id_in
      GROUP BY sv.cve_id
    ), upserted AS (
      INSERT INTO cve_account_data (cve_id, rh_account_id, systems_affected)
        SELECT cve_id, rh_account_id_in, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account_id) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_account_data WHERE cve_id NOT IN (SELECT cve_id FROM current_counts)
      AND rh_account_id = rh_account_id_in;
  END;
$refresh_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_cached_counts(cve_in varchar)
  RETURNS void AS
$refresh_cve_cached_counts$
  DECLARE
    cve_md_id INT;
  BEGIN
    -- update system count for cve
    SELECT id FROM cve_metadata WHERE cve = cve_in INTO cve_md_id;
    WITH locked_rows AS (
      SELECT cad.rh_account_id
      FROM cve_account_data cad
      WHERE cad.cve_id = cve_md_id
      ORDER BY cad.rh_account_id
      FOR UPDATE OF cad
    ), current_counts AS (
      SELECT sp.rh_account_id, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id LEFT OUTER JOIN
           insights_rule ir ON sv.rule_id = ir.id
      WHERE sp.when_deleted IS NULL AND
            (sp.last_evaluation IS NOT NULL OR sp.advisor_evaluated IS NOT NULL) AND
            (sp.opt_out = FALSE AND sp.stale = FALSE) AND
            (sv.mitigation_reason IS NULL OR ir.active = 'F') AND
            (sv.when_mitigated IS NULL OR
            ir.active = 'T') AND
            sv.cve_id = cve_md_id
      GROUP BY sp.rh_account_id
    ), upserted AS (
      INSERT INTO cve_account_data (cve_id, rh_account_id, systems_affected)
        SELECT cve_md_id, rh_account_id, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account_id) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_account_data WHERE rh_account_id NOT IN (SELECT rh_account_id FROM current_counts)
      AND cve_id = cve_md_id;
  END;
$refresh_cve_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_account_cached_counts(cve_in varchar, rh_account_in varchar)
  RETURNS void AS
$refresh_cve_account_cached_counts$
  DECLARE
    cve_md_id INT;
    rh_account_id_in INT;
  BEGIN
    -- update system count for ordered cves
    SELECT id FROM cve_metadata WHERE cve = cve_in INTO cve_md_id;
    SELECT id FROM rh_account WHERE name = rh_account_in INTO rh_account_id_in;
    WITH locked_rows AS (
      SELECT cad.rh_account_id, cad.cve_id
      FROM cve_account_data cad
      WHERE cad.cve_id = cve_md_id AND
            cad.rh_account_id = rh_account_id_in
      FOR UPDATE OF cad
    ), current_counts AS (
      SELECT sv.cve_id, sp.rh_account_id, count(sv.system_id) as systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp ON sv.system_id = sp.id LEFT OUTER JOIN
           insights_rule ir ON sv.rule_id = ir.id
      WHERE sp.when_deleted IS NULL AND
            (sp.last_evaluation IS NOT NULL OR sp.advisor_evaluated IS NOT NULL) AND
            (sp.opt_out = FALSE AND sp.stale = FALSE) AND
            (sv.mitigation_reason IS NULL OR ir.active = 'F') AND
            (sv.when_mitigated IS NULL OR
            ir.active = 'T') AND
            sv.cve_id = cve_md_id AND
            sp.rh_account_id = rh_account_id_in
      GROUP BY sv.cve_id, sp.rh_account_id
    ), upserted AS (
      INSERT INTO cve_account_data (cve_id, rh_account_id, systems_affected)
        SELECT cve_md_id, rh_account_id_in, systems_affected FROM current_counts
      ON CONFLICT (cve_id, rh_account_id) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected
    )
    DELETE FROM cve_account_data WHERE NOT EXISTS (SELECT 1 FROM current_counts)
      AND cve_id = cve_md_id
      AND rh_account_id = rh_account_id_in;
  END;
$refresh_cve_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_system_cached_counts(inventory_id_in varchar)
  RETURNS void AS
$refresh_system_cached_counts$
  BEGIN
    -- update cve count for system
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve_id) FROM system_vulnerabilities sv LEFT OUTER JOIN
                                insights_rule ir ON sv.rule_id = ir.id
      WHERE sv.system_id = sp.id AND (sv.mitigation_reason IS NULL OR ir.active = 'F') AND (sv.when_mitigated IS NULL OR ir.active = 'T')
    ) WHERE sp.inventory_id = inventory_id_in;
  END;
$refresh_system_cached_counts$
  LANGUAGE 'plpgsql';
