-- refresh_all_cached_counts
-- WARNING: executing this procedure takes long time,
--          use only when necessary, e.g. during upgrade to populate initial caches
CREATE OR REPLACE FUNCTION refresh_all_cached_counts()
  RETURNS void AS
$refresh_all_cached_counts$
  BEGIN
    -- update cve count for ordered systems
    WITH to_update_systems AS (
      SELECT sp.inventory_id
      FROM system_platform sp
      ORDER BY sp.rh_account, sp.inventory_id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve) FROM system_vulnerabilities sv
      WHERE sv.inventory_id = sp.inventory_id AND sv.when_mitigated IS NULL
    )
    FROM to_update_systems
    WHERE sp.inventory_id = to_update_systems.inventory_id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.rh_account, casc.cve
      FROM cve_affected_systems_cache casc
      ORDER BY casc.rh_account, casc.cve
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve, sp.rh_account, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL
      GROUP BY sv.cve, sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve, rh_account, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE (cve, rh_account) NOT IN (SELECT cve, rh_account FROM current_counts);
  END;
$refresh_all_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_account_cached_counts(rh_account_in varchar)
  RETURNS void AS
$refresh_account_cached_counts$
  BEGIN
    -- update cve count for ordered systems
    WITH to_update_systems AS (
      SELECT sp.inventory_id
      FROM system_platform sp
      WHERE sp.rh_account = rh_account_in
      ORDER BY sp.inventory_id
      FOR UPDATE OF sp
    )
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve) FROM system_vulnerabilities sv
      WHERE sv.inventory_id = sp.inventory_id AND sv.when_mitigated IS NULL
    )
    FROM to_update_systems
    WHERE sp.inventory_id = to_update_systems.inventory_id;

    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.cve
      FROM cve_affected_systems_cache casc
      WHERE casc.rh_account = rh_account_in
      ORDER BY casc.cve
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sp.rh_account = rh_account_in
      GROUP BY sv.cve
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve, rh_account_in, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE cve NOT IN (SELECT cve FROM current_counts)
      AND rh_account = rh_account_in;
  END;
$refresh_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_cached_counts(cve_in varchar)
  RETURNS void AS
$refresh_cve_cached_counts$
  BEGIN
    -- update system count for cve
    WITH locked_rows AS (
      SELECT casc.rh_account
      FROM cve_affected_systems_cache casc
      WHERE casc.cve = cve_in
      ORDER BY casc.rh_account
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sp.rh_account, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sv.cve = cve_in
      GROUP BY sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve_in, rh_account, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE rh_account NOT IN (SELECT rh_account FROM current_counts)
      AND cve = cve_in;
  END;
$refresh_cve_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_cve_account_cached_counts(cve_in varchar, rh_account_in varchar)
  RETURNS void AS
$refresh_cve_account_cached_counts$
  BEGIN
    -- update system count for ordered cves
    WITH locked_rows AS (
      SELECT casc.rh_account, casc.cve
      FROM cve_affected_systems_cache casc
      WHERE casc.cve = cve_in AND
            casc.rh_account = rh_account_in
      FOR UPDATE OF casc
    ), current_counts AS (
      SELECT sv.cve, sp.rh_account, count(sv.inventory_id) as systems_affected, count(CASE WHEN sp.satellite_managed THEN NULL ELSE 1 END) as direct_systems_affected
      FROM system_vulnerabilities sv INNER JOIN
           system_platform sp USING (inventory_id)
      WHERE sp.last_evaluation IS NOT NULL AND
            sp.opt_out = FALSE AND
            sv.when_mitigated IS NULL AND
            sv.cve = cve_in AND
            sp.rh_account = rh_account_in
      GROUP BY sv.cve, sp.rh_account
    ), upserted AS (
      INSERT INTO cve_affected_systems_cache (cve, rh_account, systems_affected, direct_systems_affected)
        SELECT cve_in, rh_account_in, systems_affected, direct_systems_affected FROM current_counts
      ON CONFLICT (cve, rh_account) DO UPDATE SET
        systems_affected = EXCLUDED.systems_affected,
        direct_systems_affected = EXCLUDED.direct_systems_affected
    )
    DELETE FROM cve_affected_systems_cache WHERE NOT EXISTS (SELECT 1 FROM current_counts)
      AND cve = cve_in
      AND rh_account = rh_account_in;
  END;
$refresh_cve_account_cached_counts$
  LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION refresh_system_cached_counts(inventory_id_in varchar)
  RETURNS void AS
$refresh_system_cached_counts$
  BEGIN
    -- update cve count for system
    UPDATE system_platform sp SET cve_count_cache = (
      SELECT COUNT(cve) FROM system_vulnerabilities sv
      WHERE sv.inventory_id = sp.inventory_id AND sv.when_mitigated IS NULL
    ) WHERE sp.inventory_id = inventory_id_in;
  END;
$refresh_system_cached_counts$
  LANGUAGE 'plpgsql';

-- manager needs to update cache
GRANT UPDATE (cve_count_cache) ON system_platform TO ve_db_user_manager;
