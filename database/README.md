# Vulnerability Engine Database Service


## Overview

The Vulnerability Engine Database Service provides the database for the components that make up the Vulnerability Engine.  Each component should have its own database user that is granted write permissions only on the table(s) it is responsible for.  Each table should only have one component that is capable of writing to the tables.  All users should have read access to all the tables.

## Schema Upgrades

This is a quick step-by-step of how to add a database schema upgrade.

 * add a new sql script to the schema/upgrade_scripts/ directory.
   * file name must be in format ```<ver#>-<name>.sql```
     * ver# is any number if digit characters.  eg. 004 or 0000023
       * suggested format is three characters - ###
     * ver# must be sequential - no duplicate values and no skipped values.
   * sql file defines sql statements to modify the database.
     * suggested is to put one command in a file so database is not left in an indeterminate state because one command succeeded while another failed.
       * for example, if a new feature requires a new table and a column added to an existing table, it is suggested to create two files:
         * 003-new-feature-add-table.sql
         * 004-new-feature-add-column.sql
 * update schema/ve_db_postgresql.sql so that the schema matches that which results when the new update scripts are applied.
   * BE SURE to also update the schema_version variable defined in schema/ve_db_postgresql.sql to the value that matches the ver# in the latest upgrade script file name.

## Adding a new user for a Vulnerability Engine component

 * add a CREATE USER command to database/schema/ve_db_user_create_postgresql.sql
 * add SELECT privileges for all tables for this user at the bottom of database/schema/ve_db_postgresql.sql
 * throughout the database/schema/ve_db_postgresql.sql file, for each table to which the user should have write privileges, add a GRANT INSERT, UPDATE, DELETE statement under the CREATE TABLE statement to give these privileges to the user.  If there is a sequence, also add a GRANT USAGE, SELECT, UPDATE on the sequence as well. 
 * add a new envirnment variable to database/Dockerfile to hold the password for the new user.
 * in the database/schema/init_schema.sh file, add an addition psql command to alter the new user and provide the user's password using the environment variable defined in the previous step.
 * add an upgrade script (see section above) to create the new user and grant permissions to existing database instances.
 * copy the content of conf/database-connection-manager.env to a new 'database-connection-<component>.env file in the conf/ directory.  Update the user and password to be the new user.  Make sure the port is 15432 so the component is able to connect to the database.
 * add the new .env file created in the previous step as an env_file to the corresponding component in the docker-compose.yml file.  Note that each component can only have one .env so the username and password environment variables don't collide.


## docker how-to

#### Build a new image:

```docker build -t ve_db_img -f Dockerfile-database .```

#### Create a container:

```docker create -it -p 15432:5432 --name ve_db_ctr ve_db_img```

#### Start a container:

```docker start ve_db_ctr```

#### Command to connect to database

```psql -h localhost -p 15432 -U ve_db_admin vulnerability```

#### Command to open shell in container

```docker exec -it ve_db_ctr bash```


