#!/usr/bin/env python3
"""
Script to check whether cached counts are OK
"""

import argparse
import os
import sys

import psycopg2

DB_NAME = os.getenv('POSTGRESQL_DATABASE', 'vulnerability')
DB_USER = os.getenv('POSTGRESQL_USER', 've_db_admin')
DB_PASS = os.getenv('POSTGRESQL_PASSWORD', 've_db_admin_pwd')
DB_HOST = os.getenv('POSTGRESQL_HOST', 'vulnerability-engine-database')
DB_PORT = int(os.getenv('POSTGRESQL_PORT', '5432'))


def check_account(cur, account_id, account_name):
    """Checks cachedcounts for given account"""
    v_print(1, 'Checking account {}'.format(account_name))

    passed = True
    cur.execute("""SELECT cm.id, cm.cve, cad.systems_affected FROM cve_metadata cm JOIN cve_account_data cad ON cm.id = cad.cve_id
                   WHERE cad.rh_account_id = %(account_id)s""", {'account_id': account_id})
    cves = cur.fetchall()
    for cve_id, cve_name, systems_affected in cves:
        v_print(2, 'Checking {}'.format(cve_name))
        cur.execute("""SELECT count(*) from system_vulnerabilities sv
                       LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                       WHERE sv.cve_id = %(cve_id)s AND sv.system_id IN
                       (SELECT id FROM system_platform WHERE rh_account_id = %(account_id)s AND opt_out = 'F' and stale = 'F')
                       AND (sv.when_mitigated IS NULL OR ir.active = 'T')""",
                    {'account_id': account_id, 'cve_id': cve_id})
        real_count = cur.fetchone()[0]
        if systems_affected != real_count:
            v_print(0, 'Counts does not match for {} in org {}: {} (cached) vs. {} (real)'.format(cve_name, account_name, systems_affected, real_count))
            passed = False

    cur.execute("""SELECT id, inventory_id, cve_count_cache FROM system_platform WHERE rh_account_id = %(account_id)s AND opt_out = 'F' AND stale = 'F'""",
                {'account_id': account_id})
    systems = cur.fetchall()

    for system_id, inventory_id, cached_count in systems:
        v_print(2, 'Checking system {}'.format(inventory_id))
        cur.execute("""SELECT count(*) FROM system_vulnerabilities sv
                       LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                       WHERE sv.system_id = %(system_id)s AND (sv.when_mitigated IS NULL OR ir.active = 'T')""", {'system_id': system_id})
        real_count = cur.fetchone()[0]
        if cached_count != real_count:
            v_print(0, 'Counts does not match for system {} in org {}: {} (cached) vs. {} (real)'.format(inventory_id, account_name, cached_count, real_count))
            passed = False

    v_print(1, 'Account {} OK'.format(account_name) if passed else 'Account {} NOT OK'.format(account_name))


def main():
    """Main function"""
    conn = psycopg2.connect(dbname=DB_NAME, user=DB_USER, password=DB_PASS, host=DB_HOST, port=DB_PORT)
    cur = conn.cursor()
    cur.execute("""SELECT id, name from rh_account""")
    accounts = cur.fetchall()
    for row in accounts:
        check_account(cur, row[0], row[1])
    cur.close()
    conn.close()


if __name__ == '__main__':
    # pylint: disable=invalid-name
    if not all((DB_NAME, DB_USER, DB_PASS, DB_HOST, DB_PORT)):
        sys.stderr.write('Missing DB credentials')
        sys.exit(1)

    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbosity', action='count',
                        help='increase output verbosity')

    args = parser.parse_args()

    verbosity = 0 if not args.verbosity else args.verbosity

    def _v_print(*verb_args):
        if verb_args[0] <= verbosity:
            print(verb_args[1])

    global v_print  # pylint: disable=global-at-module-level
    v_print = _v_print

    main()
