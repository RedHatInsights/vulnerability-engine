# -*- coding: utf-8 -*-
# pylint: disable=no-self-use
"""
Unit tests for evaulator module
"""
import asyncio
import logging
import pytest
import evaluator.evaluator as evaluator

from common.constants import remediation


TEST_TOPIC = "test_topic"


def empty_fun(*_, **__):
    """Empty function for mocking"""
    return True


async def empty_fun_async(*_, **__):
    """Empty function in async"""
    return True


class KafkaMsgMock:
    """Mock for kafka MSG"""

    def __init__(self, topic, value):
        self.topic = topic
        self.value = value


class DbPoolMock:
    """Db pool mock"""
    def acquire(self):
        """Mock for database pool"""


class ConnMock:
    """Connection mock"""
    def __init__(self, return_val):
        self.return_val = return_val

    async def fetchrow(self, *_, **__):
        """Fetchrow mock returning set value"""
        return self.return_val

    def transaction(self):
        """Transaction mock"""
        return self

    async def __aenter__(self):
        return self

    async def __aexit__(self, *_, **__):
        pass


class TestEvaluator:
    """Unit tests for vulnerability-evaluator."""

    # @staticmethod
    async def _get_vulnerabilities(self, asyncio_conn, pg_db_conn, cve, system_id: int, inventory_id: str, package_json: str, org_id: str):
        rh_account = 0
        opt_out = False
        stale = False
        transaction = asyncio_conn.transaction()
        await transaction.start()
        await evaluator.evaluate_vmaas([system_id, inventory_id, package_json, rh_account, opt_out, stale], org_id, asyncio_conn)
        await transaction.commit()
        cur = pg_db_conn.cursor()
        sql = f"select sv.id, sv.system_id, cm.cve, sv.first_reported, sv.when_mitigated, sv.status_id, \
                       sv.advisory_available, sv.remediation_type_id \
                from system_vulnerabilities sv join cve_metadata cm on sv.cve_id = cm.id \
                where system_id = {system_id} and rh_account_id = {rh_account}"
        if cve:
            sql += f" and cm.cve = '{cve}'"
        cur.execute(sql)
        return cur.fetchall()

    @pytest.mark.asyncio
    async def test_mitigation_1_single(self, asyncio_conn, pg_db_conn):
        """Test that unmitigated CVE becomes mitigated."""
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, "CVE-2017-7", system_id=3,
            inventory_id="00000000-0000-0000-0000-000000000003",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": ["bash-0:4.2.46-20.el7_2.x86_64"]}',
            org_id="0",
        )
        assert len(rows) == 1
        when_mitigated = rows[0][4]
        assert when_mitigated

    @pytest.mark.asyncio
    async def test_mitigation_2_non_exist(self, asyncio_conn, pg_db_conn):
        """Test that unmitigated CVE becomes mitigated."""
        # non existing package implies no CVEs
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, "CVE-2017-6", 4, "00000000-0000-0000-0000-000000000004",
            '{"repository_list": ["rhel-7-server-rpms"], "package_list": ["non_exist"]}', "0",
        )
        assert len(rows) == 1
        when_mitigated = rows[0][4]
        assert when_mitigated

    @pytest.mark.asyncio
    async def test_mitigation_3_empty(self, asyncio_conn, pg_db_conn):
        """Test that unmitigated CVE becomes mitigated."""
        # no packages implies no CVEs
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve="CVE-2017-7", system_id=5,
            inventory_id="00000000-0000-0000-0000-000000000005",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": []}',
            org_id="0",
        )
        assert len(rows) == 1
        when_mitigated = rows[0][4]
        assert when_mitigated

    @pytest.mark.asyncio
    async def test_double_mitigation(self, asyncio_conn, pg_db_conn):
        """Test that unmitigated CVE becomes mitigated only once and timestamp is not updated twice."""
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve="CVE-2017-8", system_id=3,
            inventory_id="00000000-0000-0000-0000-000000000003",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": ["bash-0:4.2.46-20.el7_2.x86_64"]}',
            org_id="0",
        )
        assert len(rows) == 1
        when_mitigated_1 = rows[0][4]
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve="CVE-2017-8", system_id=3,
            inventory_id="00000000-0000-0000-0000-000000000003",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": ["bash-0:4.2.46-20.el7_2.x86_64"]}',
            org_id="0",
        )
        assert len(rows) == 1
        when_mitigated_2 = rows[0][4]
        assert when_mitigated_1 == when_mitigated_2

    @pytest.mark.asyncio
    async def test_unmitigation_1(self, asyncio_conn, pg_db_conn):
        """Test that mitigated CVE becomes unmitigated."""
        # send package needed to fix
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve="CVE-2018-5", system_id=5,
            inventory_id="00000000-0000-0000-0000-000000000005",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": ["bash-0:4.2.46-20.el7_2.x86_64"]}',
            org_id="0",
        )
        assert len(rows) == 1
        when_mitigated = rows[0][4]
        assert when_mitigated is None

    @pytest.mark.asyncio
    async def test_evaluate_vmaas_1_single(self, asyncio_conn, pg_db_conn):
        """Test evaluation of CVEs from VMaaS."""
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve=None, system_id=0,
            inventory_id="00000000-0000-0000-0000-000000000000",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": ["bash-0:4.2.46-20.el7_2.x86_64"]}',
            org_id="0",
        )
        assert len(rows) == 4
        cves = [row[2] for row in rows]
        new_cves = ("CVE-2018-5", "CVE-2016-0634", "CVE-2016-9401", "CVE-2018-6")
        for new_cve in new_cves:   # check all new_cves are associated with that system
            assert new_cve in cves
        for row in rows:           # check all new_cves are not mitigated
            when_mitigated = row[4]
            assert when_mitigated is None
            if row[2] == "CVE-2018-6":  # manually fixable
                assert not row[6]  # advisory_available = False
                assert row[7] == remediation.MANUAL.value
            else:
                assert row[6]  # advisory_available = True
                assert row[7] == remediation.PLAYBOOK.value

    @pytest.mark.asyncio
    async def test_evaluate_vmaas_2_empty(self, asyncio_conn, pg_db_conn):
        """Test evaluation of CVEs from VMaaS."""

        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve=None, system_id=1,
            inventory_id="00000000-0000-0000-0000-000000000001",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": []}',
            org_id="0",
        )
        assert rows == []

    @pytest.mark.asyncio
    async def test_evaluate_vmaas_3_non_exist(self, asyncio_conn, pg_db_conn):
        """Test evaluation of CVEs from VMaaS."""
        rows = await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve=None, system_id=2,
            inventory_id="00000000-0000-0000-0000-000000000002",
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": ["non_exist"]}',
            org_id="0",
        )
        assert len(rows) == 4
        cves = [row[2] for row in rows]
        new_cves = ("CVE-2018-5", "CVE-2016-0634", "CVE-2016-9401", "CVE-2018-6")
        for new_cve in new_cves:   # check all new_cves are associated with that system
            assert new_cve in cves
        for row in rows:           # check all new_cves are not mitigated
            when_mitigated = row[4]
            assert when_mitigated is None

    @pytest.mark.asyncio
    async def test_evaluate_vmaas_4_force_400(self, asyncio_conn, pg_db_conn, caplog):
        """Test evaluation of CVEs from VMaaS."""
        caplog.clear()
        inventory_id = "00000000-0000-0000-0000-000000000000"
        await self._get_vulnerabilities(
            asyncio_conn, pg_db_conn, cve=None, system_id=0, inventory_id=inventory_id,
            package_json='{"repository_list": ["rhel-7-server-rpms"], "package_list": ["FORCE_CODE_400"]}',
            org_id="0",
        )
        joined_logs = "".join([rec.message for rec in caplog.records])
        assert "Error during request to VMaaS endpoint" in joined_logs
        assert f"Skipping evaluation of {inventory_id} due to VMaaS errors." in joined_logs

    def test_main(self, monkeypatch, caplog, event_loop):
        """Test main"""
        monkeypatch.setattr(evaluator, "run", empty_fun_async)
        evaluator.MAIN_LOOP = event_loop
        evaluator.CFG.minimal_schema = 0
        with caplog.at_level(logging.INFO):
            evaluator.main()

        assert "Opening port" in caplog.messages[0]
        assert "Using BOOTSTRAP_SERVERS" in caplog.messages[2]
        assert "Using GROUP_ID" in caplog.messages[3]
        assert "Using TOPICS" in caplog.messages[4]

    @pytest.mark.asyncio
    async def test_process_msg_wrong_json(self, caplog):
        """Test msg with wrong json"""
        msg = KafkaMsgMock(TEST_TOPIC, "wrong_json".encode("utf-8"))

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Unable to parse message" in caplog.messages[0]

    @pytest.mark.asyncio
    async def test_process_msg_wrong_topic(self, caplog):
        """Test msg with invalid topic"""
        msg = KafkaMsgMock(TEST_TOPIC, "{}".encode("utf-8"))

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Received message on unsupported topic" in caplog.messages[0]

    @pytest.mark.asyncio
    async def test_process_msg_missing_type(self, caplog):
        """Test msg with missing type"""
        evaluator.CFG.evaluator_topics.append(TEST_TOPIC)
        msg = KafkaMsgMock(TEST_TOPIC, "{}".encode("utf-8"))

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Received message is missing type field" in caplog.messages[0]

    @pytest.mark.asyncio
    async def test_process_msg_wrong_type(self, caplog):
        """Test msg with wrong type"""
        evaluator.CFG.evaluator_topics.append(TEST_TOPIC)
        msg = KafkaMsgMock(TEST_TOPIC, """{
            "type": "wrong"
        }""".encode("utf-8"))

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Received unknown message type" in caplog.messages[0]

    @pytest.mark.asyncio
    async def test_process_msg_upload(self, caplog, monkeypatch):
        """Test msg with upload (new system) type"""
        evaluator.CFG.evaluator_topics.append(TEST_TOPIC)
        evaluator.MAIN_LOOP = asyncio.get_event_loop()

        evaluator.DB_POOL = DbPoolMock()
        monkeypatch.setattr(evaluator.DB_POOL, "acquire", lambda: ConnMock(True))

        msg = KafkaMsgMock(TEST_TOPIC, """{
            "type": "upload_new_file",
            "host": {
                "id": 0
            }
        }""".encode("utf-8"))
        monkeypatch.setattr(evaluator, "send_msg_to_payload_tracker", empty_fun)
        monkeypatch.setattr(evaluator, "evaluate_vmaas", empty_fun_async)

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Received message type: upload_new_file" in caplog.messages[0]

    @pytest.mark.asyncio
    async def test_process_msg_nonex_system(self, caplog, monkeypatch):
        """Test msg with upload type, but with non existing system"""
        evaluator.CFG.evaluator_topics.append(TEST_TOPIC)

        evaluator.DB_POOL = DbPoolMock()
        monkeypatch.setattr(evaluator.DB_POOL, "acquire", lambda: ConnMock(None))

        msg = KafkaMsgMock(TEST_TOPIC, """{
            "type": "upload_new_file",
            "host": {
                "id": 99999
            }
        }""".encode("utf-8"))
        monkeypatch.setattr(evaluator, "send_msg_to_payload_tracker", empty_fun)
        monkeypatch.setattr(evaluator, "evaluate_vmaas", empty_fun_async)

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Received message type: upload_new_file" in caplog.messages[0]
        assert "System with inventory_id not found in DB" in caplog.messages[1]

    @pytest.mark.asyncio
    async def test_process_msg_re_eval(self, caplog, monkeypatch):
        """Test msg with re-evaluate_system type"""
        evaluator.CFG.evaluator_topics.append(TEST_TOPIC)
        evaluator.MAIN_LOOP = asyncio.get_event_loop()

        evaluator.DB_POOL = DbPoolMock()
        monkeypatch.setattr(evaluator.DB_POOL, "acquire", lambda: ConnMock(True))

        msg = KafkaMsgMock(TEST_TOPIC, """{
            "type": "re-evaluate_system",
            "host": {
                "id": 0
            }
        }""".encode("utf-8"))
        monkeypatch.setattr(evaluator, "send_msg_to_payload_tracker", empty_fun)
        monkeypatch.setattr(evaluator, "evaluate_vmaas", empty_fun_async)

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Received message type: re-evaluate_system" in caplog.messages[0]

    @pytest.mark.asyncio
    async def test_process_msg_re_eval_nonex(self, caplog, monkeypatch):
        """Test msg with re-evaluate_system type, but with nonexisting system"""
        evaluator.CFG.evaluator_topics.append(TEST_TOPIC)
        evaluator.MAIN_LOOP = asyncio.get_event_loop()

        evaluator.DB_POOL = DbPoolMock()
        monkeypatch.setattr(evaluator.DB_POOL, "acquire", lambda: ConnMock(None))

        msg = KafkaMsgMock(TEST_TOPIC, """{
            "type": "re-evaluate_system",
            "host": {
                "id": 99999
            }
        }""".encode("utf-8"))
        monkeypatch.setattr(evaluator, "send_msg_to_payload_tracker", empty_fun)
        monkeypatch.setattr(evaluator, "evaluate_vmaas", empty_fun_async)

        with caplog.at_level(logging.INFO):
            await evaluator.MAX_MESSAGES_SEMAPHORE.acquire()
            await evaluator.process_message(msg)

        assert "Received message type: re-evaluate_system" in caplog.messages[0]
        assert "System with inventory_id not found in DB" in caplog.messages[1]
