# pylint: disable=no-self-use,no-method-argument
"""
Unit tests fortaskomatic
"""

import asyncio

from psycopg2.extensions import connection
import pytest
from tornado.httpclient import HTTPClientError

import taskomatic.jobs.common as tjc
from taskomatic import taskomatic

TASKOMATIC_JOBS = ["db_metrics", "delete_systems", "rules_git_sync", "stale_systems", "usage_metrics"]


async def empty_fun():
    """Empty mock for testing"""


class TestTaskomatic:
    """
    Class holding all tests
    """

    @staticmethod
    def test_get_conn(monkeypatch, pg_db_mod):
        """Test obtaining DB connection"""
        class CustomCFG:
            """Custom config class to override DB config with"""

            def __init__(self, pg_db_mod):
                dsn = pg_db_mod.dsn()
                self.db_name = dsn['database']
                self.db_user = dsn['user']
                self.db_pass = None
                self.db_host = dsn['host']
                self.db_port = dsn['port']
                self.db_ssl_mode = 'disable'
                self.db_ssl_root_cert_path = '/dev/null'

        custom_cfg = CustomCFG(pg_db_mod)
        monkeypatch.setattr(tjc, 'CFG', custom_cfg)

        conn = tjc.get_conn()
        assert isinstance(conn, connection)
        assert conn.closed == 0

        cur = conn.cursor()
        cur.execute("""SELECT COUNT(*) FROM system_platform""")
        res = cur.fetchone()[0]
        assert res == 33

        cur.close()
        conn.close()

        assert conn.closed == 1

    def test_main(self, monkeypatch):
        """Test main, job and taskomatic setup"""
        monkeypatch.setattr(taskomatic.SCHEDULER, "start", lambda: None)

        class LoopMock:
            """Event loop mock"""
            loop = asyncio.get_event_loop()

            def run_until_complete(self, *args, **kwargs):
                """run_until_complete mock"""
                return self.loop.run_until_complete(*args, **kwargs)

            def add_signal_handler(self, *args, **kwargs):
                """add_signal_handler mock"""
                self.loop.add_signal_handler(*args, **kwargs)

            def run_forever(self, *_, **__):
                """Dont run forever, just mock for tests"""

        # Setup to not loop the tests
        monkeypatch.setattr(taskomatic, "MAIN_LOOP", LoopMock())
        monkeypatch.setattr(taskomatic, "a_ensure_minimal_schema_version", empty_fun)
        taskomatic.JOBS = "stale_systems:5,delete_systems:30".split(",")

        taskomatic.main()

        jobs = taskomatic.SCHEDULER.get_jobs()
        for job in jobs:
            assert job.id in TASKOMATIC_JOBS


class TestTaskomaticApp:
    """Test taskomatic App handlers"""

    @pytest.mark.asyncio
    async def test_run_job(self, taskomatic_server, http_client):
        """Test run job handler"""
        response = await http_client.fetch("%s%s" % (taskomatic_server, "/api/v1/run/stale_systems"), method="PUT", body="{}")
        assert response.code == 200

    @pytest.mark.asyncio
    async def test_run_job_wrong(self, taskomatic_server, http_client):
        """Test run job handler with wrong job"""
        with pytest.raises(HTTPClientError):
            await http_client.fetch("%s%s" % (taskomatic_server, "/api/v1/run/nonexisting_job"), method="PUT", body="{}")
