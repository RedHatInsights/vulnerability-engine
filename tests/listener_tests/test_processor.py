"""
Test listener processor suite
"""
# pylint: disable=line-too-long,protected-access,no-self-use,invalid-name
# noqa: E501

import json
import uuid
import hashlib
import pytest

from listener.common import QueueItem, InventoryMsgType, ImportStatus

PACKAGE_LIST = ['package-a', 'package-b']
REPO_LIST = ['repo-c', 'repo-d']
REPO_PATHS = ["/content/dist/rhel8/rhui/8/x86_64/baseos/os", "/content/dist/rhel8/rhui/8.4/x86_64/appstream/os"]
MODULES_LIST = ['module-e', 'module-f']
BASEARCH = "x86_64"
RESULT_JSON = '{"package_list": ["package-a", "package-b"], ' \
              '"repository_list": ["repo-c", "repo-d"], ' \
              '"repository_paths": ["/content/dist/rhel8/rhui/8/x86_64/baseos/os", ' \
              '"/content/dist/rhel8/rhui/8.4/x86_64/appstream/os"], ' \
              '"extended": true, '\
              '"modules_list": ["module-e", "module-f"], '\
              '"basearch": "x86_64"}'

A_SYSTEM = {'vmaas-json': 'NEW-JSON', 'host': {'id': '8e08be35-8419-4472-8fda-9fbb706e6d71',
                                               'account': 'NEW-ACCT',
                                               'org_id': 'NEW-ORG',
                                               'display_name': 'example.com',
                                               'stale_timestamp': '2020-01-09T10:17:33.881280+00:00',
                                               'stale_warning_timestamp': '2020-01-16T10:17:33.881280+00:00',
                                               'culled_timestamp': '2020-01-23T10:17:33.881280+00:00'},
            'platform_metadata': {'url': 'NEW-URL'}}
A_SYSTEM_DELETE = {'id': '8e08be35-8419-4472-8fda-9fbb706e6d71', 'account': 'NEW-ACCT', 'org_id': 'NEW-ORG'}
A_SYSTEM_UPDATE = {'host': {'id': '8e08be35-8419-4472-8fda-9fbb706e6d71', 'display_name': 'new.example.com'}}
TESTING_SYSTEM = "42e1f448-11da-4cc3-9f67-fc8c04830c44"

INVENTORY_MSG = {
    "host": {
        "org_id": "0",
        "account": "0",
        "id": "8e08be35-8419-4472-8fda-9fbb706e6d71",
        "display_name": "system",
        "system_profile": {
            "installed_packages": ["package-1", "package-2"],
            "basearch": "x86_64",
            "rhsm": {
                "version": "7",
                "releasever": "10",
            },
            "yum_repos": [
                {
                    "enabled": True,
                    "id": "repo-1",
                    "mirrorlist": "https://rhui.redhat.com/pulp/mirror/content/dist/rhel8/rhui/8.4/x86_64/baseos/os"
                },
                {
                    "enabled": False,
                    "id": "repo-2",
                },
            ],
            "dnf_modules": [
                {
                    "name": "module-1",
                    "stream": "rh7",
                },
                {
                    "name": "module-2",
                    "stream": "rh7"
                },
            ],
        },
    },
    "platform_metadata": {
        "url": "s3.com"
    }
}

INVENTORY_DELETE_MSG = {
    "type": "delete",
    "id": "8e08be35-8419-4472-8fda-9fbb706e6d71",
    "org_id": "0",
    "account": "0",
}

ADVISOR_MSG = {
    "input": {
        "platform_metadata": {
        },
        "host": {
            "org_id": "0",
            "account": "0",
            "id": "8e08be35-8419-4472-8fda-9fbb706e6d71",
            "display_name": "system",
        },
    },
    "results": {
        "reports": [
            {
                "rule_id": "CVE_2019_11135_cpu_taa|CVE_2019_11135_CPU_TAA_KERNEL",
                "type": "rule",
                "details": {
                    "cves": {
                        "CVE-2020-1": False,
                        "CVE-2019-1": False,
                        "CVE-2021-1": "Module not enabled.",
                    },
                },
            },
        ],
        "pass": [
            {
                "pass_id": "CVE_2018_3639_cpu_kernel|All CVEs passsed.",
                "type": "pass",
                "details": {
                    "cves": {
                        "CVE-2022-1": "System is not running vulnerable kernel.",
                        "CVE-2023-1": "System is not running vulnerable kernel.",
                    },
                },
            },
        ],
    },
}

ADVISOR_MSG_HITS = {
    "CVE-2020-1": {
        "rule_id": "CVE_2019_11135_cpu_taa|CVE_2019_11135_CPU_TAA_KERNEL",
        "details": json.dumps(ADVISOR_MSG["results"]["reports"][0]["details"]),
    },
    "CVE-2019-1": {
        "rule_id": "CVE_2019_11135_cpu_taa|CVE_2019_11135_CPU_TAA_KERNEL",
        "details": json.dumps(ADVISOR_MSG["results"]["reports"][0]["details"]),
    },
    "CVE-2021-1": {
        "rule_id": "CVE_2019_11135_cpu_taa|CVE_2019_11135_CPU_TAA_KERNEL",
        "mitigation_reason": ADVISOR_MSG["results"]["reports"][0]["details"]["cves"]["CVE-2021-1"]
    },
}

ADVISOR_MSG_PASSES = {
    "CVE-2022-1": {
        "rule_id": "CVE_2018_3639_cpu_kernel",
        "mitigation_reason": ADVISOR_MSG["results"]["pass"][0]["details"]["cves"]["CVE-2022-1"]
    },
    "CVE-2023-1": {
        "rule_id": "CVE_2018_3639_cpu_kernel",
        "mitigation_reason": ADVISOR_MSG["results"]["pass"][0]["details"]["cves"]["CVE-2023-1"],
    }
}

VMAAS_REQ = {
    "package_list": INVENTORY_MSG["host"]["system_profile"]["installed_packages"],
    "repository_list": ["repo-1"],
    "repository_paths": ["/content/dist/rhel8/rhui/8.4/x86_64/baseos/os"],
    "extended": True,
    "modules_list": [{"module_name": "module-1", "module_stream": "rh7"}, {"module_name": "module-2", "module_stream": "rh7"}],
    "basearch": "x86_64",
    "releasever": "7",
}

ORG_ID = "0"


class TestProcessor:
    """Test listener processor component"""

    async def _import_system(self, conn, processor) -> int:
        """Test helper function for importing system"""
        db_fields = {
            "inventory_id": str(uuid.uuid4()),
            "display_name": "system",
        }
        result, system_id = await processor._db_import_system(conn, db_fields, ORG_ID, None)
        if ImportStatus.FAILED in result:
            raise Exception("Cannot import system")
        return system_id, db_fields["inventory_id"]

    def test_format_vmaas_request(self, processor):
        """Test vmaas_json building function"""
        req = processor._format_vmaas_req(PACKAGE_LIST, REPO_LIST, BASEARCH, modules_list=MODULES_LIST, repo_paths=REPO_PATHS)
        assert req == RESULT_JSON

    def test_format_repo_path(self, processor):
        """Test system repository paths formatting"""
        assert processor._format_repo_path(None) is None
        assert processor._format_repo_path("") is None
        assert processor._format_repo_path("https://rhui.redhat.com[") is None
        assert processor._format_repo_path("https://rhui.redhat.com/") is None

        assert processor._format_repo_path(
            "https://rhui.redhat.com/pulp/mirror/content/dist/rhel8/rhui/8.4/x86_64/baseos/os",
        ) == "/content/dist/rhel8/rhui/8.4/x86_64/baseos/os"

        assert processor._format_repo_path(
            "https://rhui.redhat.com/pulp/mirror/content/dist/rhel8/rhui/$releasever/$basearch/baseos/os",
            basearch="x86_64", releasever="8.4"
        ) == "/content/dist/rhel8/rhui/8.4/x86_64/baseos/os"

        assert processor._format_repo_path(
            "https://rhui.redhat.com/pulp/content/eus/rhel8/rhui/8.4/x86_64/baseos/os",
        ) == "/content/eus/rhel8/rhui/8.4/x86_64/baseos/os"

    def test_parse_inventory_system_data(self, processor):
        """Test parsing inventory system data"""
        item = QueueItem(INVENTORY_MSG, InventoryMsgType.UPLOAD, None)
        vmaas_request, repo_list = processor._parse_inventory_system_data(item)

        assert repo_list == ["repo-1"]
        assert vmaas_request == json.dumps(VMAAS_REQ)

    @pytest.mark.asyncio
    async def test_db_import_system(self, processor_with_db):
        """Test importing of system to DB"""
        db_fields = {
            "inventory_id": "ac5d6655-03c6-41a7-8895-f4fb855b374a",
            "display_name": "system-0",
            "s3_url": "url",
            "vmaas_json": "{}",
            "json_checksum": "0"
        }

        async with processor_with_db.db_pool.acquire() as conn:
            async with conn.transaction():
                result, system_id = await processor_with_db._db_import_system(conn, db_fields, ORG_ID, None)
                assert ImportStatus.INSERTED in result
                assert system_id

    @pytest.mark.asyncio
    async def test_db_import_repos(self, processor_with_db):
        """Test importing of repositories to DB"""
        repo_list = ["repo-3", "repo-4", "repo-5"]
        async with processor_with_db.db_pool.acquire() as conn:
            async with conn.transaction():
                repo_ids = await processor_with_db._db_import_repos(conn, repo_list)
        assert len(repo_list) == len(repo_ids)

    @pytest.mark.asyncio
    async def test_db_import_system_repos(self, processor_with_db):
        """Test importing of link between system and repos"""
        repo_list = ["repo-6", "repo-7"]
        async with processor_with_db.db_pool.acquire() as conn:
            async with conn.transaction():
                system_id, _ = await self._import_system(conn, processor_with_db)
                await processor_with_db._db_import_repos(conn, repo_list)
                new_inserted = await processor_with_db._db_import_system_repos(conn, repo_list, system_id)
        assert len(new_inserted) == len(repo_list)

    @pytest.mark.asyncio
    async def test_db_unlink_system_repos(self, processor_with_db):
        """Test removing link between system and repos"""
        repo_list = ["repo-7", "repo-8"]
        deleted_system_repo = ["repo-7"]
        async with processor_with_db.db_pool.acquire() as conn:
            async with conn.transaction():
                system_id, _ = await self._import_system(conn, processor_with_db)
                await processor_with_db._db_import_repos(conn, repo_list)
                await processor_with_db._db_import_system_repos(conn, repo_list, system_id)
                unlinked_repos = await processor_with_db._db_unlink_system_repos(conn, deleted_system_repo, system_id)
        assert len(unlinked_repos) == len(deleted_system_repo)

    def test_prepare_db_insert(self, processor):
        """Test dynamic DB insert query formatter"""
        fields = {
            "inventory_id": "1337",
            "display_name": "system",
            "vmaas_json": "{}"
        }
        columns, formats, upsert, values = processor._prepare_db_insert(fields)
        assert columns == "inventory_id,display_name,vmaas_json"
        assert formats == "$1,$2,$3"
        assert upsert == "inventory_id = EXCLUDED.inventory_id,display_name = EXCLUDED.display_name,vmaas_json = EXCLUDED.vmaas_json"
        assert values == ["1337", "system", "{}"]

    def test_parse_inventory_message_db_fields(self, processor):
        """Test parsing of inventory message DB fields"""
        item = QueueItem(INVENTORY_MSG, InventoryMsgType.UPLOAD, None)
        vmaas_json = '{"vmaas_json":"json"}'
        json_csum = hashlib.sha256(vmaas_json.encode("utf-8")).hexdigest()
        fields = {}

        processor._parse_inventory_db_fields(fields, item, vmaas_json)

        assert fields["s3_url"] == INVENTORY_MSG["platform_metadata"]["url"]
        assert fields["inventory_id"] == INVENTORY_MSG["host"]["id"]
        assert fields["vmaas_json"] == vmaas_json
        assert fields["json_checksum"] == json_csum
        assert fields["display_name"] == INVENTORY_MSG["host"]["display_name"]

    def test_parse_advisor_message_db_fields(self, processor):
        """Test parsing of advisor message DB fields"""
        item = QueueItem(None, None, ADVISOR_MSG)
        fields = {}

        processor._parse_advisor_db_fields(fields, item)

        assert fields["display_name"] == ADVISOR_MSG["input"]["host"]["display_name"]
        assert fields["inventory_id"] == ADVISOR_MSG["input"]["host"]["id"]

        rule_results = fields["rule_results"]
        rule_dict = json.loads(rule_results)

        advisor_csum = hashlib.sha256(rule_results.encode("utf-8")).hexdigest()
        assert fields["advisor_checksum"] == advisor_csum

        assert rule_dict["rule_hits"] == ADVISOR_MSG_HITS
        assert rule_dict["rule_passes"] == ADVISOR_MSG_PASSES

    def test_parse_org_id(self, processor):
        """Test parsing of org_id from messages"""
        item_both = QueueItem(INVENTORY_MSG, InventoryMsgType.UPLOAD, ADVISOR_MSG)
        item_inventory = QueueItem(INVENTORY_MSG, InventoryMsgType.UPLOAD, None)
        item_advisor = QueueItem(None, InventoryMsgType.UNKNOWN, ADVISOR_MSG)

        org_id_both, acc_both = processor._parse_org_id(item_both)
        org_id_inv, acc_inv = processor._parse_org_id(item_inventory)
        org_id_adv, acc_adv = processor._parse_org_id(item_advisor)

        assert org_id_both == org_id_inv == org_id_adv
        assert acc_both == acc_inv == acc_adv

    @pytest.mark.asyncio
    async def test_process_upload_both(self, monkeypatch, processor_with_db):
        """Test upload processing when both messages arrive"""
        inv_msg = INVENTORY_MSG.copy()
        adv_msg = ADVISOR_MSG.copy()
        inventory_id = str(uuid.uuid4())
        inv_msg["host"]["id"] = inventory_id
        adv_msg["input"]["host"]["id"] = inventory_id

        item = QueueItem(inv_msg, InventoryMsgType.UPLOAD, ADVISOR_MSG)

        was_sent_for_evaluation = False

        def _mock(*_, **__):
            nonlocal was_sent_for_evaluation
            was_sent_for_evaluation = True

        monkeypatch.setattr(processor_with_db, "_send_for_evaluation", _mock)

        await processor_with_db._process_upload(item)

        async with processor_with_db.db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM system_platform WHERE inventory_id = $1", INVENTORY_MSG["host"]["id"])

        assert str(row["inventory_id"]) == inventory_id
        assert row["s3_url"] == INVENTORY_MSG["platform_metadata"]["url"]
        assert row["vmaas_json"] is not None
        assert row["json_checksum"] is not None
        assert row["advisor_checksum"] is not None
        assert row["rule_results"] is not None
        assert was_sent_for_evaluation

    @pytest.mark.asyncio
    async def test_process_upload_inventory(self, monkeypatch, processor_with_db):
        """Test upload procesing when only inventory message arrives"""
        inv_msg = INVENTORY_MSG.copy()
        inventory_id = str(uuid.uuid4())
        inv_msg["host"]["id"] = inventory_id

        item = QueueItem(inv_msg, InventoryMsgType.UPLOAD, None)

        was_sent_for_evaluation = False

        def _mock(*_, **__):
            nonlocal was_sent_for_evaluation
            was_sent_for_evaluation = True

        monkeypatch.setattr(processor_with_db, "_send_for_evaluation", _mock)

        await processor_with_db._process_upload(item)

        async with processor_with_db.db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM system_platform WHERE inventory_id = $1", inventory_id)

        assert str(row["inventory_id"]) == inventory_id
        assert row["s3_url"] is not None
        assert row["vmaas_json"] is not None
        assert row["json_checksum"] is not None
        assert row["advisor_checksum"] is None
        assert row["rule_results"] is None
        assert was_sent_for_evaluation

    @pytest.mark.asyncio
    async def test_process_upload_advisor(self, monkeypatch, processor_with_db):
        """Test upload processing when only advisor msg arrives"""
        adv_msg = ADVISOR_MSG.copy()
        inventory_id = str(uuid.uuid4())
        adv_msg["input"]["host"]["id"] = inventory_id

        item = QueueItem(None, InventoryMsgType.UNKNOWN, adv_msg)

        was_sent_for_evaluation = False

        def _mock(*_, **__):
            nonlocal was_sent_for_evaluation
            was_sent_for_evaluation = True

        monkeypatch.setattr(processor_with_db, "_send_for_evaluation", _mock)

        await processor_with_db._process_upload(item)

        async with processor_with_db.db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM system_platform WHERE inventory_id = $1", inventory_id)

        assert str(row["inventory_id"]) == inventory_id
        assert row["s3_url"] is None
        assert row["vmaas_json"] is None
        assert row["json_checksum"] is None
        assert row["advisor_checksum"] is not None
        assert row["rule_results"] is not None
        assert was_sent_for_evaluation

    @pytest.mark.asyncio
    async def test_process_inventory_delete(self, processor_with_db):
        """Test processing of inventory delete"""
        async with processor_with_db.db_pool.acquire() as conn:
            system_id, inventory_id = await self._import_system(conn, processor_with_db)

        msg = INVENTORY_DELETE_MSG.copy()
        msg["id"] = inventory_id

        item = QueueItem(msg, InventoryMsgType.DELETE, None)

        await processor_with_db._process_inventory_delete(item)

        async with processor_with_db.db_pool.acquire() as conn:
            row = await conn.fetchrow("SELECT * FROM system_platform WHERE id = $1", system_id)
        assert row["when_deleted"] is not None
