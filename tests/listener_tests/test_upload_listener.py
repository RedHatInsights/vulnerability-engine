# -*- coding: utf-8 -*-
# pylint: disable=no-self-use
"""
Unit tests for listener module
"""
import asyncio
from concurrent.futures import ThreadPoolExecutor
import os
import logging
import tempfile

import pytest

import listener.upload_listener
from listener.upload_listener import format_vmaas_request, db_import_system, process_upload, LOGGER, \
    terminate, UPLOAD_QUEUE, EVALUATOR_QUEUE, on_thread_done, download_archive, parse_archive
from common.mqueue import MQWriter

# We should refactor upload_listener to be a class where db and other things
# are initialized in __init__() method.  This would allow us to override
# those things in unit tests here.

PACKAGE_LIST = ['package-a', 'package-b']
REPO_LIST = ['repo-c', 'repo-d']
MODULES_LIST = ['module-e', 'module-f']
RESULT_JSON = '{"package_list": ["package-a", "package-b"], ' \
              '"repository_list": ["repo-c", "repo-d"], ' \
              '"modules_list": ["module-e", "module-f"]}'

A_SYSTEM = {'inv-id': 'NEW-ID', 'rh-acct': 'NEW-ACCT', 's3-url': 'NEW-URL',
            'vmaas-json': 'NEW-JSON', 'managed': True}

class TestUploadListner:
    """Unit tests for vulnerability-listener."""

    @pytest.mark.asyncio
    async def test_terminate(self):
        """test_terminate"""
        loop = asyncio.new_event_loop()
        await terminate(0, loop)
        assert not loop.is_running()
        assert not UPLOAD_QUEUE.connected
        assert not EVALUATOR_QUEUE.connected

    def test_on_thread_done(self, caplog):
        "test_on_thread_done"
        with caplog.at_level(logging.ERROR):
            with ThreadPoolExecutor(max_workers=1) as executor:
                future_ok = executor.submit(lambda: True)
                future_ok.add_done_callback(on_thread_done)
        assert not caplog.records # empty log
        caplog.clear()

        with caplog.at_level(logging.ERROR):
            with ThreadPoolExecutor(max_workers=1) as executor:
                future_fail = executor.submit(lambda: 1/0)
                future_fail.add_done_callback(on_thread_done)
        assert caplog.records # not empty log
        caplog.clear()

    def test_format_vmaas_request(self):
        """test_format_vmaas_request"""
        result = format_vmaas_request(PACKAGE_LIST, repo_list=REPO_LIST, modules_list=MODULES_LIST)
        assert result
        assert result == RESULT_JSON

    def test_download_archive(self):
        """test_download_archive"""
        download_server_host = os.getenv("DOWNLOAD_SERVER_HOST")
        with tempfile.NamedTemporaryFile(delete=True) as tmp_file:
            success = download_archive("%s/api/v1/download/insights-archive.tar.gz" % download_server_host, tmp_file)
        assert success

    def test_download_archive_404(self):
        """test_download_archive_404"""
        download_server_host = os.getenv("DOWNLOAD_SERVER_HOST")
        with tempfile.NamedTemporaryFile(delete=True) as tmp_file:
            success = download_archive("%s/api/v1/download/insights-archive-404.tar.gz" % download_server_host,
                                       tmp_file)
        assert not success

    def test_download_archive_conn_err(self):
        """test_download_archive_conn_err"""
        download_server_host = "http://invalidhost:8080"
        with tempfile.NamedTemporaryFile(delete=True) as tmp_file:
            success = download_archive("%s/api/v1/download/insights-archive.tar.gz" % download_server_host,
                                       tmp_file)
        assert not success

    def test_parse_archive(self):
        """test_parse_archive"""
        download_server_host = os.getenv("DOWNLOAD_SERVER_HOST")
        vmaas_request = parse_archive({"url": "%s/api/v1/download/insights-archive.tar.gz" % download_server_host})
        assert vmaas_request is not None

    def test_parse_archive_no_pkgs(self):
        """test_parse_archive_no_pkgs"""
        download_server_host = os.getenv("DOWNLOAD_SERVER_HOST")
        vmaas_request = parse_archive({"url": "%s/api/v1/download/insights-archive-no-packages.tar.gz" % \
            download_server_host})
        assert vmaas_request is None

    def test_parse_archive_exception(self):
        """test_parse_archive_exception"""
        download_server_host = os.getenv("DOWNLOAD_SERVER_HOST")
        vmaas_request = parse_archive({"url": "%s/api/v1/download/non-archive.tar.gz" % \
            download_server_host})
        assert vmaas_request is None

    def test_import_system(self, pg_db_conn, caplog):
        """Test importing a system not-in-the-db, followed by same so it's-already-there"""
        # new system
        rtrn = db_import_system(pg_db_conn, A_SYSTEM['inv-id'], A_SYSTEM['rh-acct'], A_SYSTEM['s3-url'],
                                A_SYSTEM['vmaas-json'], A_SYSTEM['managed'])
        assert rtrn['inserted']
        assert rtrn['changed']
        assert not rtrn['updated']

        # And now it's an rtrn['updated'], but same json
        rtrn = db_import_system(pg_db_conn, A_SYSTEM['inv-id'], A_SYSTEM['rh-acct'], A_SYSTEM['s3-url'],
                                A_SYSTEM['vmaas-json'], A_SYSTEM['managed'])
        assert not rtrn['inserted']
        assert rtrn['updated']
        assert not rtrn['changed']

        # And now it's another rtrn['updated'], same json
        rtrn = db_import_system(pg_db_conn, A_SYSTEM['inv-id'], A_SYSTEM['rh-acct'], A_SYSTEM['s3-url'],
                                A_SYSTEM['vmaas-json'], A_SYSTEM['managed'])
        assert not rtrn['inserted']
        assert rtrn['updated']
        assert not rtrn['changed']

        # And now it's an rtrn['updated'], with diff json
        rtrn = db_import_system(pg_db_conn, A_SYSTEM['inv-id'], A_SYSTEM['rh-acct'], A_SYSTEM['s3-url'],
                                A_SYSTEM['vmaas-json'] + '-1', A_SYSTEM['managed'])
        assert not rtrn['inserted']
        assert rtrn['updated']
        assert rtrn['changed']

        # And try to import system with invalid inventory id
        with caplog.at_level(logging.ERROR):
            rtrn = db_import_system(pg_db_conn, None, A_SYSTEM['rh-acct'], A_SYSTEM['s3-url'],
                                    A_SYSTEM['vmaas-json'], A_SYSTEM['managed'])
        assert caplog.records[0].msg.startswith("Error importing system:")
        caplog.clear()

    def test_process_upload(self, pg_db_conn, monkeypatch, caplog):
        """Test to see that upload only sends eval-msgs on new systems and ones with new vmaas_json"""
        same_json = "{'diff': False}"
        diff_json = "{'diff': True}"
        upld_data = {'id': 'A-SYSTEM-ID', 'rh_account': 'AN-ACCOUNT', 'url': 'A-URL', 'satellite_managed': False}
        monkeypatch.setattr(MQWriter, 'send', lambda self, msg, loop: LOGGER.info('SENT'))
        monkeypatch.setattr(listener.upload_listener, 'parse_archive', lambda upld_dta: same_json)

        # first-upload - should send
        caplog.clear()
        with caplog.at_level(logging.INFO):
            process_upload(upld_data, pg_db_conn, None)
        assert caplog.records[0].msg == 'SENT'

        # re-upload - should not send
        caplog.clear()
        with caplog.at_level(logging.INFO):
            process_upload(upld_data, pg_db_conn, None)
        assert not caplog.records

        # same-id, diff-vmaas upload - should send
        monkeypatch.setattr(listener.upload_listener, 'parse_archive', lambda upld_dta: diff_json)
        caplog.clear()
        with caplog.at_level(logging.INFO):
            process_upload(upld_data, pg_db_conn, None)
        assert caplog.records[0].msg == 'SENT'
