# -*- coding: utf-8 -*-
"""
Methods for vulnerability API testing.
"""
import base64
import copy
import json
import re

import pytest
from box import Box

from .schemas import SCHEMA_MAP
from manager import main

URL_BASE = "/api/vulnerability/v1"

IDENTITY = {
    "identity": {
        "org_id": "0",
        "type": "User",
        "user": {
            "username": "jdoe@acme.com",
            "email": "jdoe@acme.com",
            "first_name": "john",
            "last_name": "doe",
            "is_active": True,
            "is_org_admin": False,
            "is_internal": False,
            "locale": "en_US",
        },
        "internal": {"org_id": 3_340_851, "auth_type": "basic-auth", "auth_time": 6300},
    },
    "entitlements": {"insights": {"is_entitled": True}},
}

TURNPIKE_IDENTITY = {
    "identity": {
        "associate": {
            "Role": ["vulnerability-admins"],
            "email": "jschmoe@redhat.com",
            "givenName": "Joseph",
            "rhatUUID": "01234567-89ab-cdef-0123-456789abcdef",
            "surname": "Schmoe",
        },
        "auth_type": "saml-auth",
        "type": "Associate",
    }
}

RH_IDENTITY_HEADER = {"x-rh-identity": base64.b64encode(json.dumps(IDENTITY).encode("utf-8"))}

RH_TURNPIKE_IDENTITY_HEADER = {"x-rh-identity": base64.b64encode(json.dumps(TURNPIKE_IDENTITY).encode("utf-8"))}


@pytest.mark.usefixtures("client_class")
class FlaskTestCase:
    """Base class for vulnerability engine manager test cases"""

    @staticmethod
    def _make_header(value):
        return {"x-rh-identity": base64.b64encode(json.dumps(value).encode("utf-8"))}

    @pytest.fixture
    def app(self):  # pylint: disable=no-self-use
        """Fixture for the application"""
        main.CFG.disable_rbac = True
        connexion_app = main.create_app({URL_BASE: "manager.spec.yaml", "": "manager.healthz.spec.yaml"}, wait_on_cyndi=False)
        return connexion_app.app

    def vfetch(self, path, turnpike=False, **kwargs):
        """Fetch method for vulnerability API."""
        path = "{}/{}".format(URL_BASE, path.lstrip("/"))
        headers = kwargs.get("headers") or {}
        if turnpike:
            headers.update(RH_TURNPIKE_IDENTITY_HEADER)
        else:
            headers.update(RH_IDENTITY_HEADER)
        kwargs["headers"] = headers
        if "data" in kwargs or "json" in kwargs:
            headers.update({"Content-type": "application/json"})
        method = kwargs.get("method", "get")
        if method.upper() == "PATCH":
            response = self.client.patch(path, **kwargs)  # pylint: disable=no-member
        elif method.upper() == "POST":
            response = self.client.post(path, **kwargs)  # pylint: disable=no-member
        elif method.upper() == "PUT":
            response = self.client.put(path, **kwargs)  # pylint: disable=no-member
        elif method.upper() == "DELETE":
            response = self.client.delete(path, **kwargs)  # pylint: disable=no-member
        else:
            response = self.client.get(path, **kwargs)  # pylint: disable=no-member
        return EngineResponse(response, method.upper(), path)

    def raw_get(self, path, **kwargs):
        """Raw get to an URI without headers"""
        response = self.client.get(path, **kwargs)  # pylint: disable=no-member
        return EngineResponse(response, "GET", path)


@pytest.mark.usefixtures("client_class")
class FlaskTestCaseAdmin(FlaskTestCase):
    """Base class for vulnerability engine manager admin test cases"""

    @pytest.fixture
    def app(self):  # pylint: disable=no-self-use
        """Fixture for the application"""
        connexion_app = main.create_app(
            {URL_BASE: "manager.admin.spec.yaml", "": "manager.admin.spec.yaml"}, wait_on_cyndi=False, init_status_cache=False
        )
        return connexion_app.app

    def vfetch(self, path, turnpike=True, **kwargs):
        """Fetch method for vulnerability API."""
        return super().vfetch(path, turnpike=turnpike, **kwargs)


class EngineResponse:
    """API response representation."""

    def __init__(self, response, method, path):
        self.raw = response
        self.body = self.load(response)
        self.method = method
        self.path = path

    @staticmethod
    def load(response):
        """Loads the response content."""
        parsed = None
        try:
            parsed = json.loads(response.data)
        # pylint: disable=broad-except
        except Exception:
            pass

        if not parsed and response.data:
            parsed = str(response.data, "utf-8")

        try:
            deep_parsed = copy.deepcopy(parsed)
            return Box(deep_parsed)
        except ValueError:
            return parsed or Box()

    def validate_schema(self):
        """Validates response against schema."""
        for (method, path), schema in SCHEMA_MAP.items():
            if method == self.method and re.search(path, self.path):
                schema.validate(self.body)
                break

    # pylint: disable=invalid-name
    @property
    def ok(self):
        """Checks if response has return code that indicates success."""
        if self.raw and self.raw.status_code >= 200 and self.raw.status_code < 400:
            return True
        return False

    def check_response(self, status_code=None, validate=True):
        """Asserts that the response HTTP status code and content is as expected."""
        if status_code:
            if self.raw.status_code != status_code:
                raise AssertionError("Expected status code {}, got {}".format(status_code, self.raw.status_code))
        elif not self.ok:
            raise AssertionError("Request failed with {}".format(self.raw.status_code))

        try:
            if self.ok and "errors" in self.body:
                raise AssertionError("Errors returned: {}".format(self.body.errors))
        except TypeError:
            pass

        if validate and self.ok:
            self.validate_schema()

        return self

    def __getattr__(self, name):
        return getattr(self.raw, name)

    def __repr__(self):
        return "<EngineResponse(raw={!r})>".format(self.raw)
