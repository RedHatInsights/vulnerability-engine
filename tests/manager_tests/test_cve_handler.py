"""Unit tests for cve_handler"""

# pylint: disable=missing-docstring,too-many-public-methods,invalid-name
import pytest

from .vuln_testcase import FlaskTestCase

INV_5_TAGS = [
    {"namespace": "vulnerability", "key": "system_name", "value": "inv-5"},
    {"namespace": "vulnerability", "key": "usage", "value": "NAS"},
]
INV_3_TAGS = [
    {"namespace": "vulnerability", "key": "system_name", "value": "inv-3"},
    {"namespace": "vulnerability", "key": "usage", "value": "server"},
]
INV_7_TAGS = [
    {"namespace": "vulnerability", "key": "system_name", "value": "inv-7"},
    {"namespace": "vulnerability", "key": "usage", "value": "server"},
]

CVE_2016_1_TAG_SYSTEMS = ["00000000-0000-0000-0000-000000000003", "00000000-0000-0000-0000-000000000007"]
CVE_2016_1_SAP_SYSTEMS = ["00000000-0000-0000-0000-000000000005", "00000000-0000-0000-0000-000000000007"]
PATCH_RESPONSE = [
    {
        "attributes": {
            "advisory_type": 1,
            "applicable_systems": 10,
            "description": "The bash packages provide Bash...",
            "public_date": "2020-09-01T15:22:07Z",
            "severity": 2,
            "synopsis": "Moderate: bash security update",
        },
        "id": "RHSA-2020:3592",
        "type": "advisory",
    }
]


@pytest.mark.feature_flag("vulnerability.cves_without_errata")
class TestCveHandler(FlaskTestCase):
    def test_cves_affected_systems(self):
        response = self.vfetch("cves/CVE-2016-1/affected_systems").check_response()
        assert len(response.body.data) == 3
        response = self.vfetch("cves/CVE-2016-1/affected_systems/ids").check_response()
        assert len(response.body.data) == 3

    def test_cves_affected_systems_st_1(self):
        self.vfetch("cves/CVE-2016-1/affected_systems?status_id=2,nan").check_response(status_code=400)
        self.vfetch("cves/CVE-2016-1/affected_systems/ids?status_id=2,nan").check_response(status_code=400)

    def test_cves_affected_systems_st_2(self):
        response = self.vfetch("cves/CVE-2016-1/affected_systems?status_id=1").check_response()
        assert not response.body.data
        response = self.vfetch("cves/CVE-2016-1/affected_systems/ids?status_id=1").check_response()
        assert not response.body.data

    def test_cves_affected_systems_st_3(self):
        response = self.vfetch("cves/CVE-2016-1/affected_systems?status_id=4,5,6").check_response()
        assert len(response.body.data) == 1
        response = self.vfetch("cves/CVE-2016-1/affected_systems/ids?status_id=4,5,6").check_response()
        assert len(response.body.data) == 1

    def test_cves_affected_systems_inventory_groups(self):
        response = self.vfetch("cves/CVE-2016-1/affected_systems?group_names=group01").check_response()
        assert len(response.body.data) == 2
        response = self.vfetch("cves/CVE-2016-1/affected_systems?group_ids=00000000-1111-0000-0000-000000000000").check_response()
        assert len(response.body.data) == 2

        response = self.vfetch("cves/CVE-2016-1/affected_systems/ids?group_names=group01").check_response()
        assert len(response.body.data) == 2
        response = self.vfetch("cves/CVE-2016-1/affected_systems/ids?group_ids=00000000-1111-0000-0000-000000000000").check_response()
        assert len(response.body.data) == 2

    def test_invalid_cves_affected_systems(self):
        self.vfetch("cves/CVE-INVALID/affected_systems").check_response(status_code=404)
        self.vfetch("cves/CVE-INVALID/affected_systems/ids").check_response(status_code=404)

    def test_cve_details(self):
        assert self.vfetch("cves/CVE-2016-1").status_code == 200

    def test_unknown_cve_details(self):
        assert self.vfetch("cves/TOTALLY-NOT-A-CVE").status_code == 404

    def test_cve_advisories_list(self):
        response = self.vfetch("cves/CVE-2017-8").check_response()
        assert len(response.body.data.attributes.advisories_list) == 2
        assert response.body.data.attributes.affected_systems == 3
        response = self.vfetch("cves/CVE-2017-7").check_response()
        assert len(response.body.data.attributes.advisories_list) == 1
        assert response.body.data.attributes.affected_systems == 4
        response = self.vfetch("cves/CVE-2013-1").check_response()
        assert len(response.body.data.attributes.advisories_list) == 0
        assert response.body.data.attributes.affected_systems == 0

    def test_cve_has_rules(self):
        response = self.vfetch("cves/CVE-2017-8").check_response()
        assert len(response.body.data.attributes.rules) == 2
        assert "CVE-2018-1" in response.body.data.attributes.rules[0].associated_cves
        assert "CVE-2017-8" in response.body.data.attributes.rules[0].associated_cves

    def test_cves_affected_systems_rule_filter(self):
        response = self.vfetch("cves/CVE-2017-8/affected_systems?rule_presence=true").check_response()
        assert len(response.body.data) == 2
        response = self.vfetch("cves/CVE-2017-8/affected_systems/ids?rule_presence=true").check_response()
        assert len(response.body.data) == 2
        response = self.vfetch("cves/CVE-2017-8/affected_systems?rule_presence=false").check_response()
        assert len(response.body.data) == 1
        response = self.vfetch("cves/CVE-2017-8/affected_systems/ids?rule_presence=false").check_response()
        assert len(response.body.data) == 1

        response = self.vfetch(
            "cves/CVE-2017-8/affected_systems?rule_key=CVE_2018_12130_cpu_kernel|CVE_2018_12130_CPU_KERNEL_BAD_MICROCODE"
        ).check_response()
        assert len(response.body.data) == 1

        response = self.vfetch(
            "cves/CVE-2017-8/affected_systems/ids?rule_key=CVE_2018_12130_cpu_kernel|CVE_2018_12130_CPU_KERNEL_BAD_MICROCODE"
        ).check_response()
        assert len(response.body.data) == 1

        path = (
            "cves/CVE-2017-8/affected_systems?rule_key=CVE_2018_12130_cpu_kernel|"
            "CVE_2018_12130_CPU_KERNEL_BAD_MICROCODE,CVE_2018_12130_cpu_kernel|CVE_2018_12130_CPU_KERNEL_NEED_UPDATE"
        )
        response = self.vfetch(path).check_response()
        assert len(response.body.data) == 2

    def test_cves_affected_systems_uuid(self):
        """Test for system which has specific CVE and gets searched by UUID."""
        response = self.vfetch("cves/CVE-2016-1/affected_systems?uuid=00000000-0000-0000-0000-000000000003").check_response()
        assert len(response.body.data) == 1

    def test_cves_affected_systems_wrong_cve_uuid(self):
        """Test for existing system with nonexisting cve."""
        response = self.vfetch("cves/CVE-2014-1/affected_systems?uuid=00000000-0000-0000-0000-000000000006").check_response()
        assert not response.body.data

    def test_cves_affected_systems_uuid_filter(self):
        """Test with different uuid and filter name."""
        response = self.vfetch(
            "cves/CVE-2014-1/affected_systems?uuid=00000000-0000-0000-0000-000000000003&filter=inv-4.example.com"
        ).check_response()
        assert not response.body.data

    def test_cve_reporter(self):
        """Test reporter of CVE"""
        response = self.vfetch("cves/CVE-2018-1/affected_systems?sort=inventory_id").check_response()
        assert response.body.data[0].attributes.reporter == 3  # on INV-5 it's reported by VMaaS and rule
        assert response.body.data[1].attributes.reporter == 2  # on INV-7 it's reported by rules

    def test_cves_affected_systems_rule_presence_bools(self):
        """Test that multiple different bools, must have
        the same behaviour as not specified parameter"""
        response_bools = self.vfetch("cves/CVE-2017-8/affected_systems?rule_presence=false,true").check_response()
        response_all = self.vfetch("cves/CVE-2017-8/affected_systems").check_response()

        assert response_bools.body.meta.total_items == response_all.body.meta.total_items

    def test_cves_affected_systems_rule_presence_multiple_same_bools(self):
        """Test with multiple same bools"""
        response_multiple = self.vfetch("cves/CVE-2017-8/affected_systems?rule_presence=true,true").check_response()
        response_single = self.vfetch("cves/CVE-2017-8/affected_systems?rule_presence=true").check_response()

        assert response_multiple.body.meta.total_items == response_single.body.meta.total_items
        assert response_multiple.body.meta.rule_presence == "True"

    def test_cves_affected_systems_tags(self):
        """Test for tags in /affected_systems"""
        correct_tags = [INV_5_TAGS, INV_3_TAGS, INV_7_TAGS]
        response = self.vfetch("cves/CVE-2016-1/affected_systems").check_response()
        for system in response.body.data:
            assert system.attributes.tags in correct_tags

    def test_cves_affected_systems_tags_filter(self):
        """Fetch systems by given tag"""
        response = self.vfetch("cves/CVE-2016-1/affected_systems?tags=vulnerability/usage=server").check_response()
        for system in response.body.data:
            assert system.attributes.inventory_id in CVE_2016_1_TAG_SYSTEMS

    def test_cves_affected_systems_tags_filter_multiple(self):
        """Fetch systems by given tags"""
        response = self.vfetch(
            "cves/CVE-2016-1/affected_systems?tags=vulnerability/usage=server,vulnerability/system_name=inv-7"
        ).check_response()
        assert response.body.meta.total_items == 1
        for rec in response.body.data:
            assert rec.attributes.inventory_id == "00000000-0000-0000-0000-000000000007"

    def test_cves_affected_systems_sap_filter(self):
        """Fetch sap filtered systems"""
        response = self.vfetch("cves/CVE-2016-1/affected_systems?sap_system=true").check_response()
        for system in response.body.data:
            assert system.attributes.inventory_id in CVE_2016_1_SAP_SYSTEMS

        response = self.vfetch("cves/CVE-2016-1/affected_systems?sap_system=false").check_response()
        for system in response.body.data:
            assert system.attributes.inventory_id not in CVE_2016_1_SAP_SYSTEMS

    def test_cves_affected_systems_sap_filter_counts(self):
        """Test counts for returned systems with sap filter"""
        response_true = self.vfetch("cves/CVE-2016-1/affected_systems?sap_system=true").check_response()
        response_false = self.vfetch("cves/CVE-2016-1/affected_systems?sap_system=false").check_response()
        response_all = self.vfetch("cves/CVE-2016-1/affected_systems").check_response()

        assert response_all.body.meta.total_items == (response_true.body.meta.total_items + response_false.body.meta.total_items)

    def test_rule_filter_regular_rule(self):
        response = self.vfetch(
            "cves/CVE-2017-8/affected_systems?rule=CVE_2018_12130_cpu_kernel|CVE_2018_12130_CPU_KERNEL_NEED_UPDATE"
        ).check_response()

        assert len(response.body.data) == 1
        assert response.body.data[0].attributes.inventory_id == "00000000-0000-0000-0000-000000000005"

    def test_rule_filter_no_rule(self):
        response = self.vfetch("cves/CVE-2017-8/affected_systems?rule=false").check_response()

        assert len(response.body.data) == 1
        assert response.body.data[0].attributes.inventory_id == "00000000-0000-0000-0000-000000000003"

    def test_rule_filter_no_rule_and_rule(self):
        response = self.vfetch(
            "cves/CVE-2017-8/affected_systems?rule=false&rule=CVE_2018_12130_cpu_kernel|CVE_2018_12130_CPU_KERNEL_NEED_UPDATE"
        ).check_response()

        assert len(response.body.data) == 2
        assert (
            response.body.data[0].attributes.inventory_id == "00000000-0000-0000-0000-000000000003"
            or response.body.data[1].attributes.inventory_id == "00000000-0000-0000-0000-000000000003"
        )
        assert (
            response.body.data[0].attributes.inventory_id == "00000000-0000-0000-0000-000000000005"
            or response.body.data[1].attributes.inventory_id == "00000000-0000-0000-0000-000000000005"
        )

    def test_rule_filter_all(self):
        response_default = self.vfetch("cves/CVE-2016-1/affected_systems").check_response()
        response = self.vfetch(
            "cves/CVE-2016-1/affected_systems?rule=false&rule=CVE_2018_3639_cpu_kernel|CVE_2018_3639_CPU_BAD_MICROCODE_2"
        ).check_response()

        assert len(response_default.body.data) == len(response.body.data) == 3

    def test_rule_filter_diff_falses(self):
        response1 = self.vfetch("cves/CVE-2017-6/affected_systems?rule=FALSE").check_response()
        response2 = self.vfetch("cves/CVE-2017-6/affected_systems?rule=false").check_response()
        response3 = self.vfetch("cves/CVE-2017-6/affected_systems?rule=fAlSe").check_response()

        assert len(response1.body.data) == len(response2.body.data) == len(response3.body.data)

    def test_cve_known_exploit(self):
        assert self.vfetch("cves/CVE-2017-8").body.data.attributes["known_exploit"] is True

    def test_cve_known_exploit_without_advisories(self):
        assert self.vfetch("cves/CVE-2023-1").body.data.attributes["known_exploit"] is False

    def test_cve_unpatched_full_query_advisory(self):
        response = self.vfetch("cves/CVE-2023-1/affected_systems?advisory_available=true").check_response()
        assert len(response.body.data) == 1
        assert response.body.data[0].attributes.inventory_id == "00000000-0000-0000-0000-000000000005"

        response = self.vfetch("cves/CVE-2023-1/affected_systems/ids?advisory_available=true").check_response()
        assert len(response.body.data) == 1

    def test_cve_unpatched_full_query_no_advisory(self):
        response = self.vfetch("cves/CVE-2023-1/affected_systems?advisory_available=false").check_response()
        assert len(response.body.data) == 1
        assert response.body.data[0].attributes.inventory_id == "00000000-0000-0000-0000-000000000032"

        response = self.vfetch("cves/CVE-2023-1/affected_systems/ids?advisory_available=false").check_response()
        assert len(response.body.data) == 1

    def test_cve_unpatched_full_query_all_advisories(self):
        response = self.vfetch("cves/CVE-2023-1/affected_systems?advisory_available=true,false").check_response()
        assert len(response.body.data) == 2
        assert response.body.data[0].attributes.inventory_id == "00000000-0000-0000-0000-000000000032"
        assert response.body.data[1].attributes.inventory_id == "00000000-0000-0000-0000-000000000005"

        response = self.vfetch("cves/CVE-2023-1/affected_systems/ids?advisory_available=true,false").check_response()
        assert len(response.body.data) == 2

    def test_cve_sort_check(self):
        sortable_columns = [
            "display_name",
            "id",
            "inventory_id",
            "last_evaluation",
            "last_upload",
            "rules_evaluation",
            "status_id",
            "status",
            "updated",
            "first_reported",
            "os",
            "advisory_available",
            "remediation",
            "advisories_list",
            "inventory_group",
        ]

        for sort in sortable_columns:
            self.vfetch(f"cves/CVE-2023-1/affected_systems?advisory_available=false&sort={sort}").check_response()
            self.vfetch(f"cves/CVE-2023-1/affected_systems?advisory_available=true,false&sort={sort}").check_response()
            self.vfetch(f"cves/CVE-2023-1/affected_systems?advisory_available=true&sort={sort}").check_response()

    def test_cve_filter_check(self):
        filters = {
            "rule": ["true", "false", "affected_not_vulnerable"],
            "status_id": [0, 1, 2],
            "advisory": ["RHSA-2014:1999"],
            "first_reported_from": ["2018-01-03"],
            "first_reported_to": ["2018-01-03"],
            "rule_key": ["rule"],
            "rule_presence": ["true", "false"],
            "remediation": [0],
            "uuid": ["00000000-0000-0000-0000-000000000025"],
            "tags": ["sap_system/true"],
            "sap_system": ["true", "false"],
            "sap_sids": ["00000000-0000-0000-0000-000000000001"],
            "rhel_version": ["7.4"],
            "ansible": ["true", "false"],
            "mssql": ["true", "false"],
            "group_ids": [0, 1],
            "group_names": ["group1"],
            "host_type": ["edge"],
        }

        for filter in filters:
            for value in filters[filter]:
                self.vfetch(f"cves/CVE-2023-1/affected_systems?advisory_available=true&{filter}={value}").check_response()
                self.vfetch(f"cves/CVE-2023-1/affected_systems?advisory_available=false&{filter}={value}").check_response()
                self.vfetch(f"cves/CVE-2023-1/affected_systems?advisory_available=true,false&{filter}={value}").check_response()

    def test_host_type_filter(self):
        edge = self.vfetch("cves/CVE-2016-1/affected_systems?host_type=edge").check_response()
        rpmdnf = self.vfetch("cves/CVE-2016-1/affected_systems?host_type=rpmdnf").check_response()
        all_filter_arr = self.vfetch("cves/CVE-2016-1/affected_systems?host_type=rpmdnf,edge").check_response()
        all_filter = self.vfetch("cves/CVE-2016-1/affected_systems?host_type=rpmdnf&host_type=edge").check_response()
        rpmdnf_default = self.vfetch("cves/CVE-2016-1/affected_systems").check_response()

        assert (len(edge.body.data) + len(rpmdnf.body.data)) == len(all_filter.body.data)
        assert len(all_filter_arr.body.data) == len(all_filter.body.data)
        assert len(rpmdnf.body.data) == len(rpmdnf_default.body.data)
        assert len(rpmdnf.body.data) == 3
        assert len(edge.body.data) == 0

        edge = self.vfetch("cves/CVE-2022-1/affected_systems?host_type=edge").check_response()
        rpmdnf = self.vfetch("cves/CVE-2022-1/affected_systems?host_type=rpmdnf").check_response()
        all_filter_arr = self.vfetch("cves/CVE-2022-1/affected_systems?host_type=rpmdnf,edge").check_response()
        all_filter = self.vfetch("cves/CVE-2022-1/affected_systems?host_type=rpmdnf&host_type=edge").check_response()
        rpmdnf_default = self.vfetch("cves/CVE-2022-1/affected_systems").check_response()

        assert (len(edge.body.data) + len(rpmdnf.body.data)) == len(all_filter.body.data)
        assert len(all_filter_arr.body.data) == len(all_filter.body.data)
        assert len(rpmdnf.body.data) == len(rpmdnf_default.body.data)
        assert len(rpmdnf.body.data) == 0
        assert len(edge.body.data) == 2
