# -*- coding: utf-8 -*-
# pylint: disable=missing-docstring,too-many-public-methods,invalid-name
"""
Vulnerability manager tests.
"""
import base64
import json

import pytest

from manager.status_handler import PatchStatus
from manager.vulnerabilities_handler import GetCves
from .vuln_testcase import FlaskTestCase

CSV_EXPORT_ENDPOINTS = ('cves/CVE-2016-0800/affected_systems', 'systems',
                        'systems/INV-ID00-0000-4444/cves', 'vulnerabilities/cves')


class TestManager(FlaskTestCase):
    def test_apidoc(self):
        response = self.raw_get("/api/vulnerability/v1/openapi.json").check_response()
        assert response.body.info.title == "Vulnerability Engine Manager"

    def test_metrics(self):
        response = self.raw_get('/metrics')
        assert response.status_code == 200

    def test_version(self):
        response = self.vfetch("version")
        assert response.body.application_version == "unknown"
        assert response.body.database_version > 0

    def test_limit_offset(self):
        response = self.vfetch('vulnerabilities/cves')
        assert len(response.body.data) == 13
        assert response.body.meta.limit == 25
        assert response.body.meta.offset == 0

        response = self.vfetch('vulnerabilities/cves?limit=2')
        assert len(response.body.data) == 2
        assert response.body.meta.limit == 2
        assert response.body.meta.offset == 0

        response = self.vfetch('vulnerabilities/cves?limit=3&offset=6')
        assert len(response.body.data) == 3
        assert response.body.meta.limit == 3
        assert response.body.meta.offset == 6

    def test_page_to_limit(self):
        response = self.vfetch('vulnerabilities/cves?page_size=5&page=3')
        assert response.body.meta.limit == 5
        assert response.body.meta.offset == 10

    def test_limit_to_page(self):
        response = self.vfetch('vulnerabilities/cves?limit=3&offset=6')
        assert response.body.meta.page_size == 3
        assert response.body.meta.page == 3

    def test_links(self):
        response = self.vfetch('vulnerabilities/cves')
        assert response.body.links.first
        assert response.body.links.previous is None
        assert response.body.links.next is None
        assert response.body.links.last

    def test_bad_pagination(self):
        self.vfetch('vulnerabilities/cves?limit=-3&offset=6').check_response(400)
        self.vfetch('vulnerabilities/cves?limit=0&offset=6').check_response(400)
        self.vfetch('vulnerabilities/cves?limit=zzz&offset=6').check_response(400)
        self.vfetch('vulnerabilities/cves?limit=2&offset=666').check_response(400)
        self.vfetch('vulnerabilities/cves?page=0&page_size=5').check_response(400)
        self.vfetch('vulnerabilities/cves?page=-1&page_size=5').check_response(400)
        self.vfetch('vulnerabilities/cves?page=666&page_size=5').check_response(400)
        self.vfetch('vulnerabilities/cves?offset=666&page=666').check_response(400)
        response = self.vfetch('vulnerabilities/cves?page=666&page_size=5')
        assert 'Requested start-point out of range' in response.body['errors'][0]['detail']
        assert 'page 666' in response.body['errors'][0]['detail']
        response = self.vfetch('vulnerabilities/cves?offset=6666&limit=5')
        assert 'Requested start-point out of range' in response.body['errors'][0]['detail']
        assert 'offset 6666' in response.body['errors'][0]['detail']

    def test_args_in_links(self):
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=2&cvss_from=6')
        assert 'cvss_from=6' in response.body.links.first
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=2&cvss_from=').check_response(status_code=400)
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=2&public_from=2018-01-01')
        assert 'public_from=2018-01-01' in response.body.links.first
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=0&show_all=true')
        assert 'show_all=True' in response.body.links.first
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=0&show_all=false')
        assert 'show_all=False' in response.body.links.first
        response = self.vfetch('systems?opt_out=true&limit=5')
        assert 'opt_out=True' in response.body.links.first
        response = self.vfetch('systems?limit=2&offset=0&opt_out=false')
        assert 'opt_out=False' in response.body.links.first

    def test_no_sort_available(self):
        self.vfetch('cves/CVE-2016-0800/affected_systems?sort=synopsis').check_response(status_code=400)

    def test_sorting_ordering(self):
        response1 = self.vfetch('vulnerabilities/cves?sort=synopsis').check_response()
        response2 = self.vfetch('vulnerabilities/cves?sort=%2Bsynopsis').check_response()
        assert response1.body.data == response2.body.data

    @pytest.mark.parametrize('endpoint', CSV_EXPORT_ENDPOINTS, ids=CSV_EXPORT_ENDPOINTS)
    def test_csv_export(self, endpoint):
        self.vfetch('{}?data_format=csv'.format(endpoint)).check_response()

    def test_invalid_export(self):
        self.vfetch('systems/?data_format=wtf').check_response(status_code=400)

    @classmethod
    def _evaluate_link(cls, link):
        errors = {'multiple_ques': False, 'multiple_attr': False, 'bad_attr': False, 'empty_attr': False}
        if not link:
            return errors
        valid_attrs = [
            'page', 'page_size', 'limit', 'offset',
            'filter', 'sort', 'public_from', 'cvss_from', 'cvss_to', 'show_all'
        ]
        attrs = []
        split_link = link.split('?')
        errors['multiple_ques'] = len(split_link) > 2
        split_attr = split_link[-1:].split('&') if errors['multiple_ques'] else split_link[1].split('&')
        for attr in split_attr:
            (k, v) = attr.split('=')
            errors['multiple_attr'] |= k in attrs
            errors['bad_attr'] |= not k in valid_attrs
            errors['empty_attr'] |= not v
        return errors

    def test_link_sanity(self):
        # Test for commentsa from demo/review
        # No empty attrs, only expected attrs, no multiple attrs, no multiple '?'
        # Note: all of first/prev/next/last behave the same, test one
        response = self.vfetch(
            'vulnerabilities/cves?empty=&limit=1&limit=1&foobar=baz&offset=1&show_all=false&' +
            'public_from=2018-01-01 00:00:00&cvss_from=6&cvss_to=8')
        errs = self._evaluate_link(response.body.links.first)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']

        response = self.vfetch(
            'vulnerabilities/cves?sort=-synopsis&limit=1&offset=1&show_all=false&' +
            'public_from=2018-01-01&cvss_from=6&cvss_to=8&filter=CVE-2018-')
        assert 'sort=' in response.body.links.first
        assert 'limit=' in response.body.links.first
        assert 'offset=' in response.body.links.first
        assert 'show_all=' in response.body.links.first
        assert 'public_from=' in response.body.links.first
        assert 'cvss_from=' in response.body.links.first
        assert 'cvss_to=' in response.body.links.first
        assert 'filter=' in response.body.links.first

        print('FIRST [%s]' % response.body.links.first)
        errs = self._evaluate_link(response.body.links.first)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']
        print('NEXT [%s]' % response.body.links.next)
        errs = self._evaluate_link(response.body.links.next)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']
        print('PREV [%s]' % response.body.links.previous)
        errs = self._evaluate_link(response.body.links.previous)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']
        print('LAST [%s]' % response.body.links.last)
        errs = self._evaluate_link(response.body.links.last)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']


class TestAuth(FlaskTestCase):

    @staticmethod
    def _make_header(value):
        return {'x-rh-identity': base64.b64encode(json.dumps(value).encode('utf-8'))}

    def test_no_header(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves').check_response(status_code=401)

    def test_empty_header(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({})).check_response(status_code=401)

    def test_empty_identity(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {}})).check_response(status_code=401)

    def test_no_entitlements(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'account_number': '000000'}})
                     ).check_response(status_code=403)

    def test_smart_management_missing(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'account_number': '000000'}, 'entitlements': {
                         'dull_management': {'is_entitled': False}}})
                     ).check_response(status_code=403)

    def test_not_entitled(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'account_number': '000000'}, 'entitlements': {
                         'smart_management': {'is_entitled': False}}})
                     ).check_response(status_code=403)

    def test_entitled(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'account_number': '000000'}, 'entitlements': {
                         'smart_management': {'is_entitled': True}}})
                     ).check_response()


class TestBase(FlaskTestCase):

    def test_get_500(self, monkeypatch):
        monkeypatch.setattr(GetCves, 'handle_get', lambda **kwargs: 1/0)
        response = self.vfetch('vulnerabilities/cves').check_response(status_code=500)
        assert response.body.errors[0].detail == 'Internal server error'

    def test_patch_500(self, monkeypatch):
        monkeypatch.setattr(PatchStatus, 'handle_patch', lambda **kwargs: 1/0)
        response = self.vfetch(
            'status', method='PATCH',
            json={'inventory_id': 'INV-ID00-0000-5555', 'cve': 'CVE-2014-0160', 'status_id': 2}
        ).check_response(status_code=500)
        assert response.body.errors[0].detail == 'Internal server error'
