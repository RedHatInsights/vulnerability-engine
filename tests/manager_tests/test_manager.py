# -*- coding: utf-8 -*-
# pylint: disable=missing-docstring,too-many-public-methods,invalid-name
"""
Vulnerability manager tests.
"""
import re

import pytest

from manager.base import round_to_100_percent, Request
from manager.status_handler import PatchStatus
from manager.vulnerabilities_handler import GetCves
from .vuln_testcase import FlaskTestCase

CSV_EXPORT_ENDPOINTS = ('cves/CVE-2016-1/affected_systems', 'systems',
                        'systems/00000000-0000-0000-0000-000000000004/cves', 'vulnerabilities/cves')


class TestManager(FlaskTestCase):
    def test_apidoc(self):
        response = self.raw_get("/api/vulnerability/v1/openapi.json").check_response()
        assert response.body.info.title == "Vulnerability Engine Manager"

    def test_swagger_ui(self):
        response = self.raw_get('/api/vulnerability/v1/ui/')
        assert response.status_code == 200

    def test_metrics(self):
        response = self.raw_get('/metrics')
        assert response.status_code == 200

    def test_version(self):
        response = self.vfetch("version")
        assert re.match(r"\d+\.\d+\.\d+", response.body.application_version)
        assert response.body.database_version > 0

    def test_unknown_db_version(self, trunc_db_version):  # pylint: disable=unused-argument
        response = self.vfetch("version")
        assert response.body.database_version == 'unknown'

    def test_limit_offset(self):
        response = self.vfetch('vulnerabilities/cves?affecting=true')
        assert len(response.body.data) == 7
        assert response.body.meta.limit == 20
        assert response.body.meta.offset == 0

        response = self.vfetch('vulnerabilities/cves?limit=2')
        assert len(response.body.data) == 2
        assert response.body.meta.limit == 2
        assert response.body.meta.offset == 0

        response = self.vfetch('vulnerabilities/cves?limit=3&offset=6')
        assert len(response.body.data) == 3
        assert response.body.meta.limit == 3
        assert response.body.meta.offset == 6

    def test_page_to_limit(self):
        response = self.vfetch('vulnerabilities/cves?page_size=3&page=3')
        assert response.body.meta.limit == 3
        assert response.body.meta.offset == 6

    def test_limit_to_page(self):
        response = self.vfetch('vulnerabilities/cves?limit=3&offset=6')
        assert response.body.meta.page_size == 3
        assert response.body.meta.page == 3

    def test_links(self):
        response = self.vfetch('vulnerabilities/cves')
        assert response.body.links.first
        assert response.body.links.previous is None
        assert response.body.links.next is None
        assert response.body.links.last

    def test_bad_pagination(self):
        self.vfetch('vulnerabilities/cves?limit=-3&offset=6').check_response(400)
        self.vfetch('vulnerabilities/cves?limit=9223372036854775808&offset=6').check_response(400)
        self.vfetch('vulnerabilities/cves?limit=0&offset=6').check_response(400)
        self.vfetch('vulnerabilities/cves?limit=zzz&offset=6').check_response(400)
        self.vfetch('vulnerabilities/cves?limit=2&offset=666').check_response(400)
        self.vfetch('vulnerabilities/cves?page=0&page_size=5').check_response(400)
        self.vfetch('vulnerabilities/cves?page=-1&page_size=5').check_response(400)
        self.vfetch('vulnerabilities/cves?page=666&page_size=5').check_response(400)
        self.vfetch('vulnerabilities/cves?offset=666&page=666').check_response(400)
        response = self.vfetch('vulnerabilities/cves?page=666&page_size=5')
        assert 'Requested start-point out of range' in response.body['errors'][0]['detail']
        assert 'page 666' in response.body['errors'][0]['detail']
        response = self.vfetch('vulnerabilities/cves?offset=6666&limit=5')
        assert 'Requested start-point out of range' in response.body['errors'][0]['detail']
        assert 'offset 6666' in response.body['errors'][0]['detail']

    def test_args_in_links(self):
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=2&cvss_from=6')
        assert 'cvss_from=6' in response.body.links.first
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=2&cvss_from=').check_response(status_code=400)
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=2&public_from=2018-01-01')
        assert 'public_from=2018-01-01' in response.body.links.first
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=0&sap_system=true')
        assert 'sap_system=True' in response.body.links.first
        response = self.vfetch('vulnerabilities/cves?limit=2&offset=0&sap_system=false')
        assert 'sap_system=False' in response.body.links.first
        response = self.vfetch('systems?excluded=false&excluded=true&limit=5')
        assert 'excluded=False%2CTrue' in response.body.links.first
        response = self.vfetch('systems?limit=2&offset=0&excluded=true&excluded=False')
        assert 'excluded=True%2CFalse' in response.body.links.first

    def test_no_sort_available(self):
        self.vfetch('cves/CVE-2016-1/affected_systems?sort=synopsis').check_response(status_code=400)

    def test_sorting_ordering(self):
        response1 = self.vfetch('vulnerabilities/cves?sort=synopsis').check_response()
        response2 = self.vfetch('vulnerabilities/cves?sort=%2Bsynopsis').check_response()
        assert response1.body.data == response2.body.data

    @pytest.mark.parametrize('endpoint', CSV_EXPORT_ENDPOINTS, ids=CSV_EXPORT_ENDPOINTS)
    def test_csv_export(self, endpoint):
        self.vfetch('{}?data_format=csv'.format(endpoint)).check_response()

    def test_invalid_export(self):
        self.vfetch('systems/?data_format=wtf').check_response(status_code=400)

    @classmethod
    def _evaluate_link(cls, link):
        errors = {'multiple_ques': False, 'multiple_attr': False, 'bad_attr': False, 'empty_attr': False}
        if not link:
            return errors
        valid_attrs = [
            'page', 'page_size', 'limit', 'offset',
            'filter', 'sort', 'public_from', 'cvss_from', 'cvss_to', 'sap_system', 'data_format'
        ]
        attrs = []
        split_link = link.split('?')
        errors['multiple_ques'] = len(split_link) > 2
        split_attr = split_link[-1:].split('&') if errors['multiple_ques'] else split_link[1].split('&')
        for attr in split_attr:
            (k, v) = attr.split('=')
            errors['multiple_attr'] |= k in attrs
            errors['bad_attr'] |= k not in valid_attrs
            errors['empty_attr'] |= not v
        return errors

    def test_link_sanity(self):
        # Test for commentsa from demo/review
        # No empty attrs, only expected attrs, no multiple attrs, no multiple '?'
        # Note: all of first/prev/next/last behave the same, test one
        response = self.vfetch(
            'vulnerabilities/cves?limit=1&limit=1&sap_system=false&offset=1&' +
            'public_from=2018-01-01 00:00:00&cvss_from=6&cvss_to=8')
        errs = self._evaluate_link(response.body.links.first)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']

        response = self.vfetch(
            'vulnerabilities/cves?sort=-synopsis&limit=1&offset=1&sap_system=false&' +
            'public_from=2018-01-01&cvss_from=6&cvss_to=8&filter=CVE-2018-')
        assert 'sort=' in response.body.links.first
        assert 'limit=' in response.body.links.first
        assert 'offset=' in response.body.links.first
        assert 'sap_system=' in response.body.links.first
        assert 'public_from=' in response.body.links.first
        assert 'cvss_from=' in response.body.links.first
        assert 'cvss_to=' in response.body.links.first
        assert 'filter=' in response.body.links.first

        print('FIRST [%s]' % response.body.links.first)
        errs = self._evaluate_link(response.body.links.first)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']
        print('NEXT [%s]' % response.body.links.next)
        errs = self._evaluate_link(response.body.links.next)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']
        print('PREV [%s]' % response.body.links.previous)
        errs = self._evaluate_link(response.body.links.previous)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']
        print('LAST [%s]' % response.body.links.last)
        errs = self._evaluate_link(response.body.links.last)
        assert not errs['multiple_ques']
        assert not errs['multiple_attr']
        assert not errs['bad_attr']
        assert not errs['empty_attr']


class TestAuth(FlaskTestCase):

    def test_no_header(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves').check_response(status_code=401)

    def test_empty_header(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({})).check_response(status_code=401)

    def test_empty_identity(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {}})).check_response(status_code=401)

    def test_no_entitlements(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'org_id': '000000'}})
                     ).check_response(status_code=403)

    def test_insights_entitlement_missing(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'org_id': '000000'}, 'entitlements': {
                         'dull_management': {'is_entitled': False}}})
                     ).check_response(status_code=403)

    def test_not_entitled(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'org_id': '000000'}, 'entitlements': {
                         'insights': {'is_entitled': False}}})
                     ).check_response(status_code=403)

    def test_entitled(self):
        self.raw_get('/api/vulnerability/v1/vulnerabilities/cves',
                     headers=self._make_header({'identity': {'org_id': '000000'}, 'entitlements': {
                         'insights': {'is_entitled': True}}})
                     ).check_response()


class TestBase(FlaskTestCase):

    def test_get_500(self, monkeypatch):
        monkeypatch.setattr(GetCves, 'handle_get', lambda **kwargs: 1 / 0)
        response = self.vfetch('vulnerabilities/cves').check_response(status_code=500)
        assert response.body.errors[0].detail == 'Internal server error'

    def test_patch_500(self, monkeypatch):
        monkeypatch.setattr(PatchStatus, 'handle_patch', lambda **kwargs: 1 / 0)
        Request._endpoint_name = r'test_patch_500'  # pylint: disable=protected-access
        response = self.vfetch(
            'status', method='PATCH',
            json={'inventory_id': '00000000-0000-0000-0000-000000000005', 'cve': 'CVE-2014-1', 'status_id': 2}
        ).check_response(status_code=500)
        assert response.body.errors[0].detail == 'Internal server error'

    @staticmethod
    def test_round_to_100_percent():
        result = round_to_100_percent([50, 40, 30], 3)
        assert result == [41.667, 33.333, 25.0]
        assert sum(result) == 100

    @staticmethod
    def test_round_to_100_percent_all_zeros():
        result = round_to_100_percent([0, 0])
        assert result == [50.0, 50.0]
        assert sum(result) == 100
