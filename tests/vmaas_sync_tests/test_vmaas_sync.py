# -*- coding: utf-8 -*-
# pylint: disable=no-self-use
"""
Unit tests for vmaas_sync module
"""
import asyncio
import datetime
import logging

import vmaas_sync.vmaas_sync as vmaas_sync
from ..scripts.vmaas_mock import CVES_RESPONSE
from ..scripts.vmaas_mock import REPOS_RESPONSE
from common import constants
from common.database_handler import DatabasePool
from vmaas_sync.vmaas_sync import _get_last_repobased_eval_tms
from vmaas_sync.vmaas_sync import _select_repo_based_inventory_ids
from vmaas_sync.vmaas_sync import _set_last_repobased_eval_tms
from vmaas_sync.vmaas_sync import LOGGER
from vmaas_sync.vmaas_sync import re_evaluate_systems
from vmaas_sync.vmaas_sync import sync_cve_md


class TestMqueueWriter:
    """Pretends to know how to send kafka msgs"""

    @staticmethod
    async def _do_nothing():
        pass

    def send(self, msg, loop=None):
        """send from cve sync"""
        LOGGER.info(msg)
        return asyncio.ensure_future(self._do_nothing(), loop=loop)

    def send_list(self, msg_list, loop=None):
        """send from re_evaluate_systems"""
        for msg in msg_list:
            LOGGER.info(msg["host"]["id"])
        return asyncio.ensure_future(self._do_nothing(), loop=loop)


class TestVmaasSync:
    """Tests for vmaas_sync and friends"""

    @staticmethod
    async def timed_future(coro, time):
        """Run coroutine for specific time"""
        future = asyncio.ensure_future(coro())
        await asyncio.sleep(time)
        future.cancel()

    @staticmethod
    def check_sync_logs(records, start_offset):
        """Check to see we got the expected msgs from sync_cve_md"""
        assert records[start_offset].msg == "Syncing CVE metadata"
        assert records[start_offset + 1].message == "Fetched %s CVEs from VMaaS" % len(CVES_RESPONSE[0]["cve_list"])
        assert records[start_offset + 2].msg == ("Importing CVE metadata")
        assert records[start_offset + 3].msg == "Finished syncing CVE metadata"

    @staticmethod
    def check_re_evaluate_all_logs(records, start_offset):
        """Check to see we got the expected msgs from re_evaluate_vmaas all systems"""
        assert records[start_offset].msg == "Re-evaluating all systems"

    @staticmethod
    def check_re_eval_repo_based_logs(records, start_offset):
        """Check to see we got the expected msgs from re_evaluate_vmaas repo based"""
        assert records[start_offset].message == "Fetched %s repos, updated since 2018-04-04T23:23:45+00:00" % len(
            REPOS_RESPONSE[0]["repository_list"]
        )
        assert records[start_offset + 1].msg == "Re-evaluating in repo-based mode"

    def test_sync_cve_md_positive(self, pg_db_conn, monkeypatch, caplog, cleanup):  # pylint: disable=unused-argument
        """Test calling sync_cve_md with vmaas responding with data"""
        monkeypatch.setattr(vmaas_sync, "_fetch_vmaas_pages", lambda *_, **__: (True, CVES_RESPONSE))

        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                result = sync_cve_md()
            assert result
        self.check_sync_logs(caplog.records, 0)
        caplog.clear()

    def test_sync_cve_md_negative(self, pg_db_conn, monkeypatch, caplog, cleanup):  # pylint: disable=unused-argument
        """Test calling sync_cve_md with vmaas responding with nothing"""
        monkeypatch.setattr(vmaas_sync, "_fetch_vmaas_pages", lambda *_, **__: (False, {}))

        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                result = sync_cve_md()
            assert not result
        assert caplog.records[0].msg == "Syncing CVE metadata"
        assert caplog.records[1].msg == "Fetched 0 CVEs from VMaaS, skipping CVE sync"
        caplog.clear()

    def test_re_evaluate_repo_based(self, pg_db_conn, monkeypatch, caplog):  # pylint: disable=unused-argument
        """Test re_evaluate_systems - repo-based mode with page control"""
        monkeypatch.setattr(vmaas_sync, "_fetch_vmaas_pages", lambda *_, **__: (True, REPOS_RESPONSE))
        monkeypatch.setattr(vmaas_sync, "EVALUATOR_QUEUE", TestMqueueWriter())
        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                re_evaluate_systems()
        self.check_re_eval_repo_based_logs(caplog.records, 0)
        caplog.clear()

    def test_select_inv_ids_2(self, pg_db_conn):
        """Test select inventory_ids repo collection"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            repos = ["repo1"]
            _select_repo_based_inventory_ids(cur, repos)
            assert len(cur.fetchall()) == 2

    def test_select_inv_ids_3(self, pg_db_conn):
        """Test select inventory_ids with empty repo collection"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            repos = []
            _select_repo_based_inventory_ids(cur, repos)
            assert list(cur.fetchall()) == []

    def test_last_repobased_eval_tms_1(self, pg_db_conn):
        """Test select repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            val = _get_last_repobased_eval_tms(cur)
            assert val is not None

    def test_last_repobased_eval_tms_2(self, pg_db_conn):
        """Test select empty repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            cur.execute("delete from timestamp_kv where name = %s", (constants.TIMESTAMP_LAST_REPO_BASED_EVAL,))
            val = _get_last_repobased_eval_tms(cur)
            assert val is None

    def test_last_repobased_eval_tms_3(self, pg_db_conn):
        """Test update repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            cur.execute("delete from timestamp_kv where name = %s", (constants.TIMESTAMP_LAST_REPO_BASED_EVAL,))
            val = datetime.datetime(2014, 1, 1, 8, 1, 1, tzinfo=datetime.timezone(datetime.timedelta(hours=2)))
            val_ret, inserted = _set_last_repobased_eval_tms(cur, val)
            assert inserted
            assert val_ret.isoformat() == "2014-01-01T06:01:01+00:00"

    def test_last_repobased_eval_tms_4(self, pg_db_conn):
        """Test update repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            val = datetime.datetime(2014, 1, 1, 6, 1, 1, tzinfo=datetime.timezone(datetime.timedelta(hours=2)))
            val_ret, inserted = _set_last_repobased_eval_tms(cur, val)
            assert not inserted  # updated
            assert val_ret.isoformat() == "2014-01-01T04:01:01+00:00"

    def test_sync_cve_md_delete(self, pg_db_conn, monkeypatch, caplog, cleanup):  # pylint: disable=unused-argument
        """Test calling sync_cve_md with vmaas responding with data"""
        cves = CVES_RESPONSE.copy()
        del cves[0]["cve_list"]["CVE-2017-3"]
        del cves[0]["cve_list"]["CVE-2018-1"]
        monkeypatch.setattr(vmaas_sync, "_fetch_vmaas_pages", lambda *_, **__: (True, cves))

        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                result = sync_cve_md()
            assert result
        assert caplog.records[3].msg.startswith("Deleting")
        assert caplog.records[4].msg == "Finished deleting unnecessary CVE metadata"
        assert caplog.records[5].msg.startswith("Unable to delete")
        caplog.clear()
