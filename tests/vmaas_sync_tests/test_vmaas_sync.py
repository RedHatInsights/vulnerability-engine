# -*- coding: utf-8 -*-
# pylint: disable=no-self-use
"""
Unit tests for vmaas_sync module
"""
import asyncio
import logging
import datetime
import pytest

from aiohttp import WSMsgType

from common.database_handler import DatabasePool
from common import constants

from vmaas_sync.vmaas_sync import SyncHandler, VmaasSyncContext, LOGGER, BaseView, ReEvaluateHandler
import vmaas_sync.vmaas_sync as vmaas_sync
from ..scripts.vmaas_mock import CVES_RESPONSE, REPOS_RESPONSE


class VmaasWebsocketMsgMock:
    """Vmaas websocket mock msg"""
    def __init__(self, data, type_):
        self.data = data
        self.type = type_


class VmaasWebsocketMock:
    """Vmaas websocket mock"""
    def __init__(self, msgs: [VmaasWebsocketMsgMock], close_code=None):
        self.msgs = msgs
        self.close_code = close_code

    async def __aiter__(self):
        for msg in self.msgs:
            await asyncio.sleep(0.01)
            yield msg

    def __iter__(self):
        return iter(self.msgs)


class TestMqueueWriter:
    """Pretends to know how to send kafka msgs"""

    @staticmethod
    async def _do_nothing():
        pass

    def send(self, msg):
        """send from cve sync"""
        LOGGER.info(msg)
        return asyncio.ensure_future(self._do_nothing())

    def send_list(self, msg_list):
        """send from re_evaluate_systems"""
        for msg in msg_list:
            LOGGER.info(msg['host']['id'])
        return asyncio.ensure_future(self._do_nothing())


class TestVmaasSync:
    """Tests for vmaas_sync and friends"""

    @staticmethod
    async def timed_future(coro, time):
        """Run coroutine for specific time"""
        future = asyncio.ensure_future(coro())
        await asyncio.sleep(time)
        future.cancel()

    @staticmethod
    def check_sync_logs(records, start_offset):
        """Check to see we got the expected msgs from sync_cve_md"""
        assert records[start_offset].msg == 'Syncing CVE metadata'
        assert records[start_offset + 1].msg.startswith('Importing CVE metadata')
        assert records[start_offset + 2].msg == 'Finished syncing CVE metadata'

    @staticmethod
    def check_sync_exploits_logs(records, start_offset):
        """Check to see we got the expected msgs from sync_cve_md"""
        assert records[start_offset].msg == 'Syncing CVE Exploits metadata'
        assert records[start_offset + 1].msg == 'Finished syncing CVE Exploits metadata'

    @staticmethod
    def check_re_evaluate_all_logs(records, start_offset):
        """Check to see we got the expected msgs from re_evaluate_vmaas all systems"""
        assert records[start_offset].msg == 'Re-evaluating all systems'

    @staticmethod
    def check_re_eval_repo_based_logs(records, start_offset):
        """Check to see we got the expected msgs from re_evaluate_vmaas repo based"""
        assert records[start_offset].message == '%s repos found updated since 2018-04-04T23:23:45+00:00' \
               % len(REPOS_RESPONSE["repository_list"])
        assert records[start_offset + 1].msg == 'Re-evaluating in repo-based mode'

    def test_sync_cve_md_positive(self, pg_db_conn, monkeypatch, caplog, cleanup):  # pylint: disable=unused-argument
        """Test calling sync_cve_md with vmaas responding with data"""
        monkeypatch.setattr(vmaas_sync, 'paging', lambda endpoint, cve_request: (True, CVES_RESPONSE))

        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                result = SyncHandler.sync_cve_md()
            assert result
        self.check_sync_logs(caplog.records, 0)
        caplog.clear()

    def test_sync_cve_md_negative(self, pg_db_conn, monkeypatch, caplog, cleanup):  # pylint: disable=unused-argument
        """Test calling sync_cve_md with vmaas responding with nothing"""
        monkeypatch.setattr(vmaas_sync, 'paging', lambda endpoint, cve_request: (False, {}))

        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                result = SyncHandler.sync_cve_md()
            assert not result
        assert caplog.records[0].msg == 'Syncing CVE metadata'
        caplog.clear()

    @pytest.mark.asyncio
    async def test_re_evaluate_all(self, pg_db_conn, monkeypatch, caplog):  # pylint: disable=unused-argument
        """Test re_evaluate_systems - all-systems mode"""
        VmaasSyncContext.evaluator_queue = TestMqueueWriter()
        future = asyncio.Future()
        future.set_result(True)
        monkeypatch.setattr(VmaasSyncContext, '_websocket_reconnect', lambda self: future)
        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                await ReEvaluateHandler.re_evaluate_systems(repo_based=False)
        self.check_re_evaluate_all_logs(caplog.records, 0)
        caplog.clear()

    @pytest.mark.asyncio
    async def test_re_evaluate_repo_based(self, pg_db_conn, monkeypatch, caplog):  # pylint: disable=unused-argument
        """Test re_evaluate_systems - repo-based mode with page control"""
        monkeypatch.setattr(vmaas_sync, 'paging', lambda endpoint, repos_request: (True, REPOS_RESPONSE))
        future = asyncio.Future()
        future.set_result(True)
        monkeypatch.setattr(VmaasSyncContext, '_websocket_reconnect', lambda self: future)
        VmaasSyncContext.evaluator_queue = TestMqueueWriter()  # mqueue.MQWriter(mqueue.EVALUATOR_TOPIC)
        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                await ReEvaluateHandler.re_evaluate_systems(repo_based=True)
        self.check_re_eval_repo_based_logs(caplog.records, 0)
        caplog.clear()

    @pytest.mark.asyncio
    async def test_read_websocket(self, pg_db_conn, monkeypatch, caplog):  # pylint: disable=unused-argument
        """Test getting msg from mqueue - requires combined sync_cve/re-evaluate setup"""
        # prep for sync_cve_md
        monkeypatch.setattr(vmaas_sync, 'paging', lambda endpoint, cve_request: (True, CVES_RESPONSE))
        monkeypatch.setattr(vmaas_sync, 'external_service_request', lambda endpoint, method, headers, verify: [{}])
        # prep for re_evaluate_systems
        future = asyncio.Future()
        future.set_result(True)
        monkeypatch.setattr(VmaasSyncContext, '_websocket_reconnect', lambda self: future)

        msg = VmaasWebsocketMsgMock("webapps-refreshed", WSMsgType.TEXT)

        srvapp = VmaasSyncContext()
        srvapp.evaluator_queue = TestMqueueWriter()  # mqueue.MQWriter(mqueue.EVALUATOR_TOPIC)
        srvapp.vmaas_websocket = VmaasWebsocketMock([msg])

        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                await TestVmaasSync.timed_future(srvapp._websocket_loop, 0.1)  # pylint: disable=protected-access

        assert caplog.records[0].msg == 'VMaaS cache refreshed'
        self.check_sync_logs(caplog.records, 1)
        self.check_sync_exploits_logs(caplog.records, 4)
        self.check_re_evaluate_all_logs(caplog.records, 6)
        caplog.clear()

    async def test_bogus_message(self, monkeypatch, caplog):
        """Test getting EMPTY and UNRECOGNIZED msg from mqueue"""
        future = asyncio.Future()
        future.set_result(True)
        monkeypatch.setattr(VmaasSyncContext, '_websocket_reconnect', lambda self: future)

        wrong_msg = VmaasWebsocketMsgMock("blabla", WSMsgType.TEXT)
        srvapp = VmaasSyncContext()
        srvapp.vmaas_websocket = VmaasWebsocketMock([wrong_msg], close_code=666)

        with caplog.at_level(logging.INFO):
            await TestVmaasSync.timed_future(srvapp._websocket_loop, 0.1)  # pylint: disable=protected-access
        assert caplog.records[0].levelname == 'WARNING'
        assert caplog.record_tuples[0][2] == 'Connection to ws://vmaas_websocket:8082/ closed: 666'
        caplog.clear()

    def test_select_inv_ids_1(self, pg_db_conn):
        """Test select all inventory_ids"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            BaseView.select_all_inventory_ids(cur)
            assert len(cur.fetchall()) == 16

    def test_select_inv_ids_2(self, pg_db_conn):
        """Test select inventory_ids repo collection"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            repos = ["repo1"]
            BaseView.select_repo_based_inventory_ids(cur, repos)
            assert len(cur.fetchall()) == 2

    def test_select_inv_ids_3(self, pg_db_conn):
        """Test select inventory_ids with empty repo collection"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            repos = []
            BaseView.select_repo_based_inventory_ids(cur, repos)
            assert list(cur.fetchall()) == []

    def test_last_repobased_eval_tms_1(self, pg_db_conn):
        """Test select repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            val = BaseView.get_last_repobased_eval_tms(cur)
            assert val is not None

    def test_last_repobased_eval_tms_2(self, pg_db_conn):
        """Test select empty repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            cur.execute("delete from timestamp_kv where name = %s", (constants.TIMESTAMP_LAST_REPO_BASED_EVAL,))
            val = BaseView.get_last_repobased_eval_tms(cur)
            assert val is None

    def test_last_repobased_eval_tms_3(self, pg_db_conn):
        """Test update repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            cur.execute("delete from timestamp_kv where name = %s", (constants.TIMESTAMP_LAST_REPO_BASED_EVAL,))
            val = datetime.datetime(2014, 1, 1, 8, 1, 1, tzinfo=datetime.timezone(datetime.timedelta(hours=2)))
            val_ret, inserted = BaseView.set_last_repobased_eval_tms(cur, val)
            assert inserted
            assert val_ret.isoformat() == '2014-01-01T06:01:01+00:00'

    def test_last_repobased_eval_tms_4(self, pg_db_conn):
        """Test update repo-based eval timestamp"""
        with pg_db_conn:
            cur = pg_db_conn.cursor()
            val = datetime.datetime(2014, 1, 1, 6, 1, 1, tzinfo=datetime.timezone(datetime.timedelta(hours=2)))
            val_ret, inserted = BaseView.set_last_repobased_eval_tms(cur, val)
            assert not inserted  # updated
            assert val_ret.isoformat() == '2014-01-01T04:01:01+00:00'

    def test_sync_cve_md_delete(self, pg_db_conn, monkeypatch, caplog, cleanup):  # pylint: disable=unused-argument
        """Test calling sync_cve_md with vmaas responding with data"""
        cves = CVES_RESPONSE.copy()
        del cves['cve_list']['CVE-2017-3']
        del cves['cve_list']['CVE-2018-1']
        monkeypatch.setattr(vmaas_sync, 'paging', lambda endpoint, cve_request: (True, cves))

        with caplog.at_level(logging.INFO):
            with DatabasePool(1):
                result = SyncHandler.sync_cve_md()
            assert result
        assert caplog.records[2].msg.startswith('Deleting')
        assert caplog.records[3].msg == 'Finished deleting unnecessary CVE metadata'
        assert caplog.records[4].msg.startswith('Unable to delete')
        caplog.clear()
