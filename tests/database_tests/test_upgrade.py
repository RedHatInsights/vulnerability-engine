# pylint: disable=no-self-use
"""
Test database upgrades
"""
import difflib
import os
import re
import subprocess

import pytest
from git import Repo

import common.database_handler
from ..utils import get_pg_class, set_env, VULN_ENG_DIR


UPGRADE_FROM = os.getenv("UPGRADE_FROM", "4448350601fc0b9f0fb65b4e49e0af8f66018587")
UPGRADE_TO = os.getenv("UPGRADE_TO", None)
STATIC_TABLES = ["db_version", "cve_impact", "status"]


class TestUpgrade:
    """Tests for vulnerability-engine database upgrade."""

    repo = Repo(VULN_ENG_DIR)
    if repo.head.is_detached:
        # HEAD is detached in Travis, create branch from head.commit
        head = repo.create_head(repo.head.commit.name_rev[:7], commit=repo.head.commit.hexsha)
    else:
        head = repo.head.reference

    def _git_checkout(self, commit):
        """Perform git checkout specified by commit and stash current work"""
        stashed = False
        if self.repo.is_dirty():
            self.repo.git.stash()
            stashed = True
        # checkout branch `commit` or branch from what tests where executed
        self.repo.head.reference = self.head
        if commit:
            self.repo.head.reference = self.repo.create_head(commit[:7], commit=commit)
        self.repo.head.reset(index=True, working_tree=True)
        return stashed

    def _git_co_teardown(self, commit, stashed):
        """Checkout to previous branch and apply last stash"""
        self.repo.head.reference = self.head
        self.repo.head.reset(index=True, working_tree=True)
        if commit:
            self.repo.delete_head(commit[:7])
        if stashed:
            self.repo.git.stash("pop")

    @pytest.fixture
    def pg_old(self, commit=UPGRADE_FROM):
        """Setup DB that will be upgraded."""
        stashed = self._git_checkout(commit)
        # start DB with old schema, also path to init scripts was different
        ve_user = VULN_ENG_DIR.joinpath("database", "ve_db_user_create_postgresql.sql")
        ve_pg = VULN_ENG_DIR.joinpath("database", "ve_db_postgresql.sql")
        ve_data = VULN_ENG_DIR.joinpath("database", "ve_db_dev_data.sql")
        postgres_class = get_pg_class(ve_user=ve_user, ve_pg=ve_pg, ve_data=ve_data)
        postgres = postgres_class()
        set_env(postgres)
        yield postgres

        postgres.stop()
        postgres_class.clear_cache()
        self._git_co_teardown(commit, stashed)

    @pytest.fixture
    def pg_new(self, commit=UPGRADE_TO):
        """Setup DB that uses already upgraded schema."""
        stashed = self._git_checkout(commit)
        # start DB with new schema
        postgres_class = get_pg_class()
        postgres = postgres_class()
        set_env(postgres)
        yield postgres

        postgres.stop()
        postgres_class.clear_cache()
        self._git_co_teardown(commit, stashed)

    def _create_dump(self, args):
        dump = subprocess.check_output(args).decode("utf-8")
        dump = re.sub(r"\n+", "\n", dump).splitlines()
        dump.sort()
        return dump

    def test_upgrade(self, pg_old, pg_new):
        """Test schema upgrade."""
        env_old = pg_old.dsn()
        env_new = pg_new.dsn()

        common.database_handler.DB_USER = "ve_db_admin"
        common.database_handler.DB_PASS = "ve_db_admin_pwd"
        common.database_handler.DB_NAME = env_old["database"]
        common.database_handler.DB_HOST = env_old["host"]
        common.database_handler.DB_PORT = int(env_old["port"])

        from database.upgrade import upgrade
        upgrade.main()

        schema_old_args = [
            "pg_dump", "-s",
            "-h", str(env_old["host"]),
            "-p", str(env_old["port"]),
            "-U", env_old["user"],
            "-d", env_old["database"],
        ]
        schema_new_args = [
            "pg_dump", "-s",
            "-h", str(env_new["host"]),
            "-p", str(env_new["port"]),
            "-U", env_new["user"],
            "-d", env_new["database"],
        ]

        dump_old = self._create_dump(schema_old_args)
        dump_new = self._create_dump(schema_new_args)
        try:
            assert dump_old == dump_new
        except AssertionError:
            diff = difflib.unified_diff(dump_old, dump_new)
            diffs = "\n".join([x for x in diff])
            assert False, f"Diff:\n{diffs}"

        data_args = ["pg_dump", "-a"]
        for table_name in STATIC_TABLES:
            data_args.append("-t")
            data_args.append(table_name)
        data_old_args = data_args + [
            "-h", str(env_old["host"]),
            "-p", str(env_old["port"]),
            "-U", env_old["user"],
            "-d", env_old["database"],
        ]
        data_new_args = data_args + [
            "-h", str(env_new["host"]),
            "-p", str(env_new["port"]),
            "-U", env_new["user"],
            "-d", env_new["database"],
        ]

        dump_old = self._create_dump(data_old_args)
        dump_new = self._create_dump(data_new_args)
        try:
            assert dump_old == dump_new
        except AssertionError:
            diff = difflib.unified_diff(dump_old, dump_new)
            diffs = "\n".join([x for x in diff])
            assert False, f"Diff:\n{diffs}"
