# -*- coding: utf-8 -*-
"""
Methods for vulnerability API testing.
"""
import base64
import json

from tornado.testing import AsyncHTTPTestCase

from box import Box

from .schemas import SCHEMA_MAP

URL_BASE = "/r/insights/platform/vulnerability/v1.0"

INTERNAL_IDENTITY = {
    "identity": {
        "account_number": "00000000",
        "type": "User",
        "user": {
            "username": "jdoe@acme.com",
            "email": "jdoe@acme.com",
            "first_name": "john",
            "last_name": "doe",
            "is_active": True,
            "is_org_admin": False,
            "is_internal": False,
            "locale": "en_US",
        },
        "internal": {"org_id": 3_340_851, "auth_type": "basic-auth", "auth_time": 6300},
    }
}

RH_IDENTITY_HEADER = {
    "x-rh-identity": base64.b64encode(json.dumps(INTERNAL_IDENTITY).encode("utf-8"))
}


# pylint: disable=abstract-method
class VulnHTTPTestCase(AsyncHTTPTestCase):
    """Base class for vulnerability testcases."""

    def vfetch(self, path, **kwargs):
        """Fetch method for vulnerability API."""
        path = "{}/{}".format(URL_BASE, path.lstrip("/"))
        headers = kwargs.get("headers") or {}
        headers.update(RH_IDENTITY_HEADER)
        kwargs["headers"] = headers
        response = self.fetch(path, **kwargs)
        return EngineResponse(response)


class EngineResponse:
    """API response representation."""

    def __init__(self, response):
        self.raw = response
        self.body = self.load(response)

    @staticmethod
    def load(response):
        """Loads the response content."""
        parsed = None
        try:
            parsed = json.loads(response.body)
        # pylint: disable=broad-except
        except Exception:
            pass

        if not parsed and response.body:
            parsed = str(response.body, "utf-8")

        try:
            return Box(parsed, box_it_up=True)
        except ValueError:
            return parsed or Box()

    def validate_schema(self):
        """Validates response against schema."""
        url = self.raw.effective_url
        for path, schema in SCHEMA_MAP.items():
            if path in url:
                schema.validate(self.body)
                break

    # pylint: disable=invalid-name
    @property
    def ok(self):
        """Checks if response has return code that indicates success."""
        if self.raw and self.raw.code >= 200 and self.raw.code < 400:
            return True
        return False

    def check_response(self, status_code=None, validate=True):
        """Asserts that the response HTTP status code and content is as expected."""
        if status_code:
            if self.raw.code != status_code:
                raise AssertionError(
                    "Expected status code {}, got {}".format(status_code, self.raw.code)
                )
        elif not self.ok:
            raise AssertionError("Request failed with {}".format(self.raw.code))

        try:
            if self.ok and "errors" in self.body:
                raise AssertionError("Errors returned: {}".format(self.body.errors))
        except TypeError:
            pass

        if validate and self.ok:
            self.validate_schema()

        return self

    def __getattr__(self, name):
        return getattr(self.raw, name)

    def __repr__(self):
        return "<EngineResponse(raw={!r})>".format(self.raw)
