# -*- coding: utf-8 -*-
# pylint: disable=no-self-use
"""
Unit tests for advisor listener
"""

import asyncio
from copy import deepcopy
import logging
import pytest

import advisor_listener.advisor_listener as advisor_listener
from advisor_listener.advisor_listener import ADVISOR_QUEUE, CVES_CACHE, db_init_caches, db_import_cve, db_import_rule, \
    db_import_system, db_import_system_platform, RULES_CACHE, terminate, parse_inventory_data, _parse_passes, _parse_reports,  \
    db_import_rule_hits
from common.database_handler import DatabasePool, DatabasePoolConnection
from common import utils

SYSTEM_DICT = {
    'input': {
        'host': {
            'account': '0',
            'display_name': 'xxee',
            'id': None,
            'stale_timestamp': '2100-01-01',
            'stale_warning_timestamp': '2100-01-01',
            'culled_timestamp': '2100-01-01',
        }
    }
}

SYSTEM = {
    'rh_account': '0',
    'display_name': 'xxee',
    'inventory_id': None,
    'stale_timestamp': '2100-01-01',
    'stale_warning_timestamp': '2100-01-01',
    'culled_timestamp': '2100-01-01',
}

ADVISOR_JSON = 'NEW_JSON'

ADVISOR_JSON_RULES = {"results": {
    "reports": [{
        "rule_id": "CVE_2018_rpm|CVE_2018_131131_64664_rpm",
        "component": "xxx",
        "type": "rule",
        "key": "CVE_2018_131131_64664_rpm",
        "details": {
            "rhel-version": 8,
            "cves": {
                "CVE-2014-1": False,
                "CVE-2018-2": False,
                "CVE-2018-3": False
            },
            "type": "rule",
            "error_key": "CVE_2018_131131_64664_rpm"
        },
    }, {
        "rule_id": "CVE_2017_dnf|CVE_2017_598375_23842_dnf",
        "component": "xxx",
        "type": "rule",
        "key": "CVE_2017_598375_23842_dnf",
        "details": {
            "cves": {
                "CVE-2017-6": False,
                "CVE-2016-2": False
            },
            "type": "rule",
            "error_key": "CVE_2017_598375_23842_dnf"
        }
    }],
    "pass": [{
        "pass_id": "CVE_2017_kernel|All CVEs passed.",
        "component": "xxx",
        "type": "pass",
        "key": "All CVEs passed.",
        "details": {
            "cves": {
                "CVE-2017-1": "Vulnerable kernel not running"
            },
            "type": "pass",
            "pass_key": "All CVEs passed."
        }
    }, {
        "pass_id": "CVE_2016_vpn|All CVEs passed.",
        "component": "xxx",
        "type": "pass",
        "key": "All CVEs passed.",
        "details": {
            "cves": {
                "CVE-2016-1": "VPN not running.",
                "CVE-2019-1": "VPN not running."
            },
            "type": "pass",
            "pass_key": "All CVEs passed."
        }
    }
    ]}}

JSON_RULE_PASSES = ["CVE_2017_kernel", "CVE_2016_vpn"]
JSON_RULE_HITS = ["CVE_2018_rpm|CVE_2018_131131_64664_rpm", "CVE_2017_dnf|CVE_2017_598375_23842_dnf"]
JSON_RULE_PASSES_CVES = ["CVE-2017-1", "CVE-2016-1", "CVE-2019-1"]
JSON_RULE_HITS_CVES = ["CVE-2014-1", "CVE-2018-2", "CVE-2018-3", "CVE-2017-6", "CVE-2016-2"]

TESTED_SYSTEM_ID = 3
TESTED_RH_ACCOUNT_ID = 0

# Completely new CVEs in rules which are hit (failed, reported)
SYSTEM_NEW_CVES_HIT = ["CVE-2018-2", "CVE-2018-3", "CVE-2016-2"]
# Completely new CVEs in rules which are passes
SYSTEM_NEW_CVES_PASS = ["CVE-2019-1"]
# CVEs which are in vulnerability as not mitigated but are pass (mitigated) in advisor result
SYSTEM_HIT_TO_PASS_CVES = ["CVE-2017-1"]
# CVEs which are mitigated in vulnerability but system is still vulnerable, rule hit (failed, reported)
SYSTEM_PASS_TO_HIT_CVES = ["CVE-2017-6"]
# CVEs which are not mitigated in vulnerability and are still not mitigated from advisor
SYSTEM_HIT_TO_HIT_CVES = ["CVE-2014-1"]
# CVEs which are mitigated in vulnerability and are mitigated by advisor
SYSTEM_PASS_TO_PASS_CVES = ["CVE-2016-1"]
# Rules which system gets updated
SYSTEM_UPDATED_RULES = ["CVE_2018_rpm|CVE_2018_131131_64664_rpm", "CVE_2016_vpn", "CVE_2017_kernel", "CVE_2017_dnf|CVE_2017_598375_23842_dnf"]


class TestAdvisorListener:
    """Tests for advisor listener"""

    def _clear_caches(self):
        advisor_listener.RULES_CACHE = {}
        advisor_listener.CVES_CACHE = {}

    @pytest.mark.asyncio
    async def test_terminate(self):
        """Test terminate"""
        loop = asyncio.new_event_loop()
        await terminate(0, loop)
        assert not loop.is_running()
        assert not ADVISOR_QUEUE.connected

    def test_init_caches(self, pg_db_conn):  # pylint: disable=unused-argument
        """Test init caches, THIS HAS TO BE FIRST TEST IN CASE YOU DO NOT WANT CALL db_init_caches EXPLICTLY IN YOUR TESTS"""
        with DatabasePool(1):
            db_init_caches()
        assert len(CVES_CACHE) == 17
        assert len(RULES_CACHE) == 13

    def test_import_cve_no_vmaas(self, pg_db_conn):  # pylint: disable=unused-argument
        """Tests insertion of single CVE into database"""
        with DatabasePool(1):
            db_import_cve('CVE-2019-1')
        assert 'CVE-2019-1' in CVES_CACHE

    def test_import_cve_vmaas(self, pg_db_conn, monkeypatch):  # pylint: disable=unused-argument
        """Tests insertion of single CVE into database using VMAAS"""
        cve_response_mock = {"cve_list":
                             {"CVE-2021-1":
                              {"impact": "High",
                               "public_date": "2018-01-04T13:29:00+00:00",
                               "synopsis": "CVE-2021-1",
                               "description": "description text",
                               "modified_date": "2018-03-31T01:29:00+00:00",
                               "redhat_url": "https://access.redhat.com/security/cve/cve-2021-1",
                               "secondary_url": "https://seconday.url.com",
                               "cvss2_score": "5.600",
                               "cvss2_metrics": "AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                               "cvss3_score": "5.1",
                               "cvss3_metrics": "AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                               "cwe_list": [
                                         "CWE-20"
                               ],
                               "errata_list": [
                                   "RHSA-2015:1981"
                               ],
                               "package_list": [
                                   "nss-devel-3.16.1-9.el6_5.x86_64"
                               ],
                               "source_package_list": [
                                   "nss-devel-3.16.1-9.el6_5.src"
                               ]}}}

        def vmaas_mock(*_, **__):
            return cve_response_mock

        monkeypatch.setattr(utils, "external_service_request", vmaas_mock)

        with DatabasePool(1):
            db_import_cve('CVE-2021-1')
        assert 'CVE-2021-1' in CVES_CACHE

    def test_fail_import_cve(self, pg_db_conn, caplog, monkeypatch):  # pylint:  disable=unused-argument
        """Tests handling of unexpected scenarios"""
        monkeypatch.setattr(advisor_listener, "format_vmaas_cve_endpoint", lambda _: "http://vmaas")
        with caplog.at_level(logging.ERROR):
            with DatabasePool(1):
                db_import_cve({})
        assert caplog.records[-1].msg == 'Error during inserting CVE: '

    def test_import_rule(self, pg_db_conn):  # pylint: disable=unused-argument
        """Test inserting new rule into database"""
        with DatabasePool(1):
            db_import_rule('test_rule|ERROR_KEY', ['CVE-2018-1', 'CVE-2018-2'])
            assert 'test_rule|ERROR_KEY' in RULES_CACHE
        with DatabasePool(2):
            db_import_rule('test_rule|CVES_NOT_IN_DB', ['CVE-2020-1', 'CVE-2020-2'])
            assert 'test_rule|CVES_NOT_IN_DB' in RULES_CACHE

    def test_fail_import_rule(self, pg_db_conn, caplog):  # pylint:  disable=unused-argument
        """Tests handling of unexpected scenarios"""
        with caplog.at_level(logging.ERROR):
            with DatabasePool(1):
                db_import_rule({}, [])
        assert caplog.records[0].msg == 'Error during inserting rule: '

    def test_import_system_platform(self, pg_db_conn):  # pylint: disable=unused-argument
        """Test insertion of system data"""
        with DatabasePool(1):
            with DatabasePoolConnection() as conn:
                with conn.cursor() as cur:
                    system = deepcopy(SYSTEM)
                    system['inventory_id'] = 'b1f21450-0000-1111-2222-000000000001'
                    db_import_system_platform(cur, system, ADVISOR_JSON)  # import new system
                    db_import_system_platform(cur, system, ADVISOR_JSON)  # update recently imported system

    def test_simple_import(self, pg_db_conn, monkeypatch):  # pylint: disable=unused-argument
        """Test importing new system with one rule"""
        monkeypatch.setattr(advisor_listener, 'send_msg_to_payload_tracker', lambda producer, msg_dict, status, status_msg, service=None: None)
        with DatabasePool(1):
            system = deepcopy(SYSTEM_DICT)
            system['input']['host']['id'] = 'b1f21450-0000-1111-2222-000000000002'
            rule_hits = {}
            rule_hits[CVES_CACHE['CVE-2014-1']] = {
                'id': RULES_CACHE['CVE_2018_3639_cpu_kernel|CVE_2018_3639_CPU_BAD_MICROCODE_2'],
                'details': '{"detail_key": "detail_value"}',
                'cve_name': 'CVE-2014-1'
            }
            db_import_system(system, rule_hits, ADVISOR_JSON)
            # add a additional CVE to rule
            rule_hits[CVES_CACHE['CVE-2016-1']] = {
                'id': RULES_CACHE['CVE_2018_3639_cpu_kernel|CVE_2018_3639_CPU_BAD_MICROCODE_2'],
                'details': '{"detail_key": "detail_value"}',
                'cve_name': 'CVE-2016-1'
            }
            db_import_system(system, rule_hits, ADVISOR_JSON)

    def test_pass_import(self, pg_db_conn, monkeypatch):  # pylint: disable=unused-argument
        """Test importing pass info"""
        monkeypatch.setattr(advisor_listener, 'send_msg_to_payload_tracker', lambda producer, msg_dict, status, status_msg, service=None: None)

        with DatabasePool(1):
            system = deepcopy(SYSTEM_DICT)
            system['input']['host']['id'] = '2a104733-c60d-4446-a9ea-bbf30851bc79'
            rule_hits = {}
            rule_hits[CVES_CACHE['CVE-2017-1']] = {
                'id': RULES_CACHE['CVE_2018_12207_cpu_kernel'],
                'mitigation_reason': 'Kernel is OK'
            }
            db_import_system(system, rule_hits, ADVISOR_JSON)

    @staticmethod
    def _import_rule_pass_mock(rule_name, *_, **__):
        """Mock for db_import_rule for pass parsing test"""
        assert rule_name in JSON_RULE_PASSES
        advisor_listener.RULES_CACHE[rule_name] = rule_name

    @staticmethod
    def _import_cve_rule_pass_mock(cve):
        """Mock for db_import_cve for pass parsing test"""
        assert cve in JSON_RULE_PASSES_CVES
        advisor_listener.CVES_CACHE[cve] = cve

    @staticmethod
    def _import_rule_hit_mock(rule_name, *_, **__):
        """Mock for db_import_rule for hits parsing test"""
        assert rule_name in JSON_RULE_HITS
        advisor_listener.RULES_CACHE[rule_name] = rule_name

    @staticmethod
    def _import_cve_rule_hit_mock(cve):
        """Mock for db_import_cve for hits parsing test"""
        assert cve in JSON_RULE_HITS_CVES
        advisor_listener.CVES_CACHE[cve] = cve

    def test_result_pass_parsing(self, monkeypatch):
        """Test parsing of input from advisor, passes"""
        # Ensure that import functions are called
        self._clear_caches()

        passes = ADVISOR_JSON_RULES["results"].get("pass", [])
        monkeypatch.setattr(advisor_listener, "db_import_rule", TestAdvisorListener._import_rule_pass_mock)
        monkeypatch.setattr(advisor_listener, "db_import_cve", TestAdvisorListener._import_cve_rule_pass_mock)

        rule_passes = {}
        passed = _parse_passes(passes, rule_passes)
        for cve in JSON_RULE_PASSES_CVES:
            assert cve in rule_passes
        assert passed is True

    def test_result_hit_parsing(self, monkeypatch):
        """Test parsing of input from advisor, hits"""
        # Ensure that import functions are called
        self._clear_caches()

        hits = ADVISOR_JSON_RULES["results"].get("reports", [])
        monkeypatch.setattr(advisor_listener, "db_import_rule", TestAdvisorListener._import_rule_hit_mock)
        monkeypatch.setattr(advisor_listener, "db_import_cve", TestAdvisorListener._import_cve_rule_hit_mock)

        rule_hits = {}
        reported = _parse_reports(hits, rule_hits)
        for cve in JSON_RULE_HITS_CVES:
            assert cve in rule_hits
        assert reported is True

    @staticmethod
    def _import_rule_mock(rule_name, *_, **__):
        """Mock for db_import_rule"""
        assert rule_name in JSON_RULE_HITS + JSON_RULE_PASSES
        advisor_listener.RULES_CACHE[rule_name] = rule_name

    @staticmethod
    def _import_cve_rule_mock(cve):
        """Mock for db_import_cve"""
        assert cve in JSON_RULE_HITS_CVES + JSON_RULE_PASSES_CVES
        advisor_listener.CVES_CACHE[cve] = cve

    def test_whole_inv_parsing(self, monkeypatch):
        """Test parsing of whole inv result from advisor"""
        self._clear_caches()

        monkeypatch.setattr(advisor_listener, "db_import_rule", TestAdvisorListener._import_rule_mock)
        monkeypatch.setattr(advisor_listener, "db_import_cve", TestAdvisorListener._import_cve_rule_mock)

        advisor_json, rule_hits = parse_inventory_data(ADVISOR_JSON_RULES)
        for cve in JSON_RULE_HITS_CVES + JSON_RULE_PASSES_CVES:
            assert cve in rule_hits
        assert advisor_json is not None

    @staticmethod
    def _insert_new_cves_mock(_, rh_account_id, system_id, new_rule_hits):
        """Mock for insert new cves mock, checks if the CVEs are correct by the JSON"""
        assert rh_account_id == TESTED_RH_ACCOUNT_ID
        assert system_id == TESTED_SYSTEM_ID
        for cve in SYSTEM_NEW_CVES_HIT + SYSTEM_NEW_CVES_PASS:
            assert advisor_listener.CVES_CACHE[cve] in new_rule_hits

    @staticmethod
    def _update_cves_mock(_, to_update, rh_account_id):
        """Mock for the update of the CVEs by test JSON"""
        inverse_rules_cache = {v: k for k, v in advisor_listener.RULES_CACHE.items()}
        assert rh_account_id == TESTED_RH_ACCOUNT_ID
        for row in to_update:
            assert row[1] == TESTED_RH_ACCOUNT_ID
            if row[2] is not None:
                assert inverse_rules_cache[row[2]] in SYSTEM_UPDATED_RULES

    def test_cve_rule_import_and_update(self, monkeypatch):
        """Test rule import and update of the CVEs of particular system"""
        self._clear_caches()

        monkeypatch.setattr(advisor_listener, "send_remediations_update", lambda _, __, ___, ____: None)

        with DatabasePool(2):
            db_init_caches()
            _, rule_hits = parse_inventory_data(ADVISOR_JSON_RULES)

        monkeypatch.setattr(advisor_listener, "update_cves", TestAdvisorListener._update_cves_mock)
        monkeypatch.setattr(advisor_listener, "insert_new_cves", TestAdvisorListener._insert_new_cves_mock)

        with DatabasePool(2):
            with DatabasePoolConnection() as conn:
                with conn.cursor() as cur:
                    db_import_rule_hits(cur, TESTED_RH_ACCOUNT_ID, "", TESTED_SYSTEM_ID, rule_hits)

    def test_main(self, caplog, monkeypatch):
        """Test main"""
        advisor_listener.CFG.worker_threads = 1

        class LoopMock:
            """Event loop mock for main testing"""
            loop = asyncio.get_event_loop()

            def run_until_complete(self, *args, **kwargs):
                """Wrapper run_until_complete"""
                return LoopMock.loop.run_until_complete(*args, **kwargs)

            def add_signal_handler(self, *args, **kwargs):
                """Wrapper add_signal_handler"""
                return LoopMock.loop.add_signal_handler(*args, **kwargs)

            def create_task(self, *args, **kwargs):
                """Wrapper create_task"""
                return LoopMock.loop.create_task(*args, **kwargs)

            def run_forever(self, *args, **kwargs):
                """Dont run forever, just mock for tests"""

            def get_debug(self, *args, **kwargs):
                """Get debug mock"""
                return LoopMock.loop.get_debug(*args, **kwargs)

        def get_event_loop_mock_single():
            if get_event_loop_mock_single.popped:
                return LoopMock.loop
            get_event_loop_mock_single.popped = True
            return LoopMock()

        get_event_loop_mock_single.popped = False
        advisor_listener.ADVISOR_QUEUE.listen = lambda _: None
        monkeypatch.setattr(asyncio, "get_event_loop", get_event_loop_mock_single)

        with caplog.at_level(logging.INFO):
            advisor_listener.main()
        assert "Starting advisor listener" in caplog.messages[4]
        assert "Shutting down" in caplog.messages[5]
