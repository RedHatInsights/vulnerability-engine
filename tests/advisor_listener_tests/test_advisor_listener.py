# -*- coding: utf-8 -*-
# pylint: disable=no-self-use
"""
Unit tests for advisor listener
"""

from copy import deepcopy
import logging

from asyncpg.exceptions import DataError
import pytest

import advisor_listener.advisor_listener as advisor_listener
from advisor_listener.advisor_listener import CVES_CACHE, db_init_caches, db_import_cve, db_import_rule, \
    db_import_system, db_import_system_platform, RULES_CACHE, parse_inventory_data, _parse_passes, _parse_reports, \
    db_import_rule_hits, update_cves

SYSTEM_DICT = {
    'input': {
        'host': {
            'account': '0',
            'display_name': 'xxee',
            'id': None,
            'stale_timestamp': '2100-01-01',
            'stale_warning_timestamp': '2100-01-01',
            'culled_timestamp': '2100-01-01',
        }
    }
}

SYSTEM = {
    'rh_account': '0',
    'display_name': 'xxee',
    'inventory_id': None,
    'stale_timestamp': '2100-01-01',
    'stale_warning_timestamp': '2100-01-01',
    'culled_timestamp': '2100-01-01',
}

ADVISOR_JSON = 'NEW_JSON'

ADVISOR_JSON_RULES = {"results": {
    "reports": [{
        "rule_id": "CVE_2018_rpm|CVE_2018_131131_64664_rpm",
        "component": "xxx",
        "type": "rule",
        "key": "CVE_2018_131131_64664_rpm",
        "details": {
            "rhel-version": 8,
            "cves": {
                "CVE-2014-1": False,
                "CVE-2018-2": False,
                "CVE-2018-3": False
            },
            "type": "rule",
            "error_key": "CVE_2018_131131_64664_rpm"
        },
    }, {
        "rule_id": "CVE_2017_dnf|CVE_2017_598375_23842_dnf",
        "component": "xxx",
        "type": "rule",
        "key": "CVE_2017_598375_23842_dnf",
        "details": {
            "cves": {
                "CVE-2017-6": False,
                "CVE-2016-2": False
            },
            "type": "rule",
            "error_key": "CVE_2017_598375_23842_dnf"
        }
    }],
    "pass": [{
        "pass_id": "CVE_2017_kernel|All CVEs passed.",
        "component": "xxx",
        "type": "pass",
        "key": "All CVEs passed.",
        "details": {
            "cves": {
                "CVE-2017-1": "Vulnerable kernel not running"
            },
            "type": "pass",
            "pass_key": "All CVEs passed."
        }
    }, {
        "pass_id": "CVE_2016_vpn|All CVEs passed.",
        "component": "xxx",
        "type": "pass",
        "key": "All CVEs passed.",
        "details": {
            "cves": {
                "CVE-2016-1": "VPN not running.",
                "CVE-2019-1": "VPN not running."
            },
            "type": "pass",
            "pass_key": "All CVEs passed."
        }
    }
    ]}}

JSON_RULE_PASSES = ["CVE_2017_kernel", "CVE_2016_vpn"]
JSON_RULE_HITS = ["CVE_2018_rpm|CVE_2018_131131_64664_rpm", "CVE_2017_dnf|CVE_2017_598375_23842_dnf"]
JSON_RULE_PASSES_CVES = ["CVE-2017-1", "CVE-2016-1", "CVE-2019-1"]
JSON_RULE_HITS_CVES = ["CVE-2014-1", "CVE-2018-2", "CVE-2018-3", "CVE-2017-6", "CVE-2016-2"]

TESTED_SYSTEM_ID = 3
TESTED_RH_ACCOUNT_ID = 0

# Completely new CVEs in rules which are hit (failed, reported)
SYSTEM_NEW_CVES_HIT = ["CVE-2018-2", "CVE-2018-3", "CVE-2016-2"]
# Completely new CVEs in rules which are passes
SYSTEM_NEW_CVES_PASS = ["CVE-2019-1"]
# CVEs which are in vulnerability as not mitigated but are pass (mitigated) in advisor result
SYSTEM_HIT_TO_PASS_CVES = ["CVE-2017-1"]
# CVEs which are mitigated in vulnerability but system is still vulnerable, rule hit (failed, reported)
SYSTEM_PASS_TO_HIT_CVES = ["CVE-2017-6"]
# CVEs which are not mitigated in vulnerability and are still not mitigated from advisor
SYSTEM_HIT_TO_HIT_CVES = ["CVE-2014-1"]
# CVEs which are mitigated in vulnerability and are mitigated by advisor
SYSTEM_PASS_TO_PASS_CVES = ["CVE-2016-1"]
# Rules which system gets updated
SYSTEM_UPDATED_RULES = ["CVE_2018_rpm|CVE_2018_131131_64664_rpm", "CVE_2016_vpn", "CVE_2017_kernel", "CVE_2017_dnf|CVE_2017_598375_23842_dnf"]


def empty_fun(*_, **__):
    """Empty function for mocking"""
    return True


async def empty_fun_async(*_, **__):
    """Empty function in async"""
    return True


class DbPoolMock:
    """Db pool mock"""

    def acquire(self):
        """Mock for database pool"""


class ConnContextMock:
    """Connection mock"""

    def __init__(self, aconn):
        self.aconn = aconn

    async def __aenter__(self):
        return self.aconn

    async def __aexit__(self, *_, **__):
        pass


class ConnMock:
    """Connection mock"""
    def __init__(self, return_val):
        self.return_val = return_val

    async def fetchrow(self, *_, **__):
        """Fetchrow mock returning set value"""
        return self.return_val

    def transaction(self):
        """Transaction mock"""
        return self

    async def __aenter__(self):
        return self

    async def __aexit__(self, *_, **__):
        pass


class TestAdvisorListener:
    """Tests for advisor listener"""

    def _clear_caches(self):
        advisor_listener.RULES_CACHE = {}
        advisor_listener.CVES_CACHE = {}

    @pytest.mark.asyncio
    async def test_init_caches(self, asyncio_conn, pg_db_conn, monkeypatch):  # pylint: disable=unused-argument
        """Test init caches, THIS HAS TO BE FIRST TEST IN CASE YOU DO NOT WANT CALL db_init_caches EXPLICTLY IN YOUR TESTS"""
        advisor_listener.DB_POOL = DbPoolMock()
        monkeypatch.setattr(advisor_listener.DB_POOL, "acquire", lambda: ConnContextMock(asyncio_conn))
        await advisor_listener.db_init_caches()

        assert len(CVES_CACHE) == 17
        assert len(RULES_CACHE) == 13

    @pytest.mark.asyncio
    async def test_import_cve_no_vmaas(self, pg_db_conn, asyncio_conn):  # pylint: disable=unused-argument
        """Tests insertion of single CVE into database"""
        await db_import_cve('CVE-2019-1', asyncio_conn)
        assert 'CVE-2019-1' in CVES_CACHE

    @pytest.mark.asyncio
    async def test_import_cve_vmaas(self, pg_db_conn, asyncio_conn, monkeypatch):  # pylint: disable=unused-argument
        """Tests insertion of single CVE into database using VMAAS"""
        cve_response_mock = {
            "cve_list":
                {
                    "CVE-2021-1":
                        {
                            "impact": "High",
                            "public_date": "2018-01-04T13:29:00+00:00",
                            "synopsis": "CVE-2021-1",
                            "description": "description text",
                            "modified_date": "2018-03-31T01:29:00+00:00",
                            "redhat_url": "https://access.redhat.com/security/cve/cve-2021-1",
                            "secondary_url": "https://seconday.url.com",
                            "cvss2_score": "5.600",
                            "cvss2_metrics": "AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                            "cvss3_score": "5.1",
                            "cvss3_metrics": "AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N",
                            "cwe_list": [
                                "CWE-20"
                            ],
                            "errata_list": [
                                "RHSA-2015:1981"
                            ],
                            "package_list": [
                                "nss-devel-3.16.1-9.el6_5.x86_64"
                            ],
                            "source_package_list": [
                                "nss-devel-3.16.1-9.el6_5.src"
                            ]
                        }
                }
        }

        async def vmaas_mock(*_, **__):
            return cve_response_mock

        monkeypatch.setattr(advisor_listener, "vmaas_request", vmaas_mock)

        async with asyncio_conn.transaction():
            await db_import_cve('CVE-2021-1', asyncio_conn)
        assert 'CVE-2021-1' in CVES_CACHE

    @pytest.mark.asyncio
    async def test_fail_import_cve(self, pg_db_conn, asyncio_conn, caplog, monkeypatch):  # pylint:  disable=unused-argument
        """Tests handling of unexpected scenarios"""
        monkeypatch.setattr(advisor_listener, "format_vmaas_cve_endpoint", lambda _: "http://vmaas")
        with pytest.raises(DataError):
            await db_import_cve({}, asyncio_conn)

    @pytest.mark.asyncio
    async def test_import_rule(self, pg_db_conn, asyncio_conn):  # pylint: disable=unused-argument
        """Test inserting new rule into database"""
        await db_import_rule('test_rule|ERROR_KEY', ['CVE-2018-1', 'CVE-2018-2'], asyncio_conn)
        assert 'test_rule|ERROR_KEY' in RULES_CACHE
        await db_import_rule('test_rule|CVES_NOT_IN_DB', ['CVE-2020-1', 'CVE-2020-2'], asyncio_conn)
        assert 'test_rule|CVES_NOT_IN_DB' in RULES_CACHE

    @pytest.mark.asyncio
    async def test_fail_import_rule(self, pg_db_conn, asyncio_conn, caplog):  # pylint:  disable=unused-argument
        """Tests handling of unexpected scenarios"""
        with pytest.raises(DataError):
            await db_import_rule({}, [], asyncio_conn)

    @pytest.mark.asyncio
    async def test_import_system_platform(self, pg_db_conn, asyncio_conn):  # pylint: disable=unused-argument
        """Test insertion of system data"""
        system = deepcopy(SYSTEM)
        system['inventory_id'] = 'b1f21450-0000-1111-2222-000000000001'
        await db_import_system_platform(asyncio_conn, system, ADVISOR_JSON)  # import new system
        await db_import_system_platform(asyncio_conn, system, ADVISOR_JSON)  # update recently imported system

    @pytest.mark.asyncio
    async def test_update_cves(self, pg_db_conn, asyncio_conn):  # pylint: disable=unused-argument
        """Test insertion of system data"""
        to_update = [
            (7, 0, None, None, None, True, 1),
            (8, 0, None, None, None, True, 1)
        ]
        await update_cves(asyncio_conn, to_update, 0)  # update cves

    @pytest.mark.asyncio
    async def test_simple_import(self, pg_db_conn, asyncio_conn, monkeypatch):  # pylint: disable=unused-argument
        """Test importing new system with one rule"""
        advisor_listener.DB_POOL = DbPoolMock()
        monkeypatch.setattr(advisor_listener, 'send_msg_to_payload_tracker', empty_fun)
        monkeypatch.setattr(advisor_listener.DB_POOL, "acquire", lambda: ConnContextMock(asyncio_conn))

        system = deepcopy(SYSTEM_DICT)
        system['input']['host']['id'] = 'b1f21450-0000-1111-2222-000000000002'
        rule_hits = {}
        rule_hits[CVES_CACHE['CVE-2014-1']] = {
            'id': RULES_CACHE['CVE_2018_3639_cpu_kernel|CVE_2018_3639_CPU_BAD_MICROCODE_2'],
            'details': '{"detail_key": "detail_value"}',
            'cve_name': 'CVE-2014-1'
        }
        async with asyncio_conn.transaction():
            await db_import_system(system, rule_hits, ADVISOR_JSON, asyncio_conn)
        # add a additional CVE to rule
        rule_hits[CVES_CACHE['CVE-2016-1']] = {
            'id': RULES_CACHE['CVE_2018_3639_cpu_kernel|CVE_2018_3639_CPU_BAD_MICROCODE_2'],
            'details': '{"detail_key": "detail_value"}',
            'cve_name': 'CVE-2016-1'
        }
        async with asyncio_conn.transaction():
            await db_import_system(system, rule_hits, ADVISOR_JSON, asyncio_conn)

    @pytest.mark.asyncio
    async def test_pass_import(self, pg_db_conn, asyncio_conn, monkeypatch):  # pylint: disable=unused-argument
        """Test importing pass info"""
        advisor_listener.DB_POOL = DbPoolMock()
        monkeypatch.setattr(advisor_listener, 'send_msg_to_payload_tracker', empty_fun)
        monkeypatch.setattr(advisor_listener.DB_POOL, "acquire", lambda: ConnContextMock(asyncio_conn))

        system = deepcopy(SYSTEM_DICT)
        system['input']['host']['id'] = '2a104733-c60d-4446-a9ea-bbf30851bc79'
        rule_hits = {}
        rule_hits[CVES_CACHE['CVE-2017-1']] = {
            'id': RULES_CACHE['CVE_2018_12207_cpu_kernel'],
            'mitigation_reason': 'Kernel is OK'
        }
        async with asyncio_conn.transaction():
            await db_import_system(system, rule_hits, ADVISOR_JSON, asyncio_conn)

    @staticmethod
    async def _import_rule_pass_mock(rule_name, *_, **__):
        """Mock for db_import_rule for pass parsing test"""
        assert rule_name in JSON_RULE_PASSES
        advisor_listener.RULES_CACHE[rule_name] = rule_name

    @staticmethod
    async def _import_cve_rule_pass_mock(cve, *_):
        """Mock for db_import_cve for pass parsing test"""
        assert cve in JSON_RULE_PASSES_CVES
        advisor_listener.CVES_CACHE[cve] = cve

    @staticmethod
    async def _import_rule_hit_mock(rule_name, *_, **__):
        """Mock for db_import_rule for hits parsing test"""
        assert rule_name in JSON_RULE_HITS
        advisor_listener.RULES_CACHE[rule_name] = rule_name

    @staticmethod
    async def _import_cve_rule_hit_mock(cve, *_):
        """Mock for db_import_cve for hits parsing test"""
        assert cve in JSON_RULE_HITS_CVES
        advisor_listener.CVES_CACHE[cve] = cve

    @pytest.mark.asyncio
    async def test_result_pass_parsing(self, asyncio_conn, monkeypatch):
        """Test parsing of input from advisor, passes"""
        # Ensure that import functions are called
        self._clear_caches()
        advisor_listener.DB_POOL = DbPoolMock()

        passes = ADVISOR_JSON_RULES["results"].get("pass", [])
        monkeypatch.setattr(advisor_listener.DB_POOL, "acquire", lambda: ConnMock(True))
        monkeypatch.setattr(advisor_listener, "db_import_rule", TestAdvisorListener._import_rule_pass_mock)
        monkeypatch.setattr(advisor_listener, "db_import_cve", TestAdvisorListener._import_cve_rule_pass_mock)

        rule_passes = {}
        passed = await _parse_passes(passes, rule_passes, asyncio_conn)
        for cve in JSON_RULE_PASSES_CVES:
            assert cve in rule_passes
        assert passed is True

    @pytest.mark.asyncio
    async def test_result_hit_parsing(self, asyncio_conn, monkeypatch):  # pylint: disable=unused-argument
        """Test parsing of input from advisor, hits"""
        # Ensure that import functions are called
        self._clear_caches()
        advisor_listener.DB_POOL = DbPoolMock()

        hits = ADVISOR_JSON_RULES["results"].get("reports", [])
        monkeypatch.setattr(advisor_listener.DB_POOL, "acquire", lambda: ConnMock(True))
        monkeypatch.setattr(advisor_listener, "db_import_rule", TestAdvisorListener._import_rule_hit_mock)
        monkeypatch.setattr(advisor_listener, "db_import_cve", TestAdvisorListener._import_cve_rule_hit_mock)

        rule_hits = {}
        reported = await _parse_reports(hits, rule_hits, asyncio_conn)
        for cve in JSON_RULE_HITS_CVES:
            assert cve in rule_hits
        assert reported is True

    @staticmethod
    async def _import_rule_mock(rule_name, *_, **__):
        """Mock for db_import_rule"""
        assert rule_name in JSON_RULE_HITS + JSON_RULE_PASSES
        advisor_listener.RULES_CACHE[rule_name] = rule_name

    @staticmethod
    async def _import_cve_rule_mock(cve, *_):
        """Mock for db_import_cve"""
        assert cve in JSON_RULE_HITS_CVES + JSON_RULE_PASSES_CVES
        advisor_listener.CVES_CACHE[cve] = cve

    @pytest.mark.asyncio
    async def test_whole_inv_parsing(self, asyncio_conn, monkeypatch):
        """Test parsing of whole inv result from advisor"""
        self._clear_caches()
        advisor_listener.DB_POOL = DbPoolMock()
        monkeypatch.setattr(advisor_listener.DB_POOL, "acquire", lambda: ConnMock(True))
        monkeypatch.setattr(advisor_listener, "db_import_rule", TestAdvisorListener._import_rule_mock)
        monkeypatch.setattr(advisor_listener, "db_import_cve", TestAdvisorListener._import_cve_rule_mock)

        advisor_json, rule_hits = await parse_inventory_data(ADVISOR_JSON_RULES, asyncio_conn)
        for cve in JSON_RULE_HITS_CVES + JSON_RULE_PASSES_CVES:
            assert cve in rule_hits
        assert advisor_json is not None

    @staticmethod
    async def _insert_new_cves_mock(_, rh_account_id, system_id, new_rule_hits, __):
        """Mock for insert new cves mock, checks if the CVEs are correct by the JSON"""
        assert rh_account_id == TESTED_RH_ACCOUNT_ID
        assert system_id == TESTED_SYSTEM_ID
        for cve in SYSTEM_NEW_CVES_HIT + SYSTEM_NEW_CVES_PASS:
            assert advisor_listener.CVES_CACHE[cve] in new_rule_hits

    @staticmethod
    async def _update_cves_mock(_, to_update, rh_account_id):
        """Mock for the update of the CVEs by test JSON"""
        inverse_rules_cache = {v: k for k, v in advisor_listener.RULES_CACHE.items()}
        assert rh_account_id == TESTED_RH_ACCOUNT_ID
        for row in to_update:
            assert row[1] == TESTED_RH_ACCOUNT_ID
            if row[2] is not None:
                assert inverse_rules_cache[row[2]] in SYSTEM_UPDATED_RULES

    @pytest.mark.asyncio
    async def test_cve_rule_import_and_update(self, pg_db_conn, asyncio_conn, monkeypatch):  # pylint: disable=unused-argument
        """Test rule import and update of the CVEs of particular system"""
        self._clear_caches()

        advisor_listener.DB_POOL = DbPoolMock()
        monkeypatch.setattr(advisor_listener, "send_remediations_update", lambda _, __, ___: None)
        monkeypatch.setattr(advisor_listener.DB_POOL, "acquire", lambda: ConnContextMock(asyncio_conn))

        await db_init_caches()
        _, rule_hits = await parse_inventory_data(ADVISOR_JSON_RULES, asyncio_conn)

        monkeypatch.setattr(advisor_listener, "update_cves", TestAdvisorListener._update_cves_mock)
        monkeypatch.setattr(advisor_listener, "insert_new_cves", TestAdvisorListener._insert_new_cves_mock)
        async with asyncio_conn.transaction():
            await db_import_rule_hits(asyncio_conn, TESTED_RH_ACCOUNT_ID, "", TESTED_SYSTEM_ID, rule_hits)

    def test_main(self, pg_db_conn, caplog, monkeypatch, event_loop):  # pylint: disable=unused-argument
        """Test main"""
        monkeypatch.setattr(advisor_listener, "run", empty_fun_async)
        monkeypatch.setattr(advisor_listener, "db_init_caches", empty_fun_async)
        monkeypatch.setattr(advisor_listener, "setup_db_pool", empty_fun_async)

        advisor_listener.MAIN_LOOP = event_loop
        advisor_listener.CFG.minimal_schema = 0

        with caplog.at_level(logging.INFO):
            advisor_listener.main()
        assert "Starting advisor listener" in caplog.messages[1]
