# -*- coding: utf-8 -*-
# pylint: disable=no-self-use
"""
Unit tests for advisor listener and rules evaluation
"""

from copy import deepcopy
import pytest

from common.database_handler import DatabasePool, DatabasePoolConnection
from advisor_listener.advisor_listener import db_import_rule, db_import_system

SYSTEM_DICT = {
    'rh_account': '0',
    'display_name': 'xxee',
    'inventory_id': None,
    'stale_timestamp': '2100-01-01',
    'stale_warning_timestamp': '2100-01-01',
    'culled_timestamp': '2100-01-01',
}


class TestRulesEvaluation:
    """Test rules evaluation"""

    @staticmethod
    def _account_caches(cur):
        caches = {}
        cur.execute('SELECT cve_id, systems_affected FROM cve_account_data where rh_account_id = 0')
        for cve_id, systems_affected in cur.fetchall():
            caches[cve_id] = systems_affected
        return caches

    @staticmethod
    def _cache_check(cur, account_id):
        """Checks cachedcounts for given account, copy of cache_check taskomatic job"""
        passed = True
        cur.execute("""SELECT count(*) as real, cad.systems_affected from system_vulnerabilities sv
                    INNER JOIN cve_metadata cm on sv.cve_id = cm.id
                    LEFT OUTER JOIN cve_account_data cad on sv.cve_id = cad.cve_id
                    LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                    WHERE sv.system_id IN
                    (SELECT id FROM system_platform WHERE rh_account_id = %(account_id)s AND when_deleted is NULL AND opt_out = 'F' and stale = 'F')
                    AND cad.rh_account_id = %(account_id)s
                    AND (sv.when_mitigated IS NULL OR ir.active = 'T')
                    GROUP by cm.cve, cad.systems_affected""",
                    {'account_id': account_id})
        cve_counts = cur.fetchall()

        for real_count, cached_count in cve_counts:
            if cached_count is None:
                cached_count = 0
            if real_count != cached_count:
                passed = False

        cur.execute("""SELECT id, cve_count_cache FROM system_platform WHERE rh_account_id = %(account_id)s AND when_deleted is NULL
                    AND opt_out = 'F' AND stale = 'F'""", {'account_id': account_id})
        systems = cur.fetchall()

        for system_id, cached_count in systems:
            cur.execute("""SELECT count(*) FROM system_vulnerabilities sv
                        LEFT OUTER JOIN insights_rule ir ON sv.rule_id = ir.id
                        WHERE sv.system_id = %(system_id)s AND (sv.when_mitigated IS NULL OR ir.active = 'T')""", {'system_id': system_id})
            real_count = cur.fetchone()[0]
            if cached_count != real_count:
                passed = False

        return passed

    @staticmethod
    def _system_cache(cur, inventory_id):
        cur.execute('SELECT cve_count_cache FROM system_platform WHERE inventory_id = %(inv_id)s', {'inv_id': inventory_id})
        return cur.fetchone()[0]

    @staticmethod
    def _test_counts(orig_cve_count_cache, new_cve_count_cache, orig_caches, new_caches, difference, cve_id):
        assert orig_cve_count_cache + difference == new_cve_count_cache
        assert orig_caches[cve_id] + difference == new_caches[cve_id]
        del orig_caches[cve_id]
        del new_caches[cve_id]
        assert orig_caches == new_caches

    @pytest.mark.parametrize('inv_id,cve_id,rule_id,cve_name', [('INV-6', 8, 3, 'CVE-2017-6'), ('INV-15', 8, 3, 'CVE-2017-6')],
                             ids=['adding_inactive_rule', 'rule_deactivation'])
    def test_rule_not_changing_cves(self, pg_db_conn, cleanup, inv_id, cve_id, rule_id, cve_name):  # pylint: disable=unused-argument
        """Inserts CVE which is tied to inactive rule, nothing shall happen"""
        with DatabasePool(2):
            with DatabasePoolConnection() as conn:
                with conn.cursor() as cur:
                    system = deepcopy(SYSTEM_DICT)
                    system['inventory_id'] = inv_id
                    rule_hits = {
                        cve_id: {
                            'id': rule_id,
                            'details': '{"detail_key": "detail_value"}',
                            'cve_name': cve_name
                        }
                    }

                    orig_cve_count_cache = self._system_cache(cur, inv_id)
                    orig_caches = self._account_caches(cur)

                    db_import_system(system, rule_hits)

                    new_cve_count_cache = self._system_cache(cur, inv_id)
                    new_caches = self._account_caches(cur)

                    assert orig_cve_count_cache == new_cve_count_cache
                    assert orig_caches == new_caches
                    assert all([self._cache_check(cur, account_id) for account_id in ('0', '1', '2')])

    @pytest.mark.parametrize('cve_id,rule_id,cve_name', [(11, 6, 'CVE-2018-1'), (2, 1, 'CVE-2016-1'), (9, 4, 'CVE-2017-7')],
                             ids=['new_cve', 'vmaas_mitigated_cve', 'inactive_to_active_rule'])
    def test_rule_adding_cve(self, pg_db_conn, cleanup, cve_id, rule_id, cve_name):  # pylint: disable=unused-argument
        """
        Tests adding a rule which adds one CVE to a system
        In some we are removing other rules from a system, but the rules in this tests were chosen so they're either not active or not VMaaS mitigated
        """
        with DatabasePool(2):
            with DatabasePoolConnection() as conn:
                with conn.cursor() as cur:
                    system = deepcopy(SYSTEM_DICT)
                    system['inventory_id'] = 'INV-4'
                    rule_hits = {
                        cve_id: {
                            'id': rule_id,
                            'details': '{"detail_key": "detail_value"}',
                            'cve_name': cve_name
                        }
                    }

                    orig_cve_count_cache = self._system_cache(cur, 'INV-4')
                    orig_caches = self._account_caches(cur)

                    db_import_system(system, rule_hits)

                    new_cve_count_cache = self._system_cache(cur, 'INV-4')
                    new_caches = self._account_caches(cur)

                    self._test_counts(orig_cve_count_cache, new_cve_count_cache, orig_caches, new_caches, 1, cve_id)
                    assert all([self._cache_check(cur, account_id) for account_id in ('0', '1', '2')])

    @pytest.mark.parametrize('inv_id,cve_id,rule_hits',
                             [('INV-7', 11, {10: {'id': 6, 'details': '{"detail_key": "detail_value"}', 'cve_name': 'CVE-2018-1'}}),
                              ('INV-5', 8, {
                                  8: {'id': 3, 'details': '{"detail_key": "detail_value"}', 'cve_name': 'CVE-2017-6'},
                                  10: {'id': 5, 'details': '{"detail_key": "detail_value"}', 'cve_name': 'CVE-2017-8'},
                                  11: {'id': 5, 'details': '{"detail_key": "detail_value"}', 'cve_name': 'CVE-2018-1'}
                              })],
                             ids=['removing_cve', 'rule_deactivation'])
    def test_rule_removing_cve(self, pg_db_conn, cleanup, inv_id, cve_id, rule_hits):  # pylint: disable=unused-argument
        """Tests removing rule from system where the CVE is not reported by VMaaS"""
        with DatabasePool(2):
            with DatabasePoolConnection() as conn:
                with conn.cursor() as cur:
                    system = deepcopy(SYSTEM_DICT)
                    system['inventory_id'] = inv_id

                    orig_cve_count_cache = self._system_cache(cur, inv_id)
                    orig_caches = self._account_caches(cur)

                    db_import_system(system, rule_hits)

                    new_cve_count_cache = self._system_cache(cur, inv_id)
                    new_caches = self._account_caches(cur)

                    self._test_counts(orig_cve_count_cache, new_cve_count_cache, orig_caches, new_caches, -1, cve_id)
                    assert all([self._cache_check(cur, account_id) for account_id in ('0', '1', '2')])

    def test_new_rule_unknown_cve(self, pg_db_conn, cleanup):  # pylint: disable=unused-argument
        """Tests adding completely new rule with completely new CVE"""
        with DatabasePool(3):
            with DatabasePoolConnection() as conn:
                with conn.cursor() as cur:
                    db_import_rule('new_rule|ERROR_KEY', ['CVE-2068-124'])

                    cur.execute("SELECT id FROM insights_rule WHERE name = 'new_rule|ERROR_KEY'")
                    rule_id = cur.fetchone()[0]
                    cur.execute("UPDATE insights_rule SET active = 'T' WHERE name = 'new_rule|ERROR_KEY'")

                    cur.execute("SELECT id FROM cve_metadata WHERE cve = 'CVE-2068-124'")
                    cve_id = cur.fetchone()[0]
                    conn.commit()

                    inv_id = 'INV-6'
                    system = deepcopy(SYSTEM_DICT)
                    system['inventory_id'] = inv_id
                    rule_hits = {cve_id: {'id': rule_id, 'details': '{"detail_key": "detail_value"}', 'cve_name': 'CVE-2068-124'}}

                    orig_cve_count_cache = self._system_cache(cur, inv_id)
                    orig_caches = self._account_caches(cur)

                    db_import_system(system, rule_hits)

                    new_cve_count_cache = self._system_cache(cur, inv_id)
                    new_caches = self._account_caches(cur)

                    assert orig_cve_count_cache + 1 == new_cve_count_cache
                    assert new_caches[cve_id] == 1
                    del new_caches[cve_id]
                    assert orig_caches == new_caches
                    assert all([self._cache_check(cur, account_id) for account_id in ('0', '1', '2')])

    def test_removing_all_rules(self, pg_db_conn, cleanup):  # pylint: disable=unused-argument
        """Tests removing all rules from system"""
        with DatabasePool(2):
            with DatabasePoolConnection() as conn:
                with conn.cursor() as cur:
                    inv_id = 'INV-5'
                    system = deepcopy(SYSTEM_DICT)
                    system['inventory_id'] = inv_id

                    orig_cve_count_cache = self._system_cache(cur, inv_id)
                    orig_caches = self._account_caches(cur)

                    db_import_system(system, {})

                    new_cve_count_cache = self._system_cache(cur, inv_id)
                    new_caches = self._account_caches(cur)

                    self._test_counts(orig_cve_count_cache, new_cve_count_cache, orig_caches, new_caches, -1, 8)
                    assert all([self._cache_check(cur, account_id) for account_id in ('0', '1', '2')])
