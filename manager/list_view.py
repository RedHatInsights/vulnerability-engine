"""
Module for sorting/pagination/filering in API
"""

import math
from urllib.parse import urlencode
from .base import InvalidArgumentException


class ListView:
    """Base class implementing sorting/pagination/filering"""

    # pylint: disable=R0902
    # handling both pagination and limit/offset drove us over the limit

    def __init__(self, query, sortable_columns, default_sort_columns, filterable_columns, list_args, query_args, uri):
        self.uri = uri.split('?')[0]
        self.query = query
        self.query_args = query_args
        self.sortable_columns = sortable_columns
        self.default_sort_columns = default_sort_columns
        self.filterable_columns = filterable_columns
        # Save list-args so we can rebuild appropriate pagination links later
        self.list_args = list_args
        self._apply_args(list_args)

    @staticmethod
    def _parse_column_name(column_name):
        desc = False
        if column_name.startswith("-"):
            desc = True
            column_name = column_name[1:]
        elif column_name.startswith("+"):
            column_name = column_name[1:]
        return column_name, desc

    def _apply_args(self, args):  # pylint: disable=R0912, R0915
        if args["filter"]:
            if not self.filterable_columns:
                raise InvalidArgumentException("No available columns for filtering")
            expressions = None
            for column in self.filterable_columns.values():
                if expressions is None:
                    expressions = column.contains(args["filter"])
                else:
                    expressions |= column.contains(args["filter"])
            self.query = self.query.where(expressions)
        self.active_filter = args["filter"]

        input_sort_columns = []
        if args["sort"]:
            input_sort_columns.extend(args["sort"].split(","))
        if self.default_sort_columns:
            input_sort_columns.extend(self.default_sort_columns)

        if input_sort_columns and not self.sortable_columns:
            raise InvalidArgumentException("No available columns for sorting")

        sort_columns = []
        for column_name in input_sort_columns:
            column_name, desc = self._parse_column_name(column_name)
            column = self.sortable_columns.get(column_name, None)
            if column:
                if desc:
                    sort_columns.append(column.desc(nulls='LAST'))
                else:
                    sort_columns.append(column.asc())
            else:
                raise InvalidArgumentException("Invalid sort column: %s" % column_name)
        if sort_columns:
            self.query = self.query.order_by(*sort_columns)

        self.active_sort = args["sort"] if args["sort"] else None
        self.total_items = self.query.count()

        self.page_size = args["page_size"]
        self.limit = args["limit"]
        self.page = args["page"]
        self.offset = args["offset"]
        self.data_format = args["data_format"]

        pages = math.ceil(self.total_items / self.page_size)
        self.pages = pages if pages > 0 else 1

        # Check for out-of-range for whichever was received
        if (args["offset"] and self.offset > self.total_items) or (args["page"] and self.page > self.pages):
            raise InvalidArgumentException("Requested start-point out of range: page %s/offset %s" %
                                           (args["page"], args["offset"]))

    def _build_list_attrs(self, new_offset):
        """
        To build pagination-links, we need the offset-info for the appropriate link (passed in) plus whatever the
        initiating request gave us in the first place (get_metadata)
        """
        link_args = {'offset': new_offset}
        # Skip meta-key when it's offset or page-related meta, skip val when in ('', None):
        # (val might be a string, or an int, or None. We want to skip empty-str or None, but NOT key=0.)
        for (key, val) in [
                (k, v) for (k, v) in self.get_metadata().items()
                if k not in ('offset', 'total_items', 'page', 'page_size', 'pages') and v not in ('', None)
        ]:
            link_args[key] = val
        return urlencode(link_args)

    @classmethod
    def _get_first(cls, curr_offset, curr_limit, curr_total):  # pylint: disable=W0613
        # 'first' offset is just '0'
        return 0

    def _get_first_link(self):
        # First offset is 0
        new_offset = self._get_first(self.offset, self.limit, self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))

    @classmethod
    def _get_next(cls, curr_offset, curr_limit, curr_total):  # pylint: disable=W0613
        # If 'here + limit' <= total', next is 'here + limit' - else we stay where we are
        return math.floor(min((curr_offset + curr_limit), curr_total - 1) / curr_limit) * curr_limit

    def _get_next_link(self):
        new_offset = self._get_next(self.offset, self.limit, self.total_items)
        if new_offset > self.offset:
            return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))
        return None

    @classmethod
    def _get_previous(cls, curr_offset, curr_limit, curr_total):  # pylint: disable=W0613
        # prev is (here - limit), or 0 if here < limit
        return math.ceil(max((curr_offset - curr_limit), 0) / curr_limit) * curr_limit

    def _get_previous_link(self):
        new_offset = self._get_previous(self.offset, self.limit, self.total_items)
        if new_offset < self.offset:
            return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))
        return None

    @classmethod
    def _get_last(cls, curr_offset, curr_limit, curr_total):  # pylint: disable=W0613
        # Last offset is (total - limit), or 0 if limit > total
        return math.ceil(max((curr_total - curr_limit), 0) / curr_limit) * curr_limit

    def _get_last_link(self):
        # Last offset is (total - limit), or 0 if limit > total
        new_offset = self._get_last(self.offset, self.limit, self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))

    def get_pagination_links(self):
        """Returns content of 'links' stanza for pagination"""
        return {
            "first": self._get_first_link(),
            "next": self._get_next_link(),
            "previous": self._get_previous_link(),
            "last": self._get_last_link()
        }

    def get_metadata(self):
        """Returns pagination/filtering/sorting related metadata"""
        meta = {
            "sort": self.active_sort,
            "filter": self.active_filter,
            "page": self.page,
            "page_size": self.page_size,
            "pages": self.pages,
            "total_items": self.total_items,
            "limit": self.limit,
            "offset": self.offset,
            "data_format": self.data_format
        }
        processed = {key: ",".join([str(x) for x in self.query_args[key]]) if isinstance(
            self.query_args[key], list) else self.query_args[key] for key in self.query_args}
        meta.update(processed)
        return meta

    def __iter__(self):
        return self.query.limit(self.limit).offset(self.offset).__iter__()
