"""
Module for sorting/pagination/filering in API
"""

import math

from .base import InvalidArgumentException


class ListView:
    """Base class implementing sorting/pagination/filering"""

    # pylint: disable=R0902
    # handling both pagination and limit/offset drove us over the limit

    def __init__(self, query, sortable_columns, filterable_columns, list_args, query_args, uri):
        self.uri = uri.split('?')[0]
        self.query = query
        self.query_args = query_args
        self.sortable_columns = sortable_columns
        self.filterable_columns = filterable_columns
        # Save list-args so we can rebuild appropriate pagination links later
        self.list_args = list_args
        self._apply_args(list_args)

    def _apply_args(self, args): # pylint: disable=R0912, R0915
        if args["filter"]:
            if not self.filterable_columns:
                raise InvalidArgumentException("No available columns for filtering")
            expressions = None
            for column in self.filterable_columns.values():
                if expressions is None:
                    expressions = column.contains(args["filter"])
                else:
                    expressions |= column.contains(args["filter"])
            self.query = self.query.where(expressions)
        self.active_filter = args["filter"]

        self.active_sort = None
        sort_column_names = []
        if args["sort"]:
            if not self.sortable_columns:
                raise InvalidArgumentException("No available columns for sorting")
            input_sort_columns = args["sort"].split(",")
            sort_columns = []
            for column_name in input_sort_columns:
                desc = False
                if column_name.startswith("-"):
                    desc = True
                    column_name = column_name[1:]
                elif column_name.startswith("+"):
                    column_name = column_name[1:]
                column = self.sortable_columns.get(column_name, None)
                if column:
                    if desc:
                        sort_column_names.append("-%s" % column_name)
                        sort_columns.append(column.desc(nulls='LAST'))
                    else:
                        sort_column_names.append("+%s" % column_name)
                        sort_columns.append(column.asc())
                else:
                    raise InvalidArgumentException("Invalid sort column: %s" % column_name)
            if sort_columns:
                self.query = self.query.order_by(*sort_columns)
            self.active_sort = ",".join(sort_column_names)

        self.total_items = self.query.count()

        self.page_size = args["page_size"]
        self.limit = args["limit"]
        self.page = args["page"]
        self.offset = args["offset"]

        pages = math.ceil(self.total_items / self.page_size)
        self.pages = pages if pages > 0 else 1

        # Check for out-of-range for whichever was received
        if args["offset"] and self.offset > self.total_items:
            raise InvalidArgumentException("Requested starting offset out of range: %s" % args["offset"])

        if args["page"] and self.page > self.pages:
            raise InvalidArgumentException("Requested page out of range: %s" % args["page"])

    def _get_list_args(self):
        return {
            'offset': self.offset,
            'limit': self.limit,
            }

    def _build_list_attrs(self, args):
        """
        To build pagination-links, we need the correct pagination-info (passed in) plus whatever the initiating
        request gave us in the first place (self.filterable_args)
        """
        hasvals = []
        # Return dict of non-empty args
        # val might be a string, or an int, or None. We want to skip empty-str or None, but NOT key=0.
        for (key, val) in args.items():
            if val not in ('', None):
                hasvals.append('%s=%s' % (key, str(val)))
        for (key, val) in self.query_args.items():
            if val not in ('', None):
                hasvals.append('%s=%s' % (key, ",".join([str(x) for x in val]) if isinstance(val, list) else str(val)))
        return '&'.join(hasvals) if hasvals else ''

    @classmethod
    def _get_first(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # 'first' offset is just '0'
        return 0

    def _get_first_link(self):
        # First offset is 0
        args = self._get_list_args()
        args['offset'] = self._get_first(args['offset'], args['limit'], self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(args))

    @classmethod
    def _get_next(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # If 'here + limit' <= total', next is 'here + limit' - else we stay where we are
        return math.floor(min((curr_offset + curr_limit), curr_total) / curr_limit) * curr_limit

    def _get_next_link(self):
        args = self._get_list_args()
        args['offset'] = self._get_next(args['offset'], args['limit'], self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(args))

    @classmethod
    def _get_previous(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # prev is (here - limit), or 0 if here < limit
        return math.ceil(max((curr_offset - curr_limit), 0) / curr_limit) * curr_limit

    def _get_previous_link(self):
        args = self._get_list_args()
        args['offset'] = self._get_previous(args['offset'], args['limit'], self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(args))

    @classmethod
    def _get_last(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # Last offset is (total - limit), or 0 if limit > total
        return math.ceil(max((curr_total - curr_limit), 0) / curr_limit) * curr_limit

    def _get_last_link(self):
        args = self._get_list_args()
        # Last offset is (total - limit), or 0 if limit > total
        args['offset'] = self._get_last(args['offset'], args['limit'], self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(args))

    def get_pagination_links(self):
        """Returns content of 'links' stanza for pagination"""
        return {
            "first": self._get_first_link(),
            "next": self._get_next_link(),
            "previous": self._get_previous_link(),
            "last": self._get_last_link()
        }

    def get_metadata(self):
        """Returns pagination/filtering/sorting related metadata"""
        meta = {
            "sort": self.active_sort,
            "filter": self.active_filter,
            "page": self.page,
            "page_size": self.page_size,
            "pages": self.pages,
            "total_items": self.total_items,
            "limit": self.limit,
            "offset": self.offset
        }
        processed = {key: ",".join([str(x) for x in self.query_args[key]]) if isinstance(
            self.query_args[key], list) else self.query_args[key] for key in self.query_args}
        meta.update(processed)
        return meta

    def __iter__(self):
        return self.query.limit(self.limit).offset(self.offset).__iter__()
