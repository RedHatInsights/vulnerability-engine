"""
Module for sorting/pagination/filering in API
"""

import math
from urllib.parse import urlencode
from .base import InvalidArgumentException


class ListView:
    """Base class implementing sorting/pagination/filering"""

    # handling both pagination and limit/offset drove us over the limit

    def __init__(self, query, sortable_columns, default_sort_columns, filterable_columns, list_args, query_args, uri):
        self.uri = uri.split('?')[0]
        self.query = query
        self.sortable_columns = sortable_columns
        self.default_sort_columns = default_sort_columns
        self.filterable_columns = filterable_columns
        self.list_args = list_args
        self.query_args = query_args

        self._apply_filter()
        self._apply_sort()
        self._get_total_items()

    @staticmethod
    def _parse_column_name(column_name):
        desc = False
        if column_name.startswith("-"):
            desc = True
            column_name = column_name[1:]
        elif column_name.startswith("+"):
            column_name = column_name[1:]
        return column_name, desc

    def _apply_filter(self):
        if self.list_args["filter"]:
            if not self.filterable_columns:
                raise InvalidArgumentException("No available columns for filtering")
            expressions = None
            for column in self.filterable_columns.values():
                if expressions is None:
                    expressions = column.contains(self.list_args["filter"])
                else:
                    expressions |= column.contains(self.list_args["filter"])
            self.query = self.query.where(expressions)

    def _apply_sort(self):
        input_sort_columns = []
        if self.list_args["sort"]:
            input_sort_columns.extend(self.list_args["sort"].split(","))
        if self.default_sort_columns:
            input_sort_columns.extend(self.default_sort_columns)

        if input_sort_columns and not self.sortable_columns:
            raise InvalidArgumentException("No available columns for sorting")

        sort_columns = []
        for column_name in input_sort_columns:
            column_name, desc = self._parse_column_name(column_name)
            column = self.sortable_columns.get(column_name, None)
            if column:
                if desc:
                    sort_columns.append(column.desc(nulls='LAST'))
                else:
                    sort_columns.append(column.asc())
            else:
                raise InvalidArgumentException("Invalid sort column: %s" % column_name)
        if sort_columns:
            self.query = self.query.order_by(*sort_columns)

    def _get_total_items(self):
        self.total_items = self.query.count()

        pages = math.ceil(self.total_items / self.list_args["page_size"])
        self.pages = pages if pages > 0 else 1

        # Check for out-of-range for whichever was received
        if (self.list_args["offset"] and self.list_args["offset"] > self.total_items) or \
                (self.list_args["page"] and self.list_args["page"] > self.pages):
            raise InvalidArgumentException("Requested start-point out of range: page %s/offset %s" %
                                           (self.list_args["page"], self.list_args["offset"]))

    def _build_list_attrs(self, new_offset):
        """
        To build pagination-links, we need the offset-info for the appropriate link (passed in) plus whatever the
        initiating request gave us in the first place (get_metadata)
        """
        link_args = {'offset': new_offset}
        # Skip meta-key when it's offset or page-related meta, skip val when in ('', None):
        # (val might be a string, or an int, or None. We want to skip empty-str or None, but NOT key=0.)
        for (key, val) in [
                (k, v) for (k, v) in self.get_metadata().items()
                if k not in ('offset', 'total_items', 'page', 'page_size', 'pages') and v not in ('', None)
        ]:
            link_args[key] = val
        return urlencode(link_args)

    def _get_first_link(self):
        # First offset is 0
        return "%s?%s" % (self.uri, self._build_list_attrs(0))

    @staticmethod
    def _get_next(curr_offset, curr_limit, curr_total):
        # If 'here + limit' <= total', next is 'here + limit' - else we stay where we are
        return math.floor(min((curr_offset + curr_limit), curr_total - 1) / curr_limit) * curr_limit

    def _get_next_link(self):
        new_offset = self._get_next(self.list_args["offset"], self.list_args["limit"], self.total_items)
        if new_offset > self.list_args["offset"]:
            return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))
        return None

    @staticmethod
    def _get_previous(curr_offset, curr_limit):
        # prev is (here - limit), or 0 if here < limit
        return math.ceil(max((curr_offset - curr_limit), 0) / curr_limit) * curr_limit

    def _get_previous_link(self):
        new_offset = self._get_previous(self.list_args["offset"], self.list_args["limit"])
        if new_offset < self.list_args["offset"]:
            return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))
        return None

    @staticmethod
    def _get_last(curr_limit, curr_total):
        # Last offset is (total - limit), or 0 if limit > total
        return math.ceil(max((curr_total - curr_limit), 0) / curr_limit) * curr_limit

    def _get_last_link(self):
        # Last offset is (total - limit), or 0 if limit > total
        new_offset = self._get_last(self.list_args["limit"], self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))

    def get_pagination_links(self):
        """Returns content of 'links' stanza for pagination"""
        return {
            "first": self._get_first_link(),
            "next": self._get_next_link(),
            "previous": self._get_previous_link(),
            "last": self._get_last_link()
        }

    def get_metadata(self):
        """Returns pagination/filtering/sorting related metadata"""
        meta = {
            "sort": self.list_args["sort"],
            "filter": self.list_args["filter"],
            "page": self.list_args["page"],
            "page_size": self.list_args["page_size"],
            "pages": self.pages,
            "total_items": self.total_items,
            "limit": self.list_args["limit"],
            "offset": self.list_args["offset"],
            "data_format": self.list_args["data_format"]
        }
        processed = {key: ",".join([str(x) for x in self.query_args[key]]) if isinstance(
            self.query_args[key], list) else self.query_args[key] for key in self.query_args}
        meta.update(processed)
        return meta

    def __iter__(self):
        return self.query.limit(self.list_args["limit"]).offset(self.list_args["offset"]).__iter__()
