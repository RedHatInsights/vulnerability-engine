"""
Module for sorting/pagination/filering in API
"""

import math

from .base import InvalidArgumentException


class ListView:
    """Base class implementing sorting/pagination/filering"""

    # pylint: disable=R0902
    # handling both pagination and limit/offset drove us over the limit

    def __init__(self, query, sortable_columns, filterable_columns, list_args, uri):
        self.uri = uri
        self.query = query
        self.sortable_columns = sortable_columns
        self.filterable_columns = filterable_columns
        # Save list-args so we can rebuild appropriate links later
        self.list_args = list_args
        self._apply_args(list_args)

    def _apply_args(self, args): # pylint: disable=R0912, R0915
        if args["filter"]:
            if not self.filterable_columns:
                raise InvalidArgumentException("No available columns for filtering")
            expressions = None
            for column in self.filterable_columns.values():
                if expressions is None:
                    expressions = column.contains(args["filter"])
                else:
                    expressions |= column.contains(args["filter"])
            self.query = self.query.where(expressions)
        self.active_filter = args["filter"]

        sort_column_names = []
        if args["sort"]:
            if not  self.sortable_columns:
                raise InvalidArgumentException("No available columns for sorting")
            input_sort_columns = args["sort"].split(",")
            sort_columns = []
            for column_name in input_sort_columns:
                desc = False
                if column_name.startswith("-"):
                    desc = True
                    column_name = column_name[1:]
                elif column_name.startswith("+"):
                    column_name = column_name[1:]
                column = self.sortable_columns.get(column_name, None)
                if column:
                    if desc:
                        sort_column_names.append("-%s" % column_name)
                        sort_columns.append(column.desc(nulls='LAST'))
                    else:
                        sort_column_names.append("+%s" % column_name)
                        sort_columns.append(column.asc())
                else:
                    raise InvalidArgumentException("Invalid sort column: %s" % column_name)
            if sort_columns:
                self.query = self.query.order_by(*sort_columns)
        self.active_sort = ",".join(sort_column_names)

        self.total_items = self.query.count()

        self.page_size = args["page_size"]
        self.limit = args["limit"] if "limit" in args else args["page_size"]

        self.page = args["page"]
        self.offset = args["offset"] if args["offset"] else ((args["page"] - 1) * args["page_size"])

        pages = math.ceil(self.total_items / self.page_size)
        self.pages = pages if pages > 0 else 1
        if self.page > self.pages:
            raise InvalidArgumentException("Requested page out of range: %s" % self.page)

        if self.limit <= 0:
            raise InvalidArgumentException("Limit must be greater than zero: %s" % self.limit)

        if self.offset > self.total_items:
            raise InvalidArgumentException("Requested starting offset out of range: %s" % self.offset)

        # Replace incoming list-arg-values with sanitized ones
        args["offset"] = self.offset
        args["limit"] = self.limit
        args["pages"] = self.pages


    @staticmethod
    def _build_list_args(args):
        return '&'.join(("%s=%s" % (x, args[x])) for x in args.keys())

    @classmethod
    def _get_first(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # 'first' offset is just '0'
        return 0

    def _get_first_link(self):
        args = self.list_args.copy()
        # First offset is 0
        args['offset'] = self._get_first(self.list_args['offset'], self.list_args['limit'], self.total_items)
        return "%s?%s" % (self.uri, ListView._build_list_args(args))

    @classmethod
    def _get_next(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # If 'here + limit' <= total', next is 'here + limit' - else we stay where we are
        return math.floor(min((curr_offset + curr_limit), curr_total) / curr_limit) * curr_limit

    def _get_next_link(self):
        args = self.list_args.copy()
        args['offset'] = self._get_next(self.list_args['offset'], self.list_args['limit'], self.total_items)
        return "%s?%s" % (self.uri, ListView._build_list_args(args))

    @classmethod
    def _get_previous(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # prev is (here - limit), or 0 if here < limit
        return math.ceil(max((curr_offset - curr_limit), 0) / curr_limit) * curr_limit

    def _get_previous_link(self):
        args = self.list_args.copy()
        args['offset'] = self._get_previous(self.list_args['offset'], self.list_args['limit'], self.total_items)
        return "%s?%s" % (self.uri, ListView._build_list_args(args))

    @classmethod
    def _get_last(cls, curr_offset, curr_limit, curr_total): # pylint: disable=W0613
        # Last offset is (total - limit), or 0 if limit > total
        return math.ceil(max((curr_total - curr_limit), 0) / curr_limit) * curr_limit

    def _get_last_link(self):
        args = self.list_args.copy()
        # Last offset is (total - limit), or 0 if limit > total
        args['offset'] = self._get_last(self.list_args['offset'], self.list_args['limit'], self.total_items)
        return "%s?%s" % (self.uri, ListView._build_list_args(args))

    def get_pagination_links(self):
        """Returns content of 'links' stanza for pagination"""
        return {
            "first": self._get_first_link(),
            "next": self._get_next_link(),
            "previous": self._get_previous_link(),
            "last": self._get_last_link()
        }

    def get_metadata(self):
        """Returns pagination/filtering/sorting related metadata"""
        return {
            "sort": self.active_sort,
            "filter": self.active_filter,
            "page": self.page,
            "page_size": self.page_size,
            "pages": self.pages,
            "total_items": self.total_items,
            "limit": self.limit,
            "offset": self.offset
        }

    def __iter__(self):
        return self.query.limit(self.limit).offset(self.offset).__iter__()
