"""
Module for sorting/pagination/filering in API
"""

import math
from urllib.parse import urlencode
from .base import InvalidArgumentException


class ListView:
    """Base class implementing sorting/pagination/filering"""

    # handling both pagination and limit/offset drove us over the limit

    def __init__(self, query, sortable_columns, default_sort_columns, filterable_columns, filter_expressions, list_args, query_args, uri):
        self.uri = uri.split("?")[0]
        self.query = query
        self.sortable_columns = sortable_columns
        self.default_sort_columns = default_sort_columns
        self.filterable_columns = filterable_columns
        self.filter_expressions = filter_expressions
        self.list_args = list_args
        self.query_args = query_args

        self._apply_filter()
        self._apply_sort()
        self._get_total_items()

    @staticmethod
    def _parse_column_name(column_name):
        desc = False
        if column_name.startswith("-"):
            desc = True
            column_name = column_name[1:]
        elif column_name.startswith("+"):
            column_name = column_name[1:]
        return column_name, desc

    def _apply_filter(self):
        if self.list_args["filter"]:
            if not self.filterable_columns and not self.filter_expressions:
                raise InvalidArgumentException("No available columns or expressions for filtering")
            expressions = None
            for column in self.filterable_columns.values():
                if expressions is None:
                    expressions = column.contains(self.list_args["filter"])
                else:
                    expressions |= column.contains(self.list_args["filter"])
            for filter_expression in self.filter_expressions.values():
                if expressions is None:
                    expressions = filter_expression
                else:
                    expressions |= filter_expression
            self.query = self.query.where(expressions)

    def _apply_sort(self):  # pylint: disable=too-many-branches
        input_sort_columns = []
        sort_list = []
        if self.list_args["sort"]:
            sort_list = self.list_args["sort"].split(",")
            input_sort_columns.extend(sort_list)
        if self.default_sort_columns:
            for sort in sort_list:
                sort, _ = self._parse_column_name(sort)
                columns = self.default_sort_columns.get(sort, [])
                if not isinstance(columns, list):
                    columns = [columns]
                input_sort_columns.extend(columns)

            default_col = self.default_sort_columns.get("default", [])
            if not isinstance(default_col, list):
                default_col = [default_col]
            input_sort_columns.extend(default_col)

        if input_sort_columns and not self.sortable_columns:
            raise InvalidArgumentException("No available columns for sorting")

        sort_columns = []
        for column_name in input_sort_columns:
            column_name, desc = self._parse_column_name(column_name)
            db_column_list = self.sortable_columns.get(column_name, None)
            if not db_column_list:
                raise InvalidArgumentException("Invalid sort column: %s" % column_name)
            if not isinstance(db_column_list, list):
                db_column_list = [db_column_list]
            for db_column in db_column_list:
                if desc:
                    sort_columns.append(db_column.desc(nulls="LAST"))
                else:
                    sort_columns.append(db_column.asc())
        if sort_columns:
            self.query = self.query.order_by(*sort_columns)

    def _get_total_items(self):
        self.total_items = self.query.count()

        pages = math.ceil(self.total_items / self.list_args["page_size"])
        self.pages = pages if pages > 0 else 1

        # Check for out-of-range for whichever was received
        if (self.list_args["offset"] and self.list_args["offset"] > self.total_items) or (self.list_args["page"] and self.list_args["page"] > self.pages):
            raise InvalidArgumentException("Requested start-point out of range: page %s/offset %s" % (self.list_args["page"], self.list_args["offset"]))

    def _build_list_attrs(self, new_offset):
        """
        To build pagination-links, we need the offset-info for the appropriate link (passed in) plus whatever the
        initiating request gave us in the first place (get_metadata)
        """
        link_args = {"offset": new_offset}
        # Skip meta-key when it"s offset or page-related meta, skip val when in ("", None):
        # (val might be a string, or an int, or None. We want to skip empty-str or None, but NOT key=0.)
        for (key, val) in [
            (k, v) for (k, v) in self.get_metadata().items() if k not in ("offset", "total_items", "page", "page_size", "pages") and v not in ("", None)
        ]:
            link_args[key] = val
        return urlencode(link_args)

    def _get_first_link(self):
        # First offset is 0
        return "%s?%s" % (self.uri, self._build_list_attrs(0))

    @staticmethod
    def _get_next(curr_offset, curr_limit, curr_total):
        # If "here + limit" <= total", next is "here + limit" - else we stay where we are
        return math.floor(min((curr_offset + curr_limit), curr_total - 1) / curr_limit) * curr_limit

    def _get_next_link(self):
        new_offset = self._get_next(self.list_args["offset"], self.list_args["limit"], self.total_items)
        if new_offset > self.list_args["offset"]:
            return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))
        return None

    @staticmethod
    def _get_previous(curr_offset, curr_limit):
        # prev is (here - limit), or 0 if here < limit
        return math.ceil(max((curr_offset - curr_limit), 0) / curr_limit) * curr_limit

    def _get_previous_link(self):
        new_offset = self._get_previous(self.list_args["offset"], self.list_args["limit"])
        if new_offset < self.list_args["offset"]:
            return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))
        return None

    @staticmethod
    def _get_last(curr_limit, curr_total):
        # Last offset is (total - limit), or 0 if limit > total
        return math.ceil(max((curr_total - curr_limit), 0) / curr_limit) * curr_limit

    def _get_last_link(self):
        # Last offset is (total - limit), or 0 if limit > total
        new_offset = self._get_last(self.list_args["limit"], self.total_items)
        return "%s?%s" % (self.uri, self._build_list_attrs(new_offset))

    def get_pagination_links(self):
        """Returns content of "links" stanza for pagination"""
        return {"first": self._get_first_link(), "next": self._get_next_link(), "previous": self._get_previous_link(), "last": self._get_last_link()}

    def get_metadata(self):
        """Returns pagination/filtering/sorting related metadata"""

        meta = {
            "sort": self.list_args["sort"],
            "filter": self.list_args["filter"],
            "page": self.list_args["page"],
            "page_size": self.list_args["page_size"],
            "pages": self.pages,
            "total_items": self.total_items,
            "limit": self.list_args["limit"],
            "offset": self.list_args["offset"],
            "data_format": self.list_args["data_format"],
        }
        processed = {
            key: ",".join([str(x) for x in self.query_args[key]]) if isinstance(self.query_args[key], list) else self.query_args[key] for key in self.query_args
        }
        meta.update(processed)
        return meta

    def __iter__(self):
        return self.query.limit(self.list_args["limit"]).offset(self.list_args["offset"]).__iter__()
