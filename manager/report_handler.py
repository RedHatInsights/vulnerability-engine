"""
Module for /report APIs
"""
from datetime import datetime
from datetime import timedelta
from datetime import timezone

import connexion
from flask import g
from peewee import fn
from peewee import JOIN
from peewee import SQL

from .base import cyndi_join
from .base import DEFAULT_REMEDIATION_FILTER
from .base import edge_feature_arg
from .base import get_account_data
from .base import get_system_count_by_type
from .base import GetRequest
from .base import is_valid_cache
from .base import round_to_100_percent
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions
from common.config import Config
from common.feature_flags import UNLEASH
from common.logging import get_logger
from common.peewee_conditions import system_has_rule_hit
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import CveAccountCache
from common.peewee_model import CveMetadata
from common.peewee_model import CveRuleMapping
from common.peewee_model import InsightsRule
from common.peewee_model import RuleAccountCache
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities

LOGGER = get_logger(__name__)
CFG = Config()


class GetExecutive(GetRequest):
    """GET to /v1/report/executive"""

    _endpoint_name = r"/v1/report/executive"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.ADVANCED_REPORTING)
    def handle_get(cls, **kwargs):
        # pylint: disable=singleton-comparison, too-many-branches, too-many-statements
        retval = {
            "system_count": 0,
            "system_count_per_type": {"rpmdnf": 0},
            "cves_total": 0,
            "cves_by_severity": {
                "0to3.9": {
                    "percentage": 0,
                    "count": 0,
                    "known_exploit_count": 0
                },
                "4to7.9": {
                    "percentage": 0,
                    "count": 0,
                    "known_exploit_count": 0
                },
                "8to10": {
                    "percentage": 0,
                    "count": 0,
                    "known_exploit_count": 0
                },
            },
            "recent_cves": {
                "last7days": 0,
                "last30days": 0,
                "last90days": 0
            },
            "rules_total": 0,
            "rules_by_severity": {
                1: {
                    "rule_count": 0,
                    "systems_affected": 0
                },
                2: {
                    "rule_count": 0,
                    "systems_affected": 0
                },
                3: {
                    "rule_count": 0,
                    "systems_affected": 0
                },
                4: {
                    "rule_count": 0,
                    "systems_affected": 0
                },
            },
            "top_cves": [],
            "top_rules": [],
        }
        account_data = get_account_data(connexion.context["user"])
        if account_data is None:
            return retval

        # argument for controling host types in system counts
        edge = edge_feature_arg()
        system_cnt_type = get_system_count_by_type(account_data.id, edge=edge)
        retval["system_count"] = system_cnt_type["rpmdnf"] + system_cnt_type.get("edge", 0)
        retval["system_count_per_type"] = system_cnt_type
        if retval["system_count"] == 0:
            return retval

        # API using cache, set keepalive for account to enable maintaining cache
        valid_cache = is_valid_cache(account_data, g.group_ids)

        # Use cache if not disabled + cache exists
        if UNLEASH.is_enabled("vulnerability.account_cache") and valid_cache:
            selectables = [CveAccountCache.cve_id.alias("cve_id_")]
            if edge is False:
                selectables.append(CveAccountCache.systems_affected_rpmdnf.alias("systems_affected_"))
            else:
                selectables.append((CveAccountCache.systems_affected_rpmdnf + CveAccountCache.systems_affected_edge).alias("systems_affected_"))

            count_query = (CveAccountCache
                           .select(*selectables)
                           .where(CveAccountCache.rh_account_id == account_data.id))

            if edge is False:
                count_query = count_query.where(CveAccountCache.systems_affected_rpmdnf > 0)
            else:
                count_query = count_query.where((CveAccountCache.systems_affected_rpmdnf + CveAccountCache.systems_affected_edge) > 0)
        else:
            count_query = (SystemVulnerabilities
                           .select(SystemVulnerabilities.cve_id.alias("cve_id_"),
                                   fn.Count(SystemVulnerabilities.id).alias("systems_affected_"))
                           .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                                     system_is_active(rh_account_id=account_data.id, edge=edge)))
                           .where(SystemVulnerabilities.rh_account_id == account_data.id)
                           .where(system_is_vulnerable())
                           .where(SystemVulnerabilities.remediation_type_id << DEFAULT_REMEDIATION_FILTER)
                           .group_by(SystemVulnerabilities.cve_id))
            count_query = cyndi_join(count_query)

        cve_query = (CveMetadata
                     .select(CveMetadata.id.alias("cve_id"),
                             fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score, 0).alias("cvss_score"),
                             CveMetadata.public_date, CveMetadata.exploit_data, CveMetadata.advisories_list)
                     .join(count_query, JOIN.INNER, on=(CveMetadata.id == count_query.c.cve_id_))
                     .dicts())
        if not account_data.cves_without_errata:
            cve_query = cve_query.where(CveMetadata.advisories_list != SQL("'[]'"))

        cve_data = [(cve["cvss_score"], cve["public_date"], cve["exploit_data"], cve["advisories_list"]) for cve in cve_query]

        cves_total = len(cve_data)
        if cves_total == 0:
            return retval

        retval["cves_total"] = cves_total

        today = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)  # offset-aware
        last7 = today - timedelta(days=7)
        last30 = today - timedelta(days=30)
        last90 = today - timedelta(days=90)

        for cvss_score, public_date, exploit_data, advisories_list in cve_data:
            if cvss_score < 4:
                retval["cves_by_severity"]["0to3.9"]["count"] += 1
                if exploit_data and advisories_list:
                    retval["cves_by_severity"]["0to3.9"]["known_exploit_count"] += 1
            elif 4 <= cvss_score < 8:
                retval["cves_by_severity"]["4to7.9"]["count"] += 1
                if exploit_data and advisories_list:
                    retval["cves_by_severity"]["4to7.9"]["known_exploit_count"] += 1
            elif cvss_score >= 8 and advisories_list:
                retval["cves_by_severity"]["8to10"]["count"] += 1
                if exploit_data and advisories_list:
                    retval["cves_by_severity"]["8to10"]["known_exploit_count"] += 1

            if public_date is not None:
                if public_date >= last7:
                    retval["recent_cves"]["last7days"] += 1
                if public_date >= last30:
                    retval["recent_cves"]["last30days"] += 1
                if public_date >= last90:
                    retval["recent_cves"]["last90days"] += 1

        cve_count_by_severity = [v["count"] for v in retval["cves_by_severity"].values()]
        rounded_percentage = round_to_100_percent(cve_count_by_severity)

        for indx, keys in enumerate(retval["cves_by_severity"]):
            retval["cves_by_severity"][keys]["percentage"] = rounded_percentage[indx]

        # The algorithm searches for CVEs with cvss score between 8 and 10, and then sort by a number of affected
        # systems if there are not 3 CVE in the 8 to 10 range, then it looks for CVEs in 4 to 8 range, sorted by a
        # number of systems affected. The high-end range check is exclusive that is why 11 here.
        cves_limit = 3
        top_cves = cls._get_top_cves_by_cvss(8.0, 11, count_query, account_data.cves_without_errata, limit=cves_limit)
        cls._build_top_cves(top_cves, retval)
        cves_count = top_cves.count()
        if cves_count < cves_limit:
            next_tier_top = cls._get_top_cves_by_cvss(4.0, 8.0, count_query, account_data.cves_without_errata, limit=cves_limit - cves_count)
            cls._build_top_cves(next_tier_top, retval)
            next_cves_count = next_tier_top.count()
            if next_cves_count < (cves_limit - cves_count):
                last_tier_top = cls._get_top_cves_by_cvss(0.0, 4.0, count_query, account_data.cves_without_errata,
                                                          limit=cves_limit - (cves_count + next_cves_count))
                cls._build_top_cves(last_tier_top, retval)

        rules_breakdown = (SystemVulnerabilities.select(fn.COUNT(fn.Distinct(InsightsRule.id)).alias("rule_count"), InsightsRule.rule_impact.alias("severity"),
                                                        fn.COUNT(fn.Distinct(SystemVulnerabilities.system_id)).alias("systems_affected"))
                           .join(InsightsRule, on=(SystemVulnerabilities.rule_id == InsightsRule.id))
                           .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                                     system_is_active(rh_account_id=account_data.id, edge=edge)))
                           .where(SystemVulnerabilities.rh_account_id == account_data.id)
                           .where(system_has_rule_hit(rule_subselect=False))
                           .where(SystemVulnerabilities.remediation_type_id << DEFAULT_REMEDIATION_FILTER)
                           .group_by(InsightsRule.rule_impact)
                           .dicts())

        rules_breakdown = cyndi_join(rules_breakdown)

        for section in rules_breakdown:
            retval["rules_by_severity"][section["severity"]]["rule_count"] = section["rule_count"]
            retval["rules_by_severity"][section["severity"]]["systems_affected"] = section["systems_affected"]

        retval["rules_total"] = sum([item["rule_count"] for item in rules_breakdown])

        if UNLEASH.is_enabled("vulnerability.account_cache") and valid_cache:
            top_rules = (RuleAccountCache.select(InsightsRule.name.alias("rule_id"), InsightsRule.description_text.alias("name"),
                                                 InsightsRule.rule_impact.alias("severity"), InsightsRule.summary_text.alias("description"),
                                                 RuleAccountCache.systems_affected, fn.ARRAY_AGG(fn.Distinct(CveMetadata.cve)).alias("associated_cves"))
                         .join(InsightsRule, on=(RuleAccountCache.rule_id == InsightsRule.id))
                         .join(CveRuleMapping, on=(InsightsRule.id == CveRuleMapping.rule_id))
                         .join(CveMetadata, on=(CveRuleMapping.cve_id == CveMetadata.id))
                         .where(RuleAccountCache.rh_account_id == account_data.id)
                         .group_by(InsightsRule.name, InsightsRule.description_text, InsightsRule.rule_impact, InsightsRule.summary_text,
                                   RuleAccountCache.systems_affected)
                         .order_by(InsightsRule.rule_impact.desc(), RuleAccountCache.systems_affected.desc(), InsightsRule.description_text, InsightsRule.name)
                         .limit(3)
                         .dicts())
        else:
            top_rules = (SystemVulnerabilities.select(InsightsRule.name.alias("rule_id"), InsightsRule.description_text.alias("name"),
                                                      InsightsRule.rule_impact.alias("severity"), InsightsRule.summary_text.alias("description"),
                                                      fn.COUNT(fn.Distinct(SystemVulnerabilities.system_id)).alias("systems_affected"),
                                                      fn.ARRAY_AGG(fn.Distinct(CveMetadata.cve)).alias("associated_cves"))
                         .join(InsightsRule, on=(SystemVulnerabilities.rule_id == InsightsRule.id))
                         .join(CveRuleMapping, on=(InsightsRule.id == CveRuleMapping.rule_id))
                         .join(CveMetadata, on=(CveRuleMapping.cve_id == CveMetadata.id))
                         .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                                   system_is_active(rh_account_id=account_data.id, edge=edge)))
                         .where(SystemVulnerabilities.rh_account_id == account_data.id)
                         .where(system_has_rule_hit())
                         .where(SystemVulnerabilities.remediation_type_id << DEFAULT_REMEDIATION_FILTER)
                         .group_by(InsightsRule.name, InsightsRule.description_text, InsightsRule.rule_impact, InsightsRule.summary_text)
                         .order_by(InsightsRule.rule_impact.desc(), SQL("systems_affected desc"), InsightsRule.description_text, InsightsRule.name)
                         .limit(3)
                         .dicts())
            top_rules = cyndi_join(top_rules)

        for top_rule in top_rules:
            retval["top_rules"].append(top_rule)

        return retval

    @staticmethod
    def _get_top_cves_by_cvss(cvss_from, cvss_to, count_query, cves_without_errata, limit=3):
        # pylint: disable=singleton-comparison
        rules = (CveRuleMapping.select(CveRuleMapping.cve_id, CveRuleMapping.rule_id)
                 .join(InsightsRule, on=((CveRuleMapping.rule_id == InsightsRule.id) & (InsightsRule.active == True))))
        query = (CveMetadata.select(CveMetadata.cve, CveMetadata.cvss3_score, CveMetadata.cvss2_score,
                                    CveMetadata.description, CveMetadata.exploit_data, CveMetadata.advisories_list,
                                    count_query.c.systems_affected_.alias("systems_affected"),
                                    fn.ARRAY_AGG(rules.c.rule_id).alias("has_rule"))
                 .join(count_query, on=(CveMetadata.id == count_query.c.cve_id_))
                 .join(rules, JOIN.LEFT_OUTER, on=(CveMetadata.id == rules.c.cve_id))
                 .where((fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score) >= cvss_from) &
                        (fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score) < cvss_to))
                 .order_by(count_query.c.systems_affected_.desc(),
                           fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).desc(nulls="LAST"), CveMetadata.cve, CveMetadata.id)
                 .group_by(CveMetadata.id, CveMetadata.cve, CveMetadata.cvss3_score, CveMetadata.cvss2_score,
                           CveMetadata.description, count_query.c.systems_affected_.alias("systems_affected"))
                 .limit(limit)
                 .dicts())
        if not cves_without_errata:
            query = query.where(CveMetadata.advisories_list != SQL("'[]'"))
        return query

    @classmethod
    def _build_top_cves(cls, top_cves, retval):
        for cve in top_cves:
            cve_dict = {"synopsis": cve["cve"],
                        "cvss2_score": str(cve["cvss2_score"]),
                        "cvss3_score": str(cve["cvss3_score"]),
                        "description": cve["description"],
                        "systems_affected": cve["systems_affected"],
                        "security_rule": bool(cve["has_rule"]) and cve["has_rule"][0] is not None,
                        "known_exploit": cve["exploit_data"] is not None and bool(cve["advisories_list"])}
            cve_dict["rule_presence"] = cve_dict["security_rule"]
            retval["top_cves"].append(cve_dict)
