"""
Module for /report APIs
"""
from datetime import datetime, timedelta, timezone

import connexion
from peewee import fn, SQL, JOIN

from common.constants import HostType
from common.logging import get_logger
from common.peewee_model import CveMetadata, CveRuleMapping, InsightsRule, SystemVulnerabilities, SystemPlatform, CveAccountCache
from .base import GetRequest, round_to_100_percent, get_system_count, get_account_data, cyndi_join, DISABLE_ACCOUNT_CACHE, update_cve_cache_keepalive
from .rbac_manager import RbacRoutePermissions, RbacManager as RBAC

LOGGER = get_logger(__name__)


class GetExecutive(GetRequest):
    """GET to /v1/report/executive"""

    _endpoint_name = r'/v1/report/executive'

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.ADVANCED_REPORTING)
    def handle_get(cls, **kwargs):
        # pylint: disable=singleton-comparison, too-many-branches, too-many-statements
        retval = {
            'system_count': 0,
            'cves_total': 0,
            'cves_by_severity': {
                '0to3.9': {
                    'percentage': 0,
                    'count': 0,
                    'known_exploit_count': 0
                },
                '4to7.9': {
                    'percentage': 0,
                    'count': 0,
                    'known_exploit_count': 0
                },
                '8to10': {
                    'percentage': 0,
                    'count': 0,
                    'known_exploit_count': 0
                },
                'na': {
                    'percentage': 0,
                    'count': 0,
                    'known_exploit_count': 0
                }
            },
            'recent_cves': {
                'last7days': 0,
                'last30days': 0,
                'last90days': 0
            },
            'rules_total': 0,
            'rules_by_severity': {
                1: {
                    'rule_count': 0,
                    'systems_affected': 0
                },
                2: {
                    'rule_count': 0,
                    'systems_affected': 0
                },
                3: {
                    'rule_count': 0,
                    'systems_affected': 0
                },
                4: {
                    'rule_count': 0,
                    'systems_affected': 0
                },
            },
            'top_cves': [],
            'top_rules': [],
        }
        rh_account, cve_cache_from, cve_cache_keepalive = get_account_data(connexion.context['user'])
        if rh_account is None:
            return retval
        retval['system_count'] = get_system_count(rh_account)
        if retval['system_count'] == 0:
            return retval

        # API using cache, set keepalive for account to enable maintaining cache
        update_cve_cache_keepalive(rh_account, cve_cache_keepalive)

        # Use cache if not disabled + cache exists
        if not DISABLE_ACCOUNT_CACHE and cve_cache_from:
            count_query = (CveAccountCache
                           .select(CveAccountCache.cve_id.alias("cve_id_"),
                                   CveAccountCache.systems_affected.alias("systems_affected_"))
                           .where(CveAccountCache.rh_account_id == rh_account))
        else:
            count_query = (SystemVulnerabilities
                           .select(SystemVulnerabilities.cve_id.alias("cve_id_"),
                                   fn.Count(SystemVulnerabilities.id).alias("systems_affected_"))
                           .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id) &
                                                    (SystemPlatform.rh_account_id == rh_account) &
                                                    (SystemPlatform.opt_out == False) &
                                                    (SystemPlatform.stale == False) &
                                                    (SystemPlatform.when_deleted.is_null(True)) &
                                                    (fn.COALESCE(SystemPlatform.host_type, 'null') != HostType.EDGE))
                           .where(SystemVulnerabilities.rh_account_id == rh_account)
                           .where((SystemVulnerabilities.mitigation_reason.is_null(True)) |
                                  (SystemVulnerabilities.rule_id << InsightsRule.select(InsightsRule.id).where(
                                   (InsightsRule.active == False) & (~InsightsRule.rule_only))))
                           .where((SystemVulnerabilities.when_mitigated.is_null(True)) |
                                  (SystemVulnerabilities.rule_id << InsightsRule.select(InsightsRule.id).where(
                                   (InsightsRule.active == True) & (~InsightsRule.rule_only))))
                           .group_by(SystemVulnerabilities.cve_id))
            count_query = cyndi_join(count_query)

        cve_query = (CveMetadata
                     .select(CveMetadata.id.alias("cve_id"),
                             fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).alias('cvss_score'),
                             CveMetadata.public_date, CveMetadata.exploits)
                     .join(count_query, JOIN.INNER, on=(CveMetadata.id == count_query.c.cve_id_))
                     .dicts())

        cve_data = [(cve["cvss_score"], cve["public_date"], cve["exploits"]) for cve in cve_query]

        cves_total = len(cve_data)
        if cves_total == 0:
            return retval

        retval['cves_total'] = cves_total

        today = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)  # offset-aware
        last7 = today - timedelta(days=7)
        last30 = today - timedelta(days=30)
        last90 = today - timedelta(days=90)

        for cvss_score, public_date, exploits in cve_data:
            if cvss_score is None:
                retval["cves_by_severity"]["na"]["count"] += 1
                if exploits:
                    retval["cves_by_severity"]["na"]["known_exploit_count"] += 1
            elif cvss_score < 4:
                retval["cves_by_severity"]["0to3.9"]["count"] += 1
                if exploits:
                    retval["cves_by_severity"]["0to3.9"]["known_exploit_count"] += 1
            elif 4 <= cvss_score < 8:
                retval["cves_by_severity"]["4to7.9"]["count"] += 1
                if exploits:
                    retval["cves_by_severity"]["4to7.9"]["known_exploit_count"] += 1
            elif cvss_score >= 8:
                retval["cves_by_severity"]["8to10"]["count"] += 1
                if exploits:
                    retval["cves_by_severity"]["8to10"]["known_exploit_count"] += 1

            if public_date is not None:
                if public_date >= last7:
                    retval["recent_cves"]["last7days"] += 1
                if public_date >= last30:
                    retval["recent_cves"]["last30days"] += 1
                if public_date >= last90:
                    retval["recent_cves"]["last90days"] += 1

        cve_count_by_severity = [v['count'] for v in retval['cves_by_severity'].values()]
        rounded_percentage = round_to_100_percent(cve_count_by_severity)

        for indx, keys in enumerate(retval['cves_by_severity']):
            retval['cves_by_severity'][keys]['percentage'] = rounded_percentage[indx]

        # The algorithm searches for CVEs with cvss score between 8 and 10, and then sort by a number of affected
        # systems if there are not 3 CVE in the 8 to 10 range, then it looks for CVEs in 4 to 8 range, sorted by a
        # number of systems affected. The high-end range check is exclusive that is why 11 here.
        cves_limit = 3
        top_cves = cls._get_top_cves_by_cvss(8.0, 11, count_query, limit=cves_limit)
        cls._build_top_cves(top_cves, retval)
        cves_count = top_cves.count()
        if cves_count < cves_limit:
            next_tier_top = cls._get_top_cves_by_cvss(4.0, 8.0, count_query, limit=cves_limit - cves_count)
            cls._build_top_cves(next_tier_top, retval)
            next_cves_count = next_tier_top.count()
            if next_cves_count < (cves_limit - cves_count):
                last_tier_top = cls._get_top_cves_by_cvss(0.0, 4.0, count_query, limit=cves_limit - (cves_count + next_cves_count))
                cls._build_top_cves(last_tier_top, retval)

        rules_breakdown = (SystemVulnerabilities.select(fn.COUNT(fn.Distinct(InsightsRule.id)).alias('rule_count'), InsightsRule.rule_impact.alias('severity'),
                                                        fn.COUNT(fn.Distinct(SystemVulnerabilities.system_id)).alias('systems_affected'))
                           .join(InsightsRule, on=(SystemVulnerabilities.rule_id == InsightsRule.id))
                           .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id) &
                                                    (SystemPlatform.rh_account_id == rh_account) &
                                                    (SystemPlatform.opt_out == False) &
                                                    (SystemPlatform.stale == False) &
                                                    (SystemPlatform.when_deleted.is_null(True)) &
                                                    (SystemPlatform.last_evaluation.is_null(False) |
                                                     SystemPlatform.advisor_evaluated.is_null(False)) &
                                                    (fn.COALESCE(SystemPlatform.host_type, 'null') != HostType.EDGE))
                           .where(SystemVulnerabilities.rh_account_id == rh_account)
                           .where((SystemVulnerabilities.mitigation_reason.is_null(True)) &
                                  (SystemVulnerabilities.rule_id << InsightsRule.select(InsightsRule.id).where((InsightsRule.active == True)
                                                                                                               & (~InsightsRule.rule_only))))
                           .group_by(InsightsRule.rule_impact)
                           .dicts())

        rules_breakdown = cyndi_join(rules_breakdown)

        for section in rules_breakdown:
            retval['rules_by_severity'][section['severity']]['rule_count'] = section['rule_count']
            retval['rules_by_severity'][section['severity']]['systems_affected'] = section['systems_affected']

        retval['rules_total'] = sum([item['rule_count'] for item in rules_breakdown])

        top_rules = (SystemVulnerabilities.select(InsightsRule.name.alias('rule_id'), InsightsRule.description_text.alias('name'),
                                                  InsightsRule.rule_impact.alias('severity'), InsightsRule.summary_text.alias('description'),
                                                  fn.COUNT(fn.Distinct(SystemVulnerabilities.system_id)).alias('systems_affected'),
                                                  fn.ARRAY_AGG(fn.Distinct(CveMetadata.cve)).alias('associated_cves'))
                     .join(InsightsRule, on=(SystemVulnerabilities.rule_id == InsightsRule.id))
                     .join(CveRuleMapping, on=(InsightsRule.id == CveRuleMapping.rule_id))
                     .join(CveMetadata, on=(CveRuleMapping.cve_id == CveMetadata.id))
                     .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id) &
                                              (SystemPlatform.rh_account_id == rh_account) &
                                              (SystemPlatform.opt_out == False) &
                                              (SystemPlatform.stale == False) &
                                              (SystemPlatform.when_deleted.is_null(True)) &
                                              (SystemPlatform.last_evaluation.is_null(False) |
                                               SystemPlatform.advisor_evaluated.is_null(False)) &
                                              (fn.COALESCE(SystemPlatform.host_type, 'null') != HostType.EDGE))
                     .where(SystemVulnerabilities.rh_account_id == rh_account)
                     .where((SystemVulnerabilities.mitigation_reason.is_null(True)) &
                            (SystemVulnerabilities.rule_id << InsightsRule.select(InsightsRule.id).where((InsightsRule.active == True)
                                                                                                         & (~InsightsRule.rule_only))))
                     .group_by(InsightsRule.name, InsightsRule.description_text, InsightsRule.rule_impact, InsightsRule.summary_text)
                     .order_by(InsightsRule.rule_impact.desc(), SQL('systems_affected desc'), InsightsRule.description_text, InsightsRule.name)
                     .limit(3)
                     .dicts())

        top_rules = cyndi_join(top_rules)

        for top_rule in top_rules:
            retval['top_rules'].append(top_rule)

        return retval

    @staticmethod
    def _get_top_cves_by_cvss(cvss_from, cvss_to, count_query, limit=3):
        # pylint: disable=singleton-comparison
        rules = (CveRuleMapping.select(CveRuleMapping.cve_id, CveRuleMapping.rule_id)
                 .join(InsightsRule, on=((CveRuleMapping.rule_id == InsightsRule.id)
                                         & (InsightsRule.active == True) & (~InsightsRule.rule_only))))
        return (CveMetadata.select(CveMetadata.cve, CveMetadata.cvss3_score, CveMetadata.cvss2_score,
                                   CveMetadata.description, CveMetadata.exploits, count_query.c.systems_affected_.alias("systems_affected"),
                                   fn.ARRAY_AGG(rules.c.rule_id).alias('has_rule'))
                .join(count_query, on=(CveMetadata.id == count_query.c.cve_id_))
                .join(rules, JOIN.LEFT_OUTER, on=(CveMetadata.id == rules.c.cve_id))
                .where((fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score) >= cvss_from) &
                       (fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score) < cvss_to))
                .order_by(count_query.c.systems_affected_.desc(),
                          fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).desc(nulls='LAST'), CveMetadata.id)
                .group_by(CveMetadata.id, CveMetadata.cve, CveMetadata.cvss3_score, CveMetadata.cvss2_score,
                          CveMetadata.description, count_query.c.systems_affected_.alias("systems_affected"))
                .limit(limit)
                .dicts())

    @classmethod
    def _build_top_cves(cls, top_cves, retval):
        for cve in top_cves:
            cve_dict = {'synopsis': cve['cve'],
                        'cvss2_score': str(cve['cvss2_score']),
                        'cvss3_score': str(cve['cvss3_score']),
                        'description': cve['description'],
                        'systems_affected': cve['systems_affected'],
                        'security_rule': bool(cve['has_rule']) and cve['has_rule'][0] is not None,
                        'known_exploit': bool(cve['exploits'])}
            cve_dict['rule_presence'] = cve_dict['security_rule']
            retval['top_cves'].append(cve_dict)
