#!/usr/bin/env python3
"""
vulnerability-manager - backend for UI
"""
import json
from traceback import format_exc

import connexion
from connexion import context
from connexion.options import SwaggerUIOptions
from connexion.resolver import RestyResolver
from flask import abort
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from peewee import OperationalError
from prometheus_client import CollectorRegistry
from prometheus_client import generate_latest
from prometheus_client import multiprocess

from .base import forbidden_missing_entitlement
from .base import forbidden_rbac
from .base import init_status_cache as _init_status_cache
from .base import MissingEntitlementException
from .base import wait_on_cyndi as _wait_on_cyndi
from .middlewares import ErrorHandlerMiddleware
from .rbac_manager import RbacException
from common.config import Config
from common.constants import APP_VERSION
from common.feature_flags import initialize_unleash
from common.logging import get_logger
from common.logging import init_logging
from common.peewee_database import DB
from common.peewee_database import DB_READ_REPLICA

LOGGER = get_logger(__name__)
CFG = Config()


def metrics():
    registry = CollectorRegistry()
    multiprocess.MultiProcessCollector(registry)
    return generate_latest(registry)


def create_app(spec_files, wait_on_cyndi=True, init_status_cache=True):
    """Creates an aplication object which is then served by tornado"""
    app = connexion.App('Vulnerability Engine Manager', swagger_ui_options=SwaggerUIOptions(swagger_ui=True))
    app.app.config['MAX_CONTENT_LENGTH'] = CFG.max_request_size * 1024 * 1024  # MB
    app.app.url_map.strict_slashes = False
    for route in spec_files.keys():
        app.add_api(spec_files[route],
                    resolver=RestyResolver('api'),
                    validate_responses=True,
                    strict_validation=True,
                    base_path=route,
                    arguments={'app_version': APP_VERSION})

    app.add_error_handler(MissingEntitlementException, forbidden_missing_entitlement)
    app.add_error_handler(RbacException, forbidden_rbac)

    limiter = Limiter(app=app.app, key_func=get_remote_address)

    @app.app.after_request
    def set_default_headers(response):  # pylint: disable=unused-variable
        response.headers["Access-Control-Allow-Origin"] = "*"
        response.headers["Access-Control-Allow-Headers"] = "Content-Type, Access-Control-Allow-Headers, \
            Authorization, X-Requested-With, x-rh-identity"
        response.headers['Access-Control-Allow-Methods'] = 'GET, OPTIONS, PATCH, POST'

        # format default connexion errors into nicer messages
        if response.status_code >= 400:
            original = json.loads(response.data.decode('utf-8'))
            if isinstance(original, dict) and 'errors' not in original:
                response.data = json.dumps(
                    {'errors': [{'detail': original['detail'], 'status': str(original['status'])}]})

        return response

    # Apply global throttling for all routes
    @app.app.before_request
    @limiter.limit(f"{CFG.api_max_rps} per second",
                   key_func=lambda: context.request.headers.get("x-rh-identity"),
                   exempt_when=lambda: context.request.headers.get("x-rh-identity") is None)  # workaround for limiter errors
    def account_level_throttle():
        return

    # This hook ensures that a connection is opened to handle any queries
    # generated by the request.
    @app.app.before_request
    def _db_connect():
        try:
            DB.connect()
            if DB_READ_REPLICA:
                DB_READ_REPLICA.connect()
        except OperationalError:
            LOGGER.exception("Error occured while connecting to database. %s", format_exc())
            abort(503, "DB is not running")

    # This hook ensures that the connection is closed when we've finished
    # processing the request.
    @app.app.teardown_request
    def _db_close(exc):  # pylint: disable=unused-argument
        if not DB.is_closed():
            DB.close()
        if DB_READ_REPLICA and not DB_READ_REPLICA.is_closed():
            DB_READ_REPLICA.close()

    @app.app.before_request
    def _on_first_request():
        # The following line will remove this handler, making it
        # only run on the first request
        app.app.before_request_funcs[None].remove(_on_first_request)
        if wait_on_cyndi:
            _wait_on_cyndi()
        if init_status_cache:
            _init_status_cache()

    app.add_middleware(ErrorHandlerMiddleware, position=connexion.middleware.MiddlewarePosition.BEFORE_EXCEPTION)

    return app


init_logging(num_servers=int(CFG.gunicorn_workers))
initialize_unleash()
#  gunicorn expects an object called 'application' hence the pylint disable
application = create_app({CFG.default_route: 'manager.spec.yaml',  # pylint: disable=invalid-name
                          "": 'manager.healthz.spec.yaml'})
