#!/usr/bin/env python3
"""
vulnerability-manager - backend for UI
"""
import os
import json
from traceback import format_exc

from peewee import OperationalError
import connexion
from flask import abort
from connexion.resolver import RestyResolver
from prometheus_client import CollectorRegistry, generate_latest, multiprocess

from common.constants import APP_VERSION
from common.logging import init_logging, get_logger
from common.peewee_database import DB

from .base import DEFAULT_ROUTE, forbidden_missing_entitlement, forbidden_internal_only, forbidden_rbac, \
    MissingEntitlementException, InternalOnlyException, RbacException

LOGGER = get_logger(__name__)


def create_app():
    """Creates an aplication object which is then served by tornado"""
    app = connexion.App('Vulnerability Engine Manager', options={'swagger_ui': True})
    app.app.url_map.strict_slashes = False
    app.add_api('manager.spec.yaml',
                resolver=RestyResolver('api'),
                validate_responses=True,
                strict_validation=True,
                base_path=DEFAULT_ROUTE,
                arguments={'app_version': APP_VERSION})
    app.add_error_handler(MissingEntitlementException, forbidden_missing_entitlement)
    app.add_error_handler(InternalOnlyException, forbidden_internal_only)
    app.add_error_handler(RbacException, forbidden_rbac)

    @app.app.route('/metrics', methods=['GET'])
    def metrics():  # pylint: disable=unused-variable
        # /metrics API shouldn't be visible in the API documentation, hence it's added here in the create_app step
        registry = CollectorRegistry()
        multiprocess.MultiProcessCollector(registry)
        return generate_latest(registry)

    @app.app.after_request
    def set_default_headers(response):  # pylint: disable=unused-variable
        response.headers["Access-Control-Allow-Origin"] = "*"
        response.headers["Access-Control-Allow-Headers"] = "Content-Type, Access-Control-Allow-Headers, \
            Authorization, X-Requested-With, x-rh-identity"
        response.headers['Access-Control-Allow-Methods'] = 'GET, OPTIONS, PATCH, POST'

        # format default connexion errors into nicer messages
        if response.status_code >= 400:
            original = json.loads(response.data.decode('utf-8'))
            if isinstance(original, dict) and 'errors' not in original:
                response.data = json.dumps(
                    {'errors': [{'detail': original['detail'], 'status': str(original['status'])}]})

        return response

    # This hook ensures that a connection is opened to handle any queries
    # generated by the request.
    @app.app.before_request
    def _db_connect():
        try:
            DB.connect()
        except OperationalError:
            LOGGER.exception("Error occured while connecting to database. %s", format_exc())
            abort(503, "DB is not running")

    # This hook ensures that the connection is closed when we've finished
    # processing the request.
    @app.app.teardown_request
    def _db_close(exc):  # pylint: disable=unused-argument
        if not DB.is_closed():
            DB.close()

    return app


init_logging(num_servers=int(os.getenv("GUNICORN_WORKERS", "4")))
#  gunicorn expects an object called 'application' hence the pylint disable
application = create_app()  # pylint: disable=invalid-name

if __name__ == '__main__':
    application.run(host='0.0.0.0', port=8000)
