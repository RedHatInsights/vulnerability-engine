"""
Represents RBAC managing classes.
"""
from enum import Enum

import requests
from flask import g

from common.logging import get_logger
from common.config import Singleton, Config

LOGGER = get_logger(__name__)
CFG = Config()


class RbacException(Exception):
    """Represents RBAC-related exception"""

    def __init__(self, message):
        self.message = message
        super().__init__(self)


class RbacApp(str, Enum):
    """Enum represents RBAC application types"""
    VULNERABILITY = "vulnerability"
    INVENTORY = "inventory"
    REMEDIATIONS = "remediations"


class RbacResource(str, Enum):
    """Enum represents RBAC resource types"""
    VULNERABILITY_RESULTS = "vulnerability_results"
    CVE_BUSINESS_RISK_AND_STATUS = "cve.business_risk_and_status"
    SYSTEM_CVE_STATUS = "system.cve.status"
    ADVANCED_REPORT = "advanced_report"
    SYSTEM_OPT_OUT = "system.opt_out"
    EXPORT_AND_REPORT = "report_and_export"
    HOSTS = "hosts"
    REMEDIATION = "remediation"
    ANY = "*"


class RbacAction(str, Enum):
    """Enum represents RBAC action types"""
    READ = "read"
    WRITE = "write"
    ANY = "*"


class RbacPermission:
    """Class represents single permission"""

    def __init__(self, app: RbacApp, resource: RbacResource, action: RbacAction):
        self.app = app
        self.resource = resource
        self.action = action

    def __str__(self):
        return f"{self.app}:{self.resource}:{self.action}"

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        app = self.app == other.app
        resource = self.resource == other.resource or (self.resource == RbacResource.ANY) or (other.resource == RbacResource.ANY)
        action = self.action == other.action or (self.action == RbacAction.ANY) or (other.action == RbacAction.ANY)
        return app and resource and action


class RbacManager(metaclass=Singleton):
    """Class represents RBAC handling and verification."""

    rbac_url = f"{CFG.rbac_url}/api/rbac/v1/access/?application=vulnerability,inventory,remediations" if CFG.rbac_url else None

    @staticmethod
    def _parse_permission(permission: str) -> RbacPermission:
        try:
            app, resource, action = permission.split(":")
            # Verify that permissions are alright so we can log this
            RbacApp(app)
            RbacResource(resource)
            RbacAction(action)
        except ValueError:
            LOGGER.warning("Obtained unknown RBAC permission: %s", permission)
        return RbacPermission(app, resource, action)

    def _parse_permissions(self, response: dict) -> [RbacPermission]:
        """Method parses permissions from json into iterable permissions"""
        res = []
        for perm_raw in response["data"]:
            res.append(self._parse_permission(perm_raw["permission"]))
        return res

    def fetch_permissions(self, x_rh_identity: str) -> [RbacPermission]:
        """Method fetches the RBAC permissions for user"""
        if self.rbac_url:
            try:
                response = requests.get(self.rbac_url, headers={'x-rh-identity': x_rh_identity}, timeout=CFG.rbac_timeout)
            except requests.exceptions.RequestException as exc:
                LOGGER.exception("Error calling RBAC: ")
                raise RbacException({"msg": 'user access service is not available at the moment',
                                     "permissions": []}) from exc
            if response.status_code != 200:
                raise RbacException({"msg": 'user is not allowed by user management',
                                     "permissions": []})
            permissions = self._parse_permissions(response.json())
            # granular rbac feature flag is not enabled, check only for vuln:*:* perm
            if not CFG.granular_rbac:
                if RbacRoutePermissions.VULNERABILITY_ANY not in permissions:
                    raise RbacException({"msg": "user is missing vulnerability:*:* permission, denying access",
                                         "permissions": []})
            return permissions

        if not CFG.disable_rbac:
            raise RbacException({"msg": 'RBAC is not configured, denying access',
                                 "permissions": []})

        # If there is not RBAC URL + RBAC is disabled, needs to return permissions for anything
        return [RbacRoutePermissions.VULNERABILITY_ANY, RbacRoutePermissions.INVENTORY_READ]

    @staticmethod
    def _serialize_permissions(perms: [RbacPermission]) -> [str]:
        """Serialize list of permissions from list objects"""
        res = []
        for perm in perms:
            res.append(str(perm))
        return res

    @staticmethod
    def format_permissions(res):
        """Format permissions to the response of the endpoint"""
        if isinstance(res, dict):
            if "meta" in res:
                res["meta"].update({"permissions": RbacManager._serialize_permissions(g.get("rbac_perms", []))})
            else:
                res["meta"] = {"permissions": RbacManager._serialize_permissions(g.get("rbac_perms", []))}
        return res

    @staticmethod
    def need_permissions(perms_lists: [[RbacPermission]]):
        """Decorator for checking if fetched users permissions are in given permissions for endpoint"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                # Granular RBAC is not enabled, dont check anything
                if CFG.disable_rbac or not CFG.granular_rbac:
                    return RbacManager.format_permissions(func(*args, **kwargs))
                user_perms = g.rbac_perms
                is_permitted = False
                for perms_list in perms_lists:
                    is_permitted = all(default_perm in user_perms for default_perm in perms_list) or is_permitted
                if is_permitted:
                    return RbacManager.format_permissions(func(*args, **kwargs))
                return {"detail": {"msg": f"User does not have any single set of given permission sets {perms_lists}",
                                   "permissions": RbacManager._serialize_permissions(user_perms)},
                        "status": 403}, 403
            return wrapper
        return decorator

    @staticmethod
    def need_permissions_filter_value(filter_perms_value: dict):
        """Decorator for checking if fetched users permissions are in given permissions for filter usage.
           Decorator checks if the argument (filter) and value is present, and if its permissions are correct.
           Argument dictionary needs to be in format:
           {"<filter_parameter_name>: ([[RbacPermission]], <value>)}"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                def _in_or_equal(key, val, args):
                    is_eq = val == args[key]
                    try:
                        is_in = val in args[key]
                        return is_in or is_eq
                    except TypeError:
                        return is_eq

                # Granular RBAC is not enabled, dont check anything
                if CFG.disable_rbac or not CFG.granular_rbac:
                    return RbacManager.format_permissions(func(*args, **kwargs))
                user_perms = g.rbac_perms
                for filter_, perms_value in filter_perms_value.items():
                    perms_lists, value = perms_value
                    if filter_ in kwargs and _in_or_equal(filter_, value, kwargs):
                        is_permitted = False
                        for perms_list in perms_lists:
                            is_permitted = all(default_perm in user_perms for default_perm in perms_list) or is_permitted
                        if not is_permitted:
                            return {"detail": {"msg": f"User does not have any single set of given permission sets {perms_lists} for filter '{filter_}'",
                                               "permissions": RbacManager._serialize_permissions(user_perms)},
                                    "status": 403}, 403
                return RbacManager.format_permissions(func(*args, **kwargs))
            return wrapper
        return decorator


class RbacRoutePermissions:
    """Class defines permissions grouped for routes"""
    VULNERABILITY_ANY = RbacPermission(RbacApp.VULNERABILITY, RbacResource.ANY, RbacAction.ANY)
    INVENTORY_READ = RbacPermission(RbacApp.INVENTORY, RbacResource.HOSTS, RbacAction.READ)

    VULNERABILITY_RESULTS = [[RbacPermission(RbacApp.VULNERABILITY, RbacResource.VULNERABILITY_RESULTS, RbacAction.READ), INVENTORY_READ]]
    CVE_BR_AND_STATUS_EDIT = [[RbacPermission(RbacApp.VULNERABILITY, RbacResource.CVE_BUSINESS_RISK_AND_STATUS, RbacAction.WRITE), INVENTORY_READ]]
    SYSTEM_CVE_STATUS_EDIT = [[RbacPermission(RbacApp.VULNERABILITY, RbacResource.SYSTEM_CVE_STATUS, RbacAction.WRITE), INVENTORY_READ]]
    SYSTEM_OPT_OUT_READ = [[RbacPermission(RbacApp.VULNERABILITY, RbacResource.SYSTEM_OPT_OUT, RbacAction.READ), INVENTORY_READ]]
    SYSTEM_OPT_OUT_EDIT = [[RbacPermission(RbacApp.VULNERABILITY, RbacResource.SYSTEM_OPT_OUT, RbacAction.WRITE), INVENTORY_READ]]
    ADVANCED_REPORTING = [[RbacPermission(RbacApp.VULNERABILITY, RbacResource.ADVANCED_REPORT, RbacAction.READ), INVENTORY_READ]]
    REPORT_AND_EXPORT = [[RbacPermission(RbacApp.VULNERABILITY, RbacResource.EXPORT_AND_REPORT, RbacAction.READ), INVENTORY_READ]]
    REMEDIATIONS_READ = [[RbacPermission(RbacApp.REMEDIATIONS, RbacResource.REMEDIATION, RbacAction.READ), INVENTORY_READ]]


class RbacFilterRoutePermissions:
    """Class defines permissions grouped for filters"""
    OPT_OUT_VALUE = {"excluded": (RbacRoutePermissions.SYSTEM_OPT_OUT_EDIT + RbacRoutePermissions.SYSTEM_OPT_OUT_READ, True)}
    CSV_FORMAT_VALUE = {"data_format": (RbacRoutePermissions.REPORT_AND_EXPORT, "csv")}

    SYSTEMS_ENDPOINT_VALUES = {}
    SYSTEMS_ENDPOINT_VALUES.update(OPT_OUT_VALUE)
    SYSTEMS_ENDPOINT_VALUES.update(CSV_FORMAT_VALUE)

    CSV_FORMAT_ENDPOINTS = {}
    CSV_FORMAT_ENDPOINTS.update(CSV_FORMAT_VALUE)
