"""
Represents RBAC managing classes.
"""
from enum import Enum

import requests
from flask import g

from common.logging import get_logger
from common.config import Singleton, Config

LOGGER = get_logger(__name__)
CFG = Config()


class RbacException(Exception):
    """Represents RBAC-related exception"""

    def __init__(self, message):
        self.message = message
        super().__init__(self)


class RbacApp(str, Enum):
    """Enum represents RBAC application types"""
    VULNERABILITY = "vulnerability"


class RbacResource(str, Enum):
    """Enum represents RBAC resource types"""
    VULNERABILITY_RESULTS = "vulnerability_results"
    CVE_BUSINESS_RISK_AND_STATUS = "cve.business_risk_and_status"
    SYSTEM_CVE_STATUS = "system.cve.status"
    ADVANCED_REPORT = "advanced_report"
    SYSTEM_OPT_OUT = "system.opt_out"
    EXPORT_AND_REPORT = "report_and_export"
    ANY = "*"


class RbacAction(str, Enum):
    """Enum represents RBAC action types"""
    READ = "read"
    WRITE = "write"
    ANY = "*"


class RbacPermission:
    """Class represents single permission"""
    def __init__(self, app: RbacApp, resource: RbacResource, action: RbacAction):
        self.app = app
        self.resource = resource
        self.action = action

    def __str__(self):
        return f"{self.app}:{self.resource}:{self.action}"

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        return self.app == other.app and self.resource == other.resource and self.action == other.action


class RbacManager(metaclass=Singleton):
    """Class represents RBAC handling and verification."""
    session = None
    rbac_url = None
    disable_rbac = None
    rbac_timeout = None

    def __init__(self):
        self.session = requests.Session()
        if CFG.rbac_url:
            self.rbac_url = f"{CFG.rbac_url}/api/rbac/v1/access/?application=vulnerability"
        self.disable_rbac = CFG.disable_rbac
        self.rbac_timeout = CFG.rbac_timeout

    @staticmethod
    def _parse_permission(permission: str) -> RbacPermission:
        try:
            app, resource, action = permission.split(":")
            # Verify that permissions are alright so we can log this
            RbacApp(app)
            RbacResource(resource)
            RbacAction(action)
        except ValueError:
            LOGGER.warning("Obtained unknown RBAC permission: %s", permission)
        return RbacPermission(app, resource, action)

    def _parse_permissions(self, response: dict) -> [RbacPermission]:
        """Method parses permissions from json into iterable permissions"""
        res = []
        for perm_raw in response["data"]:
            res.append(self._parse_permission(perm_raw["permission"]))
        return res

    def fetch_permissions(self, x_rh_identity: str) -> [RbacPermission]:
        """Method fetches the RBAC permissions for user"""
        if self.rbac_url:
            try:
                response = self.session.get(self.rbac_url, headers={'x-rh-identity': x_rh_identity}, timeout=self.rbac_timeout)
            except requests.exceptions.RequestException as exc:
                LOGGER.exception("Error calling RBAC: ")
                raise RbacException({"msg": 'user access service is not available at the moment',
                                     "permissions": []}) from exc
            if response.status_code != 200:
                raise RbacException({"msg": 'user is not allowed by user management',
                                     "permissions": []})
            return self._parse_permissions(response.json())

        if not self.disable_rbac:
            raise RbacException({"msg": 'RBAC is not configured, denying access',
                                 "permissions": []})

        # If there is not RBAC URL + RBAC is disabled, needs to return permission for anything
        return [RbacRoutePermissions.VULNERABILITY_ANY]

    @staticmethod
    def _serialize_permissions(perms: [RbacPermission]) -> [str]:
        """Serialize list of permissions from list objects"""
        res = []
        for perm in perms:
            res.append(str(perm))
        return res

    @staticmethod
    def format_permissions(res):
        """Format permissions to the response of the endpoint"""
        if isinstance(res, dict):
            if "meta" in res:
                res["meta"].update({"permissions": RbacManager._serialize_permissions(g.get("rbac_perms", []))})
            else:
                res["meta"] = {"permissions": RbacManager._serialize_permissions(g.get("rbac_perms", []))}
        return res

    @staticmethod
    def need_permissions(perms: [RbacPermission], operator="or"):
        """Decorator for checking if fetched users permissions are in given permissions for endpoint"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                if RbacManager.disable_rbac:
                    return func(*args, **kwargs)

                user_perms = g.rbac_perms
                # If vulnerability:*:* is in perms or rbac is disabled, needs to allow anything
                if RbacRoutePermissions.VULNERABILITY_ANY in user_perms:
                    return RbacManager.format_permissions(func(*args, **kwargs))
                if operator == "or":
                    # Is there any user permission which is in the set needed permissions in decorator?
                    is_permitted = any(default_perm in user_perms for default_perm in perms)
                elif operator == "and":
                    is_permitted = all(default_perm in user_perms for default_perm in perms)
                if is_permitted:
                    return RbacManager.format_permissions(func(*args, **kwargs))
                return {"detail": {"msg": f"User does not have one of given permissions {perms}" if operator == "or"
                                   else f"User does not have all of given permissions {perms}",
                                   "permissions": RbacManager._serialize_permissions(user_perms)},
                        "status": 403}, 403
            return wrapper
        return decorator

    @staticmethod
    def need_permissions_filter_value(filter_perms_value: dict, operator="or"):
        """Decorator for checking if fetched users permissions are in given permissions for filter usage.
           Decorator checks if the argument (filter) and value is present, and if its permissions are correct.
           Argument dictionary needs to be in format:
           {"<filter_parameter_name>: ([RbacPermission], <value>)}"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                def _in_or_equal(key, val, args):
                    is_eq = val == args[key]
                    try:
                        is_in = val in args[key]
                        return is_in or is_eq
                    except TypeError:
                        return is_eq

                if RbacManager.disable_rbac:
                    return func(*args, **kwargs)

                user_perms = g.rbac_perms
                if RbacRoutePermissions.VULNERABILITY_ANY in user_perms:
                    return func(*args, **kwargs)
                for filter_, perms_value in filter_perms_value.items():
                    perms, value = perms_value
                    if filter_ in kwargs and _in_or_equal(filter_, value, kwargs):
                        is_permitted = False
                        if operator == "or":
                            is_permitted = any(default_perm in user_perms for default_perm in perms)
                        elif operator == "and":
                            is_permitted = all(default_perm in user_perms for default_perm in perms)
                        if not is_permitted:
                            return {"detail": f"User does not have one of given permissions {perms} for filter \"{filter_}\"" if operator == "or"
                                              else f"User does not have all of given permissions {perms}",
                                    "status": 403}, 403
                return RbacManager.format_permissions(func(*args, **kwargs))
            return wrapper
        return decorator


class RbacRoutePermissions:
    """Class defines permissions grouped for routes"""
    VULNERABILITY_ANY = RbacPermission(RbacApp.VULNERABILITY, RbacResource.ANY, RbacAction.ANY)

    VULNERABILITY_RESULTS = [RbacPermission(RbacApp.VULNERABILITY, RbacResource.VULNERABILITY_RESULTS, RbacAction.READ)]
    CVE_BR_AND_STATUS_EDIT = [RbacPermission(RbacApp.VULNERABILITY, RbacResource.CVE_BUSINESS_RISK_AND_STATUS, RbacAction.WRITE)]
    SYSTEM_CVE_STATUS_EDIT = [RbacPermission(RbacApp.VULNERABILITY, RbacResource.SYSTEM_CVE_STATUS, RbacAction.WRITE)]
    SYSTEM_OPT_OUT_READ = [RbacPermission(RbacApp.VULNERABILITY, RbacResource.SYSTEM_OPT_OUT, RbacAction.READ)]
    SYSTEM_OPT_OUT_EDIT = [RbacPermission(RbacApp.VULNERABILITY, RbacResource.SYSTEM_OPT_OUT, RbacAction.WRITE)]
    ADVANCED_REPORTING = [RbacPermission(RbacApp.VULNERABILITY, RbacResource.ADVANCED_REPORT, RbacAction.READ)]
    REPORT_AND_EXPORT = [RbacPermission(RbacApp.VULNERABILITY, RbacResource.EXPORT_AND_REPORT, RbacAction.READ)]


class RbacFilterValuePermissions:
    """Class defines permissions grouped for filters"""
    SHOW_OPTED_OUT = {"excluded": (RbacRoutePermissions.SYSTEM_OPT_OUT_EDIT + RbacRoutePermissions.SYSTEM_OPT_OUT_READ, True)}
