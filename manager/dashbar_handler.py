"""
Module for /dashbar API
"""
from connexion import context
from peewee import JOIN
from peewee import SQL
from peewee import Case
from peewee import fn

from common.config import Config
from common.feature_flags import UNLEASH
from common.logging import get_logger
from common.peewee_conditions import is_not_empty_list
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import CveAccountCache
from common.peewee_model import CveMetadata
from common.peewee_model import CveRuleMapping
from common.peewee_model import InsightsRule
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities

from .base import DEFAULT_REMEDIATION_FILTER
from .base import GetRequest
from .base import cyndi_join
from .base import get_account_data
from .base import is_not_cacheable_request
from .base import is_valid_cache
from .base import parse_tags
from .filters import apply_filters
from .filters import filter_types
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions

LOGGER = get_logger(__name__)
CFG = Config()


class GetDashbar(GetRequest):
    """GET to /v1/dashbar"""

    _endpoint_name = r"/v1/dashbar"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_get(cls, **kwargs):
        # pylint: disable=singleton-comparison
        args_desc = [
            {"arg_name": "tags", "convert_func": parse_tags},
            {"arg_name": "sap_system", "convert_func": None},
            {"arg_name": "sap_sids", "convert_func": None},
            {"arg_name": "ansible", "convert_func": None},
            {"arg_name": "mssql", "convert_func": None},
        ]
        args = cls._parse_arguments(kwargs, args_desc)
        filters = [filter_types.SYSTEM_TAGS, filter_types.SYSTEM_SAP, filter_types.SYSTEM_SAP_SIDS, filter_types.SYSTEM_AAP, filter_types.SYSTEM_MSSQL]

        account_data = get_account_data(context.context["user"])
        valid_cache = is_valid_cache(account_data, context.context["user"]["group_ids"])

        if UNLEASH.is_enabled("vulnerability.account_cache") and not is_not_cacheable_request(args) and valid_cache:
            query = (CveAccountCache
                     .select(fn.Count(fn.Distinct(Case(None, ((CveMetadata.exploit_data.is_null(False) &
                                                              is_not_empty_list(CveMetadata.advisories_list),
                                                               CveMetadata.id),)))).alias("exploitable_cves"),
                             fn.Count(fn.Distinct(Case(CveMetadata.impact_id, ((7, CveMetadata.id),)))).alias("critical_cves"),
                             fn.Count(fn.Distinct(Case(CveMetadata.impact_id, ((5, CveMetadata.id),)))).alias("important_cves"),
                             fn.Count(fn.Distinct(Case(None, ((InsightsRule.id.is_null(False), CveMetadata.id),)))).alias("cves_with_rule"))
                     .join(CveMetadata, on=(CveAccountCache.cve_id == CveMetadata.id))
                     .join(CveRuleMapping, JOIN.LEFT_OUTER, on=((CveAccountCache.cve_id == CveRuleMapping.cve_id)))
                     .join(InsightsRule, JOIN.LEFT_OUTER, on=((CveRuleMapping.rule_id == InsightsRule.id) &
                                                              (InsightsRule.active == True)))
                     .where(CveAccountCache.rh_account_id == account_data.id))
            query = query.where((CveAccountCache.systems_affected_rpmdnf + CveAccountCache.systems_affected_edge) > 0)
        else:
            query = (SystemVulnerabilities
                     .select(fn.Count(fn.Distinct(Case(None, ((CveMetadata.exploit_data.is_null(False) &
                                                               is_not_empty_list(CveMetadata.advisories_list),
                                                               CveMetadata.id),)))).alias("exploitable_cves"),
                             fn.Count(fn.Distinct(Case(CveMetadata.impact_id, ((7, CveMetadata.id),)))).alias("critical_cves"),
                             fn.Count(fn.Distinct(Case(CveMetadata.impact_id, ((5, CveMetadata.id),)))).alias("important_cves"),
                             fn.Count(fn.Distinct(Case(None, ((InsightsRule.id.is_null(False), CveMetadata.id),)))).alias("cves_with_rule"))
                     .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                     .join(CveRuleMapping, JOIN.LEFT_OUTER, on=((SystemVulnerabilities.cve_id == CveRuleMapping.cve_id)))
                     .join(InsightsRule, JOIN.LEFT_OUTER, on=(CveRuleMapping.rule_id == InsightsRule.id))
                     .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                               system_is_active(rh_account_id=account_data.id, edge=None)))
                     .where(SystemVulnerabilities.rh_account_id == account_data.id)
                     .where(system_is_vulnerable())
                     .where(SystemVulnerabilities.remediation_type_id << DEFAULT_REMEDIATION_FILTER))
            if not account_data.cves_without_errata:
                query = query.where(CveMetadata.advisories_list != SQL("'[]'"))
            query = cyndi_join(query)
            query = apply_filters(query, args, filters, {})
        res = query.first()

        return {"exploitable_cves": res.exploitable_cves,
                "critical_cves": res.critical_cves,
                "important_cves": res.important_cves,
                "cves_with_rule": res.cves_with_rule,
                "meta": {"cves_without_errata": account_data.cves_without_errata}}
