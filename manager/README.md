# Vulnerability Engine Manager Service

## Overview

The vulnerability engine manager service provides backend API for the UI. It's connexion (Flask) application, ran inside of tornado WSGI container.

### API design

The most important part of our API is `manager.spec.yaml` file which is our swagger documentation and which defines the API (the way how connexion framework works), the most important part of the documentation is the `operationId` parameter which defines which python function will be responsible for API call execution.

Existing API endpoints are all classmethods of {Get,Patch,Post}Request, a class which is full of class and static methods. That's because unlike tornado, Flask does not instantiate new objects each time API call is processed, but executes a function, static or class method.

### Adding new API endpoints

To add new API, simply add description of your API to the `manager.spec.yaml`. After that create a new class which inherits from manager.base.{Get,Patch,Post}Request and fill in the `handle_{get,patch,post}` class method.
The `operationId` in the manager spec should point to `{get,patch,post}` method of your new class as we're using inheritance to take care of error handling for us, e.g. `manager.$YOUR_NEW_MODULE.$YOUR_NEW_CLASS.get`.

To access information like e.g. `rh_account_number` simply `import connexion` and use the `connexion.context['user']` for that. Similarly you can access headers via `connexion.request.headers`.

All functions should accept `**kwargs` arguments as there is stored all input (described by the `manager.spec.yaml`), which means that if you e.g. specify a required integer parameter `length` in the spec it will be accessible via `kwargs['length']` and WILL always be there and WILL always be an integer. No additional checks required.

To access requestBody use `kwargs['data']`.

To return any data to client just `return` the data from the `handle_{get,patch,post}`. There's no need to call `json.dumps()` as it's done automatically by the connexion. If you want to return an error use `cls.format_exception(message, status_code).`
