"""
Module for /vulnerabilities API endpoint
"""
import connexion
import dateutil.parser
from flask import g
from peewee import Case
from peewee import fn
from peewee import JOIN
from peewee import SQL
from peewee import Value

from .base import cyndi_join
from .base import DEFAULT_BUSINESS_RISK
from .base import DEFAULT_REMEDIATION_FILTER
from .base import DEFAULT_STATUS
from .base import edge_feature_arg
from .base import get_account_data
from .base import get_remediation_filter
from .base import get_rules_for_cves
from .base import get_system_count_by_type
from .base import GetRequest
from .base import is_not_cacheable_request
from .base import is_valid_cache
from .base import parse_int_list
from .base import parse_str_list
from .base import parse_tags
from .base import PostRequest
from .base import remove_str_nulls
from .base import transform_ids
from .base import transform_names
from .base import unique_bool_list
from .filters import apply_filters
from .filters import filter_types
from .list_view import ListView
from .rbac_manager import RbacFilterRoutePermissions
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions
from common.config import Config
from common.constants import HostType
from common.feature_flags import UNLEASH
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import BusinessRisk
from common.peewee_model import CveAccountCache
from common.peewee_model import CveAccountData
from common.peewee_model import CveImpact
from common.peewee_model import CveMetadata
from common.peewee_model import CveRuleMapping
from common.peewee_model import InsightsRule
from common.peewee_model import Status
from common.peewee_model import SystemCveData
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities
from common.peewee_model import SystemVulnerablePackage
from common.peewee_model import VulnerablePackageCVE

CFG = Config()

CVE_SYNOPSIS_SORT = [fn.SUBSTRING(CveMetadata.cve, r"-(\d+)-").cast("integer"),
                     fn.SUBSTRING(CveMetadata.cve, r"-(\d+)$").cast("integer")]


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, account_data, list_args, uri, args):
        join_type = JOIN.INNER
        if (args["affecting"] is None and args["affecting_host_type"] is None) or \
            (args["affecting"] is not None and False in args["affecting"]) or \
                (args["affecting_host_type"] is not None and HostType.NONE in args["affecting_host_type"]):
            join_type = JOIN.LEFT_OUTER

        # API using cache, set keepalive for account to enable maintaining cache
        valid_cache = is_valid_cache(account_data, g.group_ids)

        full_query_filters = [filter_types.CVE_BUSINESS_RISK,
                              filter_types.CVE_CVSS,
                              filter_types.CVE_IMPACT,
                              filter_types.CVE_PUBLIC_DATE,
                              filter_types.CVE_RULE_PRESENCE,
                              filter_types.CVE_STATUS,
                              filter_types.CVE_AFFECTING,
                              filter_types.CVE_AFFECTING_HOST_TYPE,
                              filter_types.CVE_KNOWN_EXPLOITS,
                              filter_types.CVE_ADVISORY_AVAILABLE,
                              ]

        subquery_filters = [filter_types.SYSTEM_TAGS,
                            filter_types.SYSTEM_SAP,
                            filter_types.SYSTEM_SAP_SIDS,
                            filter_types.SYSTEM_RHEL_VERSION,
                            filter_types.SYSTEM_AAP,
                            filter_types.SYSTEM_MSSQL,
                            filter_types.INVENTORY_GROUP_IDS,
                            filter_types.INVENTORY_GROUP_NAMES,
                            ]

        # Use cache if not disabled + systems are not filtered + cache exists
        is_cached = UNLEASH.is_enabled("vulnerability.account_cache") and not is_not_cacheable_request(args) and valid_cache
        if is_cached:
            count_subquery = self._cached_count_subquery(account_data.id, account_data.cves_without_errata, args)
        else:
            if account_data.cves_without_errata:
                count_subquery = self._unpatched_count_subquery(account_data.id, args, subquery_filters)
            else:
                count_subquery = self._count_subquery(account_data.id, args, subquery_filters,
                                                      remediation_filter=DEFAULT_REMEDIATION_FILTER)

        query = self._full_query(account_data.id, join_type, count_subquery)
        query = apply_filters(query, args, full_query_filters, {"count_subquery": count_subquery})
        if not account_data.cves_without_errata:
            query = query.where(CveMetadata.advisories_list != SQL("'[]'"))
        query = query.dicts()

        sortable_columns = {
            "systems_affected": SQL("systems_affected"),
            "id": CveMetadata.id,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "business_risk_id": SQL("business_risk_id"),
            "business_risk": SQL("business_risk_id"),
            "status_id": SQL("status_id"),
            "status": SQL("status_id"),
            "advisory_available": SQL("advisory_available"),
        }
        default_sort_columns = {
            "default": "id",
            "cvss_score": "public_date",
            "cvss2_score": "public_date",
            "cvss3_score": "public_date",
            "public_date": "synopsis",
            "impact": "public_date",
            "systems_affected": "public_date",
            "business_risk": "public_date",
            "status": "public_date",
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description,
        }

        if list_args["filter"]:
            filter_expressions = {
                "rule_description": fn.Exists(CveRuleMapping
                                              .select(CveRuleMapping.cve_id)
                                              .join(InsightsRule, on=(CveRuleMapping.rule_id == InsightsRule.id))
                                              .where(CveRuleMapping.cve_id == CveMetadata.id)
                                              .where(InsightsRule.description_text.contains(list_args["filter"])))
            }
        else:
            filter_expressions = {}

        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, args, uri)

    @staticmethod
    def _full_query(rh_account_id, join_type, count_subquery):
        return (CveMetadata
                .select(CveMetadata.id.alias("cve_id"),
                        CveMetadata.cve.alias("cve_name"),
                        CveMetadata.cvss3_score,
                        CveMetadata.cvss2_score,
                        CveMetadata.impact_id,
                        CveMetadata.public_date,
                        CveMetadata.description.alias("cve_description"),
                        CveMetadata.exploit_data,
                        CveMetadata.advisories_list,
                        fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                        CveAccountData.business_risk_text.alias("business_risk_text"),
                        fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                        fn.COALESCE(CveAccountData.status_id, 0).alias("status_id"),
                        CveAccountData.status_text.alias("status_text"),
                        fn.COALESCE(Status.name, DEFAULT_STATUS).alias("status"),
                        fn.Sum((fn.COALESCE(count_subquery.c.systems_affected_rpmdnf_, 0) +
                                fn.COALESCE(count_subquery.c.systems_affected_edge_, 0))).alias("systems_affected"),
                        fn.Sum(fn.COALESCE(count_subquery.c.systems_status_divergent_, 0)).alias("systems_status_divergent"),
                        fn.Bool_Or(fn.COALESCE(count_subquery.c.advisory_available_, fn.COALESCE(CveMetadata.advisories_list, '[]') != SQL("'[]'")))
                        .alias("advisory_available"))
                .join(count_subquery, join_type, on=(CveMetadata.id == count_subquery.c.cve_id_))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveMetadata.id == CveAccountData.cve_id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id))
                .group_by(CveMetadata.id,
                          fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                          CveAccountData.business_risk_text.alias("business_risk_text"),
                          fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                          fn.COALESCE(CveAccountData.status_id, 0).alias("status_id"),
                          CveAccountData.status_text.alias("status_text"),
                          fn.COALESCE(Status.name, DEFAULT_STATUS).alias("status")))

    @staticmethod
    def _count_subquery(rh_account_id, args, filters, remediation_filter=None):
        # pylint: disable=singleton-comparison
        subq = (SystemVulnerabilities
                .select(SystemVulnerabilities.cve_id.alias("cve_id_"),
                        fn.SUM(Case(None, ((SystemPlatform.host_type.is_null(True), 1),), 0)).alias("systems_affected_rpmdnf_"),
                        fn.SUM(Case(None, ((SystemPlatform.host_type == "edge", 1),), 0)).alias("systems_affected_edge_"),
                        fn.SUM(Case(None, ((fn.COALESCE(SystemCveData.status_id, 0) != CveAccountData.status_id, 1),), 0))
                        .alias("systems_status_divergent_"),
                        fn.Bool_Or(SystemVulnerabilities.advisory_available).alias("advisory_available_"))
                .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                          system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg())))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((SystemVulnerabilities.cve_id == CveAccountData.cve_id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(SystemCveData, JOIN.LEFT_OUTER, on=((SystemPlatform.id == SystemCveData.system_id)
                                                          & (SystemVulnerabilities.cve_id == SystemCveData.cve_id)))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(system_is_vulnerable())
                .group_by(SystemVulnerabilities.cve_id))
        if remediation_filter:
            subq = subq.where(SystemVulnerabilities.remediation_type_id << remediation_filter)
        subq = cyndi_join(subq)
        subq = apply_filters(subq, args, filters, {})
        return subq

    @staticmethod
    def _unpatched_count_subquery(rh_account_id, args, filters):
        # pylint: disable=singleton-comparison
        remediation_filter, return_only_first_subq = get_remediation_filter(args["advisory_available"])

        fixed_subq = CvesListView._count_subquery(rh_account_id, args, filters, remediation_filter=remediation_filter)
        unfixed_subq = (SystemVulnerablePackage
                        .select(VulnerablePackageCVE.cve_id.alias("cve_id_"),
                                fn.COUNT(fn.DISTINCT(Case(None, ((SystemPlatform.host_type.is_null(True), SystemPlatform.id),), None)))
                                .alias("systems_affected_rpmdnf_"),
                                fn.COUNT(fn.DISTINCT(Case(None, ((SystemPlatform.host_type == "edge", SystemPlatform.id),), None)))
                                .alias("systems_affected_edge_"),
                                fn.SUM(Case(None, ((fn.COALESCE(SystemCveData.status_id, 0) != CveAccountData.status_id, 1),), 0))
                                .alias("systems_status_divergent_"),
                                Value(False).alias("advisory_available_"))
                        .join(SystemPlatform, on=((SystemVulnerablePackage.system_id == SystemPlatform.id) &
                                                  system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg())))
                        .join(VulnerablePackageCVE, on=((SystemVulnerablePackage.vulnerable_package_id == VulnerablePackageCVE.vulnerable_package_id)))
                        .join(CveAccountData, JOIN.LEFT_OUTER, on=((VulnerablePackageCVE.cve_id == CveAccountData.cve_id)
                                                                   & (CveAccountData.rh_account_id == rh_account_id)))
                        .join(SystemCveData, JOIN.LEFT_OUTER, on=((SystemPlatform.id == SystemCveData.system_id)
                                                                  & (VulnerablePackageCVE.cve_id == SystemCveData.cve_id)))
                        .where(SystemVulnerablePackage.rh_account_id == rh_account_id)
                        .group_by(VulnerablePackageCVE.cve_id))
        unfixed_subq = cyndi_join(unfixed_subq)
        unfixed_subq = apply_filters(unfixed_subq, args, filters, {})

        if return_only_first_subq:
            return fixed_subq
        else:
            return (fixed_subq + unfixed_subq)

    @staticmethod
    def _cached_count_subquery(rh_account_id, cves_without_errata, args):
        # Select only fixed counts by default
        systems_affected_rpmdnf = CveAccountCache.systems_affected_rpmdnf
        systems_affected_edge = CveAccountCache.systems_affected_edge
        systems_status_divergent = CveAccountCache.systems_status_divergent
        advisory_available_column = CveAccountCache.advisory_available
        # Override selected counts if advisory_available filter is used
        advisory_available = args["advisory_available"]
        if cves_without_errata:
            if advisory_available is None or (False in advisory_available and True in advisory_available):
                # Fixed + unfixed counts
                systems_affected_rpmdnf = (CveAccountCache.systems_affected_rpmdnf + CveAccountCache.systems_affected_unpatched_rpmdnf)
                systems_affected_edge = (CveAccountCache.systems_affected_edge + CveAccountCache.systems_affected_unpatched_edge)
                systems_status_divergent = (CveAccountCache.systems_status_divergent + fn.Coalesce(CveAccountCache.systems_status_divergent_unpatched, 0))
            elif False in advisory_available:
                # Only unfixed counts
                systems_affected_rpmdnf = CveAccountCache.systems_affected_unpatched_rpmdnf
                systems_affected_edge = CveAccountCache.systems_affected_unpatched_edge
                systems_status_divergent = fn.Coalesce(CveAccountCache.systems_status_divergent_unpatched, 0)
                advisory_available_column = Value(False)

        # edge systems are added in the cache, need to mock the systems_affected_edge_ column
        query = (CveAccountCache
                 .select(CveAccountCache.cve_id.alias("cve_id_"),
                         systems_affected_rpmdnf.alias("systems_affected_rpmdnf_"),
                         systems_affected_edge.alias("systems_affected_edge_"),
                         systems_status_divergent.alias("systems_status_divergent_"),
                         advisory_available_column.alias("advisory_available_"))
                 .where(CveAccountCache.rh_account_id == rh_account_id))
        return query


def _prepare_impact_id_map():
    impact_id_map = {}
    for row in CveImpact.select().dicts():
        impact_id_map[row["id"]] = row["name"]
    return impact_id_map


class GetCves(GetRequest):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r"/v1/vulnerabilities/cves"
    _ids_only = False

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.VULNERABILITIES_CVES_ENDPOINT)
    def handle_get(cls, **kwargs):
        """Grabs all CVEs user is affected by"""
        args_desc = [{"arg_name": "cvss_from", "convert_func": None},
                     {"arg_name": "cvss_to", "convert_func": None},
                     {"arg_name": "public_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "public_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "impact", "convert_func": parse_int_list},
                     {"arg_name": "business_risk_id", "convert_func": parse_int_list},
                     {"arg_name": "status_id", "convert_func": parse_int_list},
                     {"arg_name": "rule_presence", "convert_func": unique_bool_list},
                     {"arg_name": "affecting", "convert_func": None},
                     {"arg_name": "affecting_host_type", "convert_func": None},
                     {"arg_name": "tags", "convert_func": parse_tags},
                     {"arg_name": "sap_system", "convert_func": None},
                     {"arg_name": "sap_sids", "convert_func": None},
                     {"arg_name": "known_exploit", "convert_func": unique_bool_list},
                     {"arg_name": "rhel_version", "convert_func": parse_str_list},
                     {"arg_name": "ansible", "convert_func": None},
                     {"arg_name": "mssql", "convert_func": None},
                     {"arg_name": "advisory_available", "convert_func": unique_bool_list},
                     {"arg_name": "group_ids", "convert_func": transform_ids},
                     {"arg_name": "group_names", "convert_func": transform_names},
                     ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        account_data = get_account_data(connexion.context["user"])
        cves_view = CvesListView(
            account_data, list_arguments, connexion.request.path, args,
        )
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = cls._format_data(list_arguments["data_format"], cls.assign_cves(cves_view), ids_only=cls._ids_only)

        system_cnt_type = get_system_count_by_type(account_data.id, edge=edge_feature_arg())
        res["meta"]["system_count"] = system_cnt_type["rpmdnf"] + system_cnt_type.get("edge", 0)
        res["meta"]["system_count_per_type"] = system_cnt_type
        res["meta"]["cves_without_errata"] = account_data.cves_without_errata
        return res

    @classmethod
    def assign_cves(cls, cves_view):
        """Provides CVE details"""
        result = []
        if cls._ids_only:
            for row in cves_view:
                result.append({
                    "business_risk_id": row["business_risk_id"],
                    "business_risk_text": row["business_risk_text"],
                    "id": row["cve_name"],
                    "status_id": row["status_id"],
                    "status_text": row["status_text"],
                })
        else:
            impact_id_map = _prepare_impact_id_map()
            cves_materialized = list(cves_view)  # execute query
            rules_map = get_rules_for_cves([row["cve_id"] for row in cves_materialized], edge=edge_feature_arg())
            for row in cves_materialized:
                entry = dict()
                res = {}
                entry["systems_affected"] = int(row["systems_affected"])
                entry["synopsis"] = row["cve_name"]
                entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else None
                entry["impact"] = impact_id_map[row["impact_id"]]
                entry["description"] = row["cve_description"]
                # Store everything we know about CVSS - maybe UI needs to decide what to show
                entry["cvss2_score"] = str(row["cvss2_score"]) if row["cvss2_score"] is not None else None
                entry["cvss3_score"] = str(row["cvss3_score"]) if row["cvss3_score"] is not None else None
                entry["business_risk"] = row["business_risk"]
                entry["business_risk_id"] = row["business_risk_id"]
                entry["business_risk_text"] = row["business_risk_text"]
                entry["status"] = row["status"]
                entry["status_id"] = row["status_id"]
                entry["status_text"] = row["status_text"]
                entry["systems_status_divergent"] = int(row["systems_status_divergent"])
                entry["rules"] = rules_map.get(row["cve_id"], [])
                entry["known_exploit"] = row["exploit_data"] is not None and bool(row["advisories_list"])
                entry["advisory_available"] = row["advisory_available"]
                res["type"] = "cve"
                res["id"] = row["cve_name"]
                res["attributes"] = entry
                result.append(res)
        return result


class GetCvesIds(GetCves):
    """GET to /v1/vulnerabilities/cves/ids"""

    _endpoint_name = r"/v1/vulnerabilities/cves/ids"
    _ids_only = True


class SimpleCvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, list_args, cve_list, uri):
        cve_list = [remove_str_nulls(elem) for elem in cve_list]
        query = (CveMetadata.select(CveMetadata.cve,
                                    fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score, 0).alias("cvss_score"),
                                    CveImpact.name.alias("impact"))
                 .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                 .where(CveMetadata.cve.in_(cve_list))
                 .dicts())

        sortable_columns = {
            "synopsis": CVE_SYNOPSIS_SORT,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
        }
        default_sort_columns = {
            "default": "synopsis"
        }

        super().__init__(query, sortable_columns, default_sort_columns, filterable_columns, {}, list_args, [], uri)


class PostCves(PostRequest):
    """POST to /v1/vulnerabilities/cves"""

    _endpoint_name = r"/v1/vulnerabilities/cves"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_post(cls, **kwargs):
        list_arguments = cls._parse_list_arguments(kwargs)
        cves_view = SimpleCvesListView(list_arguments, kwargs["data"]["cve_list"], connexion.request.path)
        data = []
        for row in cves_view:
            entry = {}
            res = {}
            entry["synopsis"] = row["cve"]
            entry["impact"] = row["impact"]
            entry["cvss_score"] = str(row["cvss_score"]) if row["cvss_score"] is not None else None
            res["type"] = "cve"
            res["id"] = row["cve"]
            res["attributes"] = entry
            data.append(res)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = data

        return res
