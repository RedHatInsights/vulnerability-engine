#!/usr/bin/python3

import json
from random import randint

from common import BaseHandler, parse_url, vmaas_call
from database.database_handler import DatabaseHandler


class VulnerabilitiesHandler(BaseHandler):
    """Handler class returning data related to vulnerabilities."""

    def prepare(self):
        self.arguments = dict()
        for key in self.request.arguments.keys():
            self.arguments[key] = self.get_argument(key, None)

    def get(self):
        route = parse_url(self.request.uri, "/vulnerabilities")
        if len(route) == 1:
            if route[0] == "impacts":
                self.get_impacts()
            elif route[0] == "changes":
                self.get_changes()
            elif route[0] == "cves":
                self.get_cves()
        else:
            self.send_error(404)
        self.flush()

    def post(self):
        self.flush()

    # TODO: Needs to be tested, reduced and add error handling
    def get_impacts(self):
        cves = self.assign_cves()
        important = moderate = critical = low = 0
        for cve in cves:
            impact = cve["impact"]
            if impact in ["Important", "High"]:
                important = important + 1
            if impact in ["Moderate", "Medium"]:
                moderate = moderate + 1
            if impact in ["Critical"]:
                critical = critical + 1
            if impact in ["Low"]:
                low = low + 1
        result = dict()
        result["Important"] = important
        result["Moderate"] = moderate
        result["Critical"] = critical
        result["Low"] = low
        self.write(json.dumps(result))

    # TODO: This is just a skeleton
    def get_changes(self):
        result = dict()
        new_vulnerabilities = {"count": 5, "percentage": 9, "direction": "up"}
        remediated = {"count": 21, "percentage": 50, "direction": "down"}
        newly_affected = {"count": 2, "percentage": 3, "direction": "up"}
        result["since"] = self.arguments.get("since", None)
        result["new_vulnerabilities"] = new_vulnerabilities
        result["remediated"] = remediated
        result["newly_affected"] = newly_affected
        self.write(json.dumps(result))

    # TODO: Needs to be tested, reduced and add error handling
    def get_cves(self):
        result = self.assign_cves()
        self.write(json.dumps(result))

    # TODO: Needs to be tested, reduced and add error handling
    def assign_cves(self):
        result = []
        self.conn = DatabaseHandler.get_connection()
        cur = self.conn.cursor()
        cur.execute(
            "SELECT DISTINCT COUNT(sv.cve), sv.cve, vs.name \
            FROM system_vulnerabilities sv \
            JOIN vulnerability_source vs ON sv.vulnerability_source = vs.id \
            GROUP BY sv.cve, sv.vulnerability_source, vs.name"
        )
        cve_meta = cur.fetchall()
        cve_list = {"cve_list": [cve[1] for cve in cve_meta]}
        cve_details = vmaas_call("/api/v1/cves", cve_list)
        cve_details = cve_details["cve_list"]
        for cve in cve_meta:
            entry = dict()
            cve_detail = cve_details[cve[1]]
            entry["systems_affected"] = cve[0]
            entry["celebrity"] = True if cve[2] == "RULES" else False
            entry["synopsis"] = cve_detail["synopsis"]
            entry["public_date"] = cve_detail["public_date"]
            entry["impact"] = cve_detail["impact"]
            entry["description"] = cve_detail["description"]
            entry["total_risk"] = randint(1, 5) #TODO provide real value
            result.append(entry)
        return result
