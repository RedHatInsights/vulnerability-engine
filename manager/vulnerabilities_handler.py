#!/usr/bin/python3

import json
from random import randint

from common import AuthenticatedHandler, parse_url, vmaas_call
from database.database_handler import DatabaseHandler


class VulnerabilitiesHandler(AuthenticatedHandler):
    """Handler class returning data related to vulnerabilities."""

    def prepare(self):
        super(VulnerabilitiesHandler, self).prepare()
        self.arguments = dict()
        for key in self.request.arguments.keys():
            self.arguments[key] = self.get_argument(key, None)

    def get(self):
        """
        ---
        description: Get Vulnerabilities
        responses:
          200:
            description: Handler class returning data related to vulnerabilities.
        """
        route = parse_url(self.request.uri, "/vulnerabilities")
        if len(route) == 1:
            if route[0] == "impacts":
                self.get_impacts()
            elif route[0] == "changes":
                self.get_changes()
            elif route[0] == "cves":
                self.get_cves()
            elif route[0] == "errorkeys":
                self.get_error_keys()
        else:
            self.raiseError(404)
        self.flush()

    def post(self):
        self.flush()

    # TODO: Needs to be tested, reduced and add error handling
    def get_impacts(self):
        cves = self.assign_cves()
        important = moderate = critical = low = 0
        for cve in cves:
            impact = cve["impact"]
            if impact in ["Important", "High"]:
                important = important + 1
            if impact in ["Moderate", "Medium"]:
                moderate = moderate + 1
            if impact in ["Critical"]:
                critical = critical + 1
            if impact in ["Low"]:
                low = low + 1
        result = dict()
        result["Important"] = important
        result["Moderate"] = moderate
        result["Critical"] = critical
        result["Low"] = low
        self.write(json.dumps(result))

    # TODO: This is just a skeleton
    def get_changes(self):
        result = dict()
        new_vulnerabilities = {"count": 5, "percentage": 9, "direction": "up"}
        remediated = {"count": 21, "percentage": 50, "direction": "down"}
        newly_affected = {"count": 2, "percentage": 3, "direction": "up"}
        result["since"] = self.arguments.get("since", None)
        result["new_vulnerabilities"] = new_vulnerabilities
        result["remediated"] = remediated
        result["newly_affected"] = newly_affected
        self.write(json.dumps(result))

    # TODO: Needs to be tested, reduced and add error handling
    # TODO: Pagination
    # TODO: Needs search by "NAME + DESCRIPTION".
    # TODO: Needs ability to sort and filter by CVSS score and Publish date
    def get_cves(self):
        res = {}
        try:
            cves = self.assign_cves()
            # See JSON API spec
            pagination_links = {"first": "http://...", "last": "http://...",
                                "prev": "http://...", "next": "http://..."}
            # Basically all interesting info about this API/Filters/Sorts/Limits..., example
            res["meta"] = {"page": 1, "per_page": 10,
                           "total": 150, "pages": 10, "sorted_by": "synopsis"}

            res["data"] = cves
            res["links"] = pagination_links
        except Exception as e:
            self.raiseError(500, str(e))
            return
        self.write(json.dumps(res))

    # TODO: Needs to be tested, reduced and add error handling
    def assign_cves(self):
        result = []
        self.conn = DatabaseHandler.get_connection()
        cur = self.conn.cursor()
        cur.execute("""SELECT DISTINCT COUNT(sv.cve), sv.cve, min(vs.name) AS name, md.cvss3_score, md.impact,
                            md.public_date, md.description
                    FROM system_vulnerabilities sv
                    JOIN system_platform sp ON sv.platform_id = sp.platform_id
                    JOIN vulnerability_source vs ON sv.vulnerability_source = vs.id
                    JOIN cve_metadata md ON sv.cve = md.cve
                    WHERE sp.rh_account = %s
                    GROUP BY sv.cve, md.cvss3_score, md.impact,
                            md.public_date, md.description""", (self.rh_account_number,)
        )
        cve_meta = cur.fetchall()
        if cve_meta:
            cve_list = {"cve_list": [cve[1] for cve in cve_meta]}
            for cve in cve_meta:
                entry = dict()
                res = {}
                entry["systems_affected"] = cve[0]
                entry["celebrity"] = True if cve[2] == "RULES" else False
                entry["synopsis"] = cve[1]
                entry["public_date"] = cve[5].isoformat()
                entry["impact"] = cve[4]
                entry["description"] = cve[6]
                entry["cvss_score"] = str(cve[3])
                res["type"] = "cve"
                res["id"] = cve[1]
                res["attributes"] = entry
                result.append(res)
        return result

    # TODO: Needs to be tested, reduced and add error handling
    # TODO: Pagination, etc
    def get_error_keys(self):
        res = {}
        try:
            error_keys = self.assign_error_keys()
            # See JSON API spec
            pagination_links = {"first": "http://...", "last": "http://...",
                                "prev": "http://...", "next": "http://..."}
            # Basically all interesting info about this API/Filters/Sorts/Limits..., example
            res["meta"] = {"page": 1, "per_page": 10,
                           "total": 150, "pages": 10, "sorted_by": "synopsis"}

            res["data"] = error_keys
            res["links"] = pagination_links
        except Exception as e:
            self.set_status(666)
            res["errors"] = str(e)
            self.finish(res)
            return
        self.write(json.dumps(res))
    
    # TODO: Needs to be tested, reduced and add error handling
    def assign_error_keys(self):
        result = []
        self.conn = DatabaseHandler.get_connection()
        cur = self.conn.cursor()
        cur.execute(
            "SELECT DISTINCT COUNT(sek.platform_id), ek.name \
            FROM system_prodsec_error_key sek \
            JOIN system_platform sp ON sek.platform_id = sp.platform_id \
            JOIN prodsec_error_key ek ON sek.error_key_id = ek.id \
            WHERE sp.rh_account = %s \
            GROUP BY ek.name", (self.rh_account_number,)
        )
        ek_meta = cur.fetchall()
        for ek in ek_meta:
            entry = dict()
            res = {}
            res["type"] = "error_key"
            res["id"] = ek[1]
            res["attributes"] = {"systems_affected": ek[0]}
            result.append(res)
        return result
