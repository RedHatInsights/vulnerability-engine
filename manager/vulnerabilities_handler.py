"""
Module for /vulnerabilities API endpoint
"""

import dateutil.parser

import connexion
from peewee import Case, fn, JOIN, SQL

from common.peewee_model import BusinessRisk, CveAccountData, \
    CveMetadata, CveImpact, RHAccount, Status
from .base import DEFAULT_BUSINESS_RISK, DEFAULT_STATUS, GetRequest, parse_int_list, CVE_SYNOPSIS_SORT
from .list_view import ListView


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, list_args, query_args, uri, args={}):  # pylint: disable=dangerous-default-value
        join_type = JOIN.INNER
        cve_count = CveAccountData.systems_affected
        if 'show_all' in args and args['show_all']:
            join_type = JOIN.RIGHT_OUTER
            cve_count = fn.COALESCE(cve_count, 0)
        query = (
            CveAccountData
            .select(cve_count.alias("systems_affected"),
                    CveMetadata.cve.alias("cve_name"),
                    CveMetadata.cvss3_score,
                    CveMetadata.cvss2_score,
                    CveMetadata.impact_id,
                    CveMetadata.public_date,
                    CveMetadata.description.alias("cve_description"),
                    fn.COALESCE(CveAccountData.business_risk_id, 0).alias('business_risk_id'),
                    CveAccountData.business_risk_text.alias('business_risk_text'),
                    fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias('business_risk'),
                    fn.COALESCE(CveAccountData.status_id, 0).alias('status_id'),
                    CveAccountData.status_text.alias('status_text'),
                    fn.COALESCE(Status.name, DEFAULT_STATUS).alias('status'),
                    fn.COALESCE(CveAccountData.systems_status_divergent, 0).alias('systems_status_divergent'))
            .join(RHAccount, on=(CveAccountData.rh_account_id == RHAccount.id))
            .join(CveMetadata, join_type,
                  on=((CveAccountData.cve_id == CveMetadata.id)
                      & (RHAccount.name == query_args["rh_account_number"])))
            .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
            .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id))
        )
        if 'show_all' not in args or not args['show_all']:
            query = query.where(CveAccountData.systems_affected > 0)
        if 'cvss_from' in args and args['cvss_from']:
            query = query.where(fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score) >= args['cvss_from'])
        if 'cvss_to' in args and args['cvss_to']:
            query = query.where(fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score) <= args['cvss_to'])
        if 'public_from' in args and args['public_from']:
            query = query.where(CveMetadata.public_date >= args['public_from'])
        if 'public_to' in args and args['public_to']:
            query = query.where(CveMetadata.public_date <= args['public_to'])
        if 'impact' in args and args['impact']:
            query = query.where(CveMetadata.impact_id << args['impact'])
        if 'business_risk_id' in args and args['business_risk_id']:
            query = query.where(fn.COALESCE(CveAccountData.business_risk_id, 0) << args['business_risk_id'])
        if 'status_id' in args and args['status_id']:
            query = query.where(fn.COALESCE(CveAccountData.status_id, 0) << args['status_id'])
        query = query.dicts()
        sortable_columns = {
            "systems_affected": SQL('systems_affected'),
            "id": CveMetadata.id,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "business_risk_id": SQL('business_risk_id'),
            "business_risk": SQL('business_risk_id'),
            "status_id": SQL('status_id'),
            "status": SQL('status_id'),
        }
        default_sort_columns = ['id']
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description
        }
        super(CvesListView, self).__init__(query, sortable_columns, default_sort_columns,
                                           filterable_columns, list_args, args, uri)


def _prepare_impact_id_map():
    impact_id_map = {}
    for row in CveImpact.select().dicts():
        impact_id_map[row['id']] = row['name']
    return impact_id_map


def assign_cves(cves_view):
    """Provides CVE details"""
    result = []
    impact_id_map = _prepare_impact_id_map()
    for row in cves_view:
        entry = dict()
        res = {}
        entry["systems_affected"] = row["systems_affected"]
        entry["synopsis"] = row["cve_name"]
        entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else None
        entry["impact"] = impact_id_map[row["impact_id"]]
        entry["description"] = row["cve_description"]
        # Store everything we know about CVSS - maybe UI needs to decide what to show
        entry["cvss2_score"] = str(row["cvss2_score"]) if row['cvss2_score'] is not None else None
        entry["cvss3_score"] = str(row["cvss3_score"]) if row['cvss3_score'] is not None else None
        entry['business_risk'] = row['business_risk']
        entry['business_risk_id'] = row['business_risk_id']
        entry['business_risk_text'] = row['business_risk_text']
        entry['status'] = row['status']
        entry['status_id'] = row['status_id']
        entry['status_text'] = row['status_text']
        entry['systems_status_divergent'] = row['systems_status_divergent']
        res["type"] = "cve"
        res["id"] = row["cve_name"]
        res["attributes"] = entry
        result.append(res)
    return result


class GetCves(GetRequest):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r'/v1/vulnerabilities/cves'

    @classmethod
    def handle_get(cls, **kwargs):
        """Grabs all CVEs user is affected by"""
        args_desc = [{'arg_name': 'cvss_from', 'convert_func': None},
                     {'arg_name': 'cvss_to', 'convert_func': None},
                     {'arg_name': 'public_from', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'public_to', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'show_all', 'convert_func': None},
                     {'arg_name': 'impact', 'convert_func': parse_int_list},
                     {'arg_name': 'business_risk_id', 'convert_func': parse_int_list},
                     {'arg_name': 'status_id', 'convert_func': parse_int_list}]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        cves_view = CvesListView(list_arguments, {"rh_account_number": connexion.context['user']},
                                 connexion.request.path, args)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = cls._format_data(list_arguments["data_format"], assign_cves(cves_view))
        return res
