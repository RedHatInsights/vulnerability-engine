"""
Module for /vulnerabilities API endpoint
"""

import connexion
import dateutil.parser
from peewee import JOIN, SQL, Case, fn

from common.peewee_model import (
    BusinessRisk,
    CveAccountCache,
    CveAccountData,
    CveImpact,
    CveMetadata,
    CveRuleMapping,
    InsightsRule,
    Status,
    SystemPlatform,
    SystemVulnerabilities,
)
from common.peewee_conditions import system_is_active, system_is_vulnerable

from .base import (
    CVE_SYNOPSIS_SORT,
    DEFAULT_BUSINESS_RISK,
    DEFAULT_STATUS,
    DISABLE_ACCOUNT_CACHE,
    GetRequest,
    PostRequest,
    cyndi_join,
    get_account_data,
    get_rules_for_cves,
    get_system_count,
    is_cyndi_request,
    parse_int_list,
    parse_str_list,
    parse_tags,
    remove_str_nulls,
    unique_bool_list,
    update_cve_cache_keepalive,
)
from .filters import apply_filters, filter_types
from .list_view import ListView
from .rbac_manager import RbacFilterRoutePermissions
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, rh_account_id, cve_cache_from, cve_cache_keepalive, list_args, uri, args):
        join_type = JOIN.INNER
        if args["affecting"] is None or False in args["affecting"] or True not in args["affecting"]:
            join_type = JOIN.LEFT_OUTER

        # API using cache, set keepalive for account to enable maintaining cache
        update_cve_cache_keepalive(rh_account_id, cve_cache_keepalive)

        # Use cache if not disabled + systems are not filtered + cache exists
        if not DISABLE_ACCOUNT_CACHE and not is_cyndi_request(args) and cve_cache_from:
            count_subquery = self._cached_count_subquery(rh_account_id)
        else:
            count_subquery = self._count_subquery(rh_account_id)
            count_subquery = cyndi_join(count_subquery)
            if is_cyndi_request(args):
                count_subquery = apply_filters(
                    count_subquery,
                    args,
                    [
                        filter_types.SYSTEM_TAGS,
                        filter_types.SYSTEM_SAP,
                        filter_types.SYSTEM_SAP_SIDS,
                        filter_types.SYSTEM_RHEL_VERSION,
                        filter_types.SYSTEM_AAP,
                        filter_types.SYSTEM_MSSQL,
                    ],
                    {},
                )

        query = self._full_query(rh_account_id, join_type, count_subquery)
        query = apply_filters(
            query,
            args,
            [
                filter_types.CVE_BUSINESS_RISK,
                filter_types.CVE_CVSS,
                filter_types.CVE_IMPACT,
                filter_types.CVE_PUBLIC_DATE,
                filter_types.CVE_RULE_PRESENCE,
                filter_types.CVE_STATUS,
                filter_types.CVE_AFFECTING,
                filter_types.CVE_KNOWN_EXPLOITS,
            ],
            {"count_subquery": count_subquery},
        )
        query = query.dicts()

        sortable_columns = {
            "systems_affected": SQL("systems_affected"),
            "id": CveMetadata.id,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "business_risk_id": SQL("business_risk_id"),
            "business_risk": SQL("business_risk_id"),
            "status_id": SQL("status_id"),
            "status": SQL("status_id"),
        }
        default_sort_columns = {
            "default": "id",
            "cvss_score": "public_date",
            "cvss2_score": "public_date",
            "cvss3_score": "public_date",
            "public_date": "synopsis",
            "impact": "public_date",
            "systems_affected": "public_date",
            "business_risk": "public_date",
            "status": "public_date",
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description,
        }

        if list_args["filter"]:
            filter_expressions = {
                "rule_description": fn.Exists(
                    CveRuleMapping.select(CveRuleMapping.cve_id)
                    .join(InsightsRule, on=(CveRuleMapping.rule_id == InsightsRule.id))
                    .where(CveRuleMapping.cve_id == CveMetadata.id)
                    .where(InsightsRule.description_text.contains(list_args["filter"]))
                )
            }
        else:
            filter_expressions = {}

        super().__init__(query, sortable_columns, default_sort_columns, filterable_columns, filter_expressions, list_args, args, uri)

    @staticmethod
    def _full_query(rh_account_id, join_type, count_subquery):
        return (
            CveMetadata.select(
                CveMetadata.id.alias("cve_id"),
                CveMetadata.cve.alias("cve_name"),
                CveMetadata.cvss3_score,
                CveMetadata.cvss2_score,
                CveMetadata.impact_id,
                CveMetadata.public_date,
                CveMetadata.description.alias("cve_description"),
                CveMetadata.exploit_data,
                CveMetadata.advisories_list,
                fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                CveAccountData.business_risk_text.alias("business_risk_text"),
                fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                fn.COALESCE(CveAccountData.status_id, 0).alias("status_id"),
                CveAccountData.status_text.alias("status_text"),
                fn.COALESCE(Status.name, DEFAULT_STATUS).alias("status"),
                fn.COALESCE(count_subquery.c.systems_affected_, 0).alias("systems_affected"),
                fn.COALESCE(count_subquery.c.systems_status_divergent_, 0).alias("systems_status_divergent"),
            )
            .join(count_subquery, join_type, on=(CveMetadata.id == count_subquery.c.cve_id_))
            .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveMetadata.id == CveAccountData.cve_id) & (CveAccountData.rh_account_id == rh_account_id)))
            .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
            .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id))
        )

    @staticmethod
    def _count_subquery(rh_account_id):
        # pylint: disable=singleton-comparison
        return (
            SystemVulnerabilities.select(
                SystemVulnerabilities.cve_id.alias("cve_id_"),
                fn.Count(SystemVulnerabilities.id).alias("systems_affected_"),
                fn.Sum(Case(None, ((SystemVulnerabilities.status_id != CveAccountData.status_id, 1),), 0)).alias("systems_status_divergent_"),
            )
            .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) & system_is_active(rh_account_id=rh_account_id)))
            .join(
                CveAccountData, JOIN.LEFT_OUTER, on=((SystemVulnerabilities.cve_id == CveAccountData.cve_id) & (CveAccountData.rh_account_id == rh_account_id))
            )
            .where(SystemVulnerabilities.rh_account_id == rh_account_id)
            .where(system_is_vulnerable())
            .group_by(SystemVulnerabilities.cve_id)
        )

    @staticmethod
    def _cached_count_subquery(rh_account_id):
        return CveAccountCache.select(
            CveAccountCache.cve_id.alias("cve_id_"),
            CveAccountCache.systems_affected.alias("systems_affected_"),
            CveAccountCache.systems_status_divergent.alias("systems_status_divergent_"),
        ).where(CveAccountCache.rh_account_id == rh_account_id)


def _prepare_impact_id_map():
    impact_id_map = {}
    for row in CveImpact.select().dicts():
        impact_id_map[row["id"]] = row["name"]
    return impact_id_map


class GetCves(GetRequest):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r"/v1/vulnerabilities/cves"
    _ids_only = False

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.VULNERABILITIES_CVES_ENDPOINT)
    def handle_get(cls, **kwargs):
        """Grabs all CVEs user is affected by"""
        args_desc = [
            {"arg_name": "cvss_from", "convert_func": None},
            {"arg_name": "cvss_to", "convert_func": None},
            {"arg_name": "public_from", "convert_func": dateutil.parser.parse},
            {"arg_name": "public_to", "convert_func": dateutil.parser.parse},
            {"arg_name": "impact", "convert_func": parse_int_list},
            {"arg_name": "business_risk_id", "convert_func": parse_int_list},
            {"arg_name": "status_id", "convert_func": parse_int_list},
            {"arg_name": "rule_presence", "convert_func": unique_bool_list},
            {"arg_name": "affecting", "convert_func": None},
            {"arg_name": "tags", "convert_func": parse_tags},
            {"arg_name": "sap_system", "convert_func": None},
            {"arg_name": "sap_sids", "convert_func": None},
            {"arg_name": "known_exploit", "convert_func": unique_bool_list},
            {"arg_name": "rhel_version", "convert_func": parse_str_list},
            {"arg_name": "ansible", "convert_func": None},
            {"arg_name": "mssql", "convert_func": None},
        ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        rh_account_id, cve_cache_from, cve_cache_keepalive = get_account_data(connexion.context["user"])
        cves_view = CvesListView(rh_account_id, cve_cache_from, cve_cache_keepalive, list_arguments, connexion.request.path, args)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = cls._format_data(list_arguments["data_format"], cls.assign_cves(cves_view), ids_only=cls._ids_only)

        res["meta"]["system_count"] = get_system_count(rh_account_id)
        return res

    @classmethod
    def assign_cves(cls, cves_view):
        """Provides CVE details"""
        result = []
        if cls._ids_only:
            for row in cves_view:
                result.append(
                    {
                        "business_risk_id": row["business_risk_id"],
                        "business_risk_text": row["business_risk_text"],
                        "id": row["cve_name"],
                        "status_id": row["status_id"],
                        "status_text": row["status_text"],
                    }
                )
        else:
            impact_id_map = _prepare_impact_id_map()
            cves_materialized = list(cves_view)  # execute query
            rules_map = get_rules_for_cves([row["cve_id"] for row in cves_materialized])
            for row in cves_materialized:
                entry = dict()
                res = {}
                entry["systems_affected"] = row["systems_affected"]
                entry["synopsis"] = row["cve_name"]
                entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else None
                entry["impact"] = impact_id_map[row["impact_id"]]
                entry["description"] = row["cve_description"]
                # Store everything we know about CVSS - maybe UI needs to decide what to show
                entry["cvss2_score"] = str(row["cvss2_score"]) if row["cvss2_score"] is not None else None
                entry["cvss3_score"] = str(row["cvss3_score"]) if row["cvss3_score"] is not None else None
                entry["business_risk"] = row["business_risk"]
                entry["business_risk_id"] = row["business_risk_id"]
                entry["business_risk_text"] = row["business_risk_text"]
                entry["status"] = row["status"]
                entry["status_id"] = row["status_id"]
                entry["status_text"] = row["status_text"]
                entry["systems_status_divergent"] = row["systems_status_divergent"]
                entry["rules"] = rules_map.get(row["cve_id"], [])
                entry["known_exploit"] = row["exploit_data"] is not None and bool(row["advisories_list"])
                res["type"] = "cve"
                res["id"] = row["cve_name"]
                res["attributes"] = entry
                result.append(res)
        return result


class GetCvesIds(GetCves):
    """GET to /v1/vulnerabilities/cves/ids"""

    _endpoint_name = r"/v1/vulnerabilities/cves/ids"
    _ids_only = True


class SimpleCvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, list_args, cve_list, uri):
        cve_list = [remove_str_nulls(elem) for elem in cve_list]
        query = (
            CveMetadata.select(
                CveMetadata.cve, fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).alias("cvss_score"), CveImpact.name.alias("impact")
            )
            .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
            .where(CveMetadata.cve.in_(cve_list))
            .dicts()
        )

        sortable_columns = {
            "synopsis": CVE_SYNOPSIS_SORT,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), CveMetadata.cvss3_score),
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
        }
        default_sort_columns = {"default": "synopsis"}

        super().__init__(query, sortable_columns, default_sort_columns, filterable_columns, {}, list_args, [], uri)


class PostCves(PostRequest):
    """POST to /v1/vulnerabilities/cves"""

    _endpoint_name = r"/v1/vulnerabilities/cves"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_post(cls, **kwargs):
        list_arguments = cls._parse_list_arguments(kwargs)
        cves_view = SimpleCvesListView(list_arguments, kwargs["data"]["cve_list"], connexion.request.path)
        data = []
        for row in cves_view:
            entry = {}
            res = {}
            entry["synopsis"] = row["cve"]
            entry["impact"] = row["impact"]
            entry["cvss_score"] = str(row["cvss_score"]) if row["cvss_score"] is not None else None
            res["type"] = "cve"
            res["id"] = row["cve"]
            res["attributes"] = entry
            data.append(res)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = data

        return res
