"""
Module for /vulnerabilities API endpoint
"""
import connexion
import dateutil.parser
from peewee import Case
from peewee import fn
from peewee import JOIN
from peewee import SQL
from peewee import Value

from .base import cyndi_join
from .base import DEFAULT_BUSINESS_RISK
from .base import DEFAULT_STATUS
from .base import DISABLE_ACCOUNT_CACHE
from .base import edge_feature_arg
from .base import get_account_data
from .base import get_rules_for_cves
from .base import get_system_count
from .base import GetRequest
from .base import is_not_cacheable_request
from .base import parse_int_list
from .base import parse_str_list
from .base import parse_tags
from .base import PostRequest
from .base import remove_str_nulls
from .base import transform_ids
from .base import transform_names
from .base import unique_bool_list
from .base import update_cve_cache_keepalive
from .filters import apply_filters
from .filters import filter_types
from .list_view import ListView
from .rbac_manager import RbacFilterRoutePermissions
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions
from common.config import Config
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import BusinessRisk
from common.peewee_model import CveAccountCache
from common.peewee_model import CveAccountData
from common.peewee_model import CveImpact
from common.peewee_model import CveMetadata
from common.peewee_model import CveRuleMapping
from common.peewee_model import InsightsRule
from common.peewee_model import Status
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities
from common.peewee_model import SystemVulnerablePackage
from common.peewee_model import VulnerablePackageCVE

CFG = Config()

CVE_SYNOPSIS_SORT = [fn.SUBSTRING(CveMetadata.cve, r"-(\d+)-").cast("integer"),
                     fn.SUBSTRING(CveMetadata.cve, r"-(\d+)$").cast("integer")]


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, rh_account_id, cve_cache_from, cve_cache_keepalive, cves_without_errata, list_args, uri, args):
        join_type = JOIN.INNER
        if args["affecting"] is None or False in args["affecting"] or True not in args["affecting"]:
            join_type = JOIN.LEFT_OUTER

        # API using cache, set keepalive for account to enable maintaining cache
        update_cve_cache_keepalive(rh_account_id, cve_cache_keepalive)

        full_query_filters = [filter_types.CVE_BUSINESS_RISK,
                              filter_types.CVE_CVSS,
                              filter_types.CVE_IMPACT,
                              filter_types.CVE_PUBLIC_DATE,
                              filter_types.CVE_RULE_PRESENCE,
                              filter_types.CVE_STATUS,
                              filter_types.CVE_AFFECTING,
                              filter_types.CVE_AFFECTING_HOST_TYPE,
                              filter_types.CVE_KNOWN_EXPLOITS,
                              filter_types.CVE_ADVISORY_AVAILABLE,
                              ]

        subquery_filters = [filter_types.SYSTEM_TAGS,
                            filter_types.SYSTEM_SAP,
                            filter_types.SYSTEM_SAP_SIDS,
                            filter_types.SYSTEM_RHEL_VERSION,
                            filter_types.SYSTEM_AAP,
                            filter_types.SYSTEM_MSSQL,
                            filter_types.INVENTORY_GROUP_IDS,
                            filter_types.INVENTORY_GROUP_NAMES,
                            ]

        # Use cache if not disabled + systems are not filtered + cache exists
        is_cached = not DISABLE_ACCOUNT_CACHE and not is_not_cacheable_request(args) and cve_cache_from
        if is_cached:
            count_subquery = self._cached_count_subquery(rh_account_id, cves_without_errata, args)
        else:
            if cves_without_errata:
                count_subquery = self._unpatched_count_subquery(rh_account_id, args, subquery_filters)
            else:
                count_subquery = self._count_subquery(rh_account_id, args, subquery_filters)

        query = self._full_query(rh_account_id, join_type, count_subquery)
        query = apply_filters(query, args, full_query_filters, {"count_subquery": count_subquery, "is_cached": is_cached})
        if not cves_without_errata:
            query = query.where(CveMetadata.advisories_list != SQL("'[]'"))
        query = query.dicts()

        sortable_columns = {
            "systems_affected": SQL("systems_affected"),
            "id": CveMetadata.id,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "business_risk_id": SQL("business_risk_id"),
            "business_risk": SQL("business_risk_id"),
            "status_id": SQL("status_id"),
            "status": SQL("status_id"),
            "advisory_available": SQL("advisory_available"),
        }
        default_sort_columns = {
            "default": "id",
            "cvss_score": "public_date",
            "cvss2_score": "public_date",
            "cvss3_score": "public_date",
            "public_date": "synopsis",
            "impact": "public_date",
            "systems_affected": "public_date",
            "business_risk": "public_date",
            "status": "public_date",
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description,
        }

        if list_args["filter"]:
            filter_expressions = {
                "rule_description": fn.Exists(CveRuleMapping
                                              .select(CveRuleMapping.cve_id)
                                              .join(InsightsRule, on=(CveRuleMapping.rule_id == InsightsRule.id))
                                              .where(CveRuleMapping.cve_id == CveMetadata.id)
                                              .where(InsightsRule.description_text.contains(list_args["filter"])))
            }
        else:
            filter_expressions = {}

        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, args, uri)

    @staticmethod
    def _full_query(rh_account_id, join_type, count_subquery):
        return (CveMetadata
                .select(CveMetadata.id.alias("cve_id"),
                        CveMetadata.cve.alias("cve_name"),
                        CveMetadata.cvss3_score,
                        CveMetadata.cvss2_score,
                        CveMetadata.impact_id,
                        CveMetadata.public_date,
                        CveMetadata.description.alias("cve_description"),
                        CveMetadata.exploit_data,
                        CveMetadata.advisories_list,
                        fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                        CveAccountData.business_risk_text.alias("business_risk_text"),
                        fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                        fn.COALESCE(CveAccountData.status_id, 0).alias("status_id"),
                        CveAccountData.status_text.alias("status_text"),
                        fn.COALESCE(Status.name, DEFAULT_STATUS).alias("status"),
                        fn.Sum((fn.COALESCE(count_subquery.c.systems_affected_rpmdnf_, 0) +
                                fn.COALESCE(count_subquery.c.systems_affected_edge_, 0))).alias("systems_affected"),
                        fn.Sum(fn.COALESCE(count_subquery.c.systems_status_divergent_, 0)).alias("systems_status_divergent"),
                        fn.Bool_Or(fn.COALESCE(count_subquery.c.advisory_available_, fn.COALESCE(CveMetadata.advisories_list, '[]') != SQL("'[]'")))
                        .alias("advisory_available"))
                .join(count_subquery, join_type, on=(CveMetadata.id == count_subquery.c.cve_id_))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveMetadata.id == CveAccountData.cve_id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id))
                .group_by(CveMetadata.id,
                          fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                          CveAccountData.business_risk_text.alias("business_risk_text"),
                          fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                          fn.COALESCE(CveAccountData.status_id, 0).alias("status_id"),
                          CveAccountData.status_text.alias("status_text"),
                          fn.COALESCE(Status.name, DEFAULT_STATUS).alias("status")))

    @staticmethod
    def _count_subquery(rh_account_id, args, filters):
        # pylint: disable=singleton-comparison
        subq = (SystemVulnerabilities
                .select(SystemVulnerabilities.cve_id.alias("cve_id_"),
                        fn.SUM(Case(None, ((SystemPlatform.host_type.is_null(True), 1),), 0)).alias("systems_affected_rpmdnf_"),
                        fn.SUM(Case(None, ((SystemPlatform.host_type == "edge", 1),), 0)).alias("systems_affected_edge_"),
                        fn.SUM(Case(None, ((SystemVulnerabilities.status_id != CveAccountData.status_id, 1),), 0)).alias("systems_status_divergent_"),
                        fn.Bool_Or(SystemVulnerabilities.advisory_available).alias("advisory_available_"))
                .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                          system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg())))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((SystemVulnerabilities.cve_id == CveAccountData.cve_id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(system_is_vulnerable())
                .group_by(SystemVulnerabilities.cve_id))
        subq = cyndi_join(subq)
        subq = apply_filters(subq, args, filters, {})
        return subq

    @staticmethod
    def _unpatched_count_subquery(rh_account_id, args, filters):
        # pylint: disable=singleton-comparison
        fixed_subq = CvesListView._count_subquery(rh_account_id, args, filters)
        unfixed_subq = (SystemVulnerablePackage
                        .select(VulnerablePackageCVE.cve_id.alias("cve_id_"),
                                fn.COUNT(fn.DISTINCT(Case(None, ((SystemPlatform.host_type.is_null(True), SystemPlatform.id),), None)))
                                .alias("systems_affected_rpmdnf_"),
                                fn.COUNT(fn.DISTINCT(Case(None, ((SystemPlatform.host_type == "edge", SystemPlatform.id),), None)))
                                .alias("systems_affected_edge_"),
                                Value(0).alias("systems_status_divergent_"),
                                Value(False).alias("advisory_available_"))
                        .join(SystemPlatform, on=((SystemVulnerablePackage.system_id == SystemPlatform.id) &
                                                  system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg())))
                        .join(VulnerablePackageCVE, on=((SystemVulnerablePackage.vulnerable_package_id == VulnerablePackageCVE.vulnerable_package_id)))
                        .where(SystemVulnerablePackage.rh_account_id == rh_account_id)
                        .group_by(VulnerablePackageCVE.cve_id))
        unfixed_subq = cyndi_join(unfixed_subq)
        unfixed_subq = apply_filters(unfixed_subq, args, filters, {})
        advisory_available = args["advisory_available"]
        if advisory_available is None or (False in advisory_available and True in advisory_available):
            return (fixed_subq + unfixed_subq)
        elif False in advisory_available:
            return unfixed_subq
        else:
            return fixed_subq

    @staticmethod
    def _cached_count_subquery(rh_account_id, cves_without_errata, args):
        # Select only fixed counts by default
        systems_affected = CveAccountCache.systems_affected
        systems_status_divergent = CveAccountCache.systems_status_divergent
        # Override selected counts if advisory_available filter is used
        advisory_available = args["advisory_available"]
        if cves_without_errata:
            if advisory_available is None or (False in advisory_available and True in advisory_available):
                # Fixed + unfixed counts
                systems_affected = (CveAccountCache.systems_affected + fn.Coalesce(CveAccountCache.systems_affected_unpatched, 0))
                systems_status_divergent = (CveAccountCache.systems_status_divergent + fn.Coalesce(CveAccountCache.systems_status_divergent_unpatched, 0))
            elif False in advisory_available:
                # Only unfixed counts
                systems_affected = fn.Coalesce(CveAccountCache.systems_affected_unpatched, 0)
                systems_status_divergent = fn.Coalesce(CveAccountCache.systems_status_divergent_unpatched, 0)

        # edge systems are added in the cache, need to mock the systems_affected_edge_ column
        query = (CveAccountCache
                 .select(CveAccountCache.cve_id.alias("cve_id_"),
                         systems_affected.alias("systems_affected_rpmdnf_"),
                         Value(0).alias("systems_affected_edge_"),
                         systems_status_divergent.alias("systems_status_divergent_"),
                         CveAccountCache.advisory_available.alias("advisory_available_"))
                 .where(CveAccountCache.rh_account_id == rh_account_id))
        return query


def _prepare_impact_id_map():
    impact_id_map = {}
    for row in CveImpact.select().dicts():
        impact_id_map[row["id"]] = row["name"]
    return impact_id_map


class GetCves(GetRequest):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r"/v1/vulnerabilities/cves"
    _ids_only = False

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.VULNERABILITIES_CVES_ENDPOINT)
    def handle_get(cls, **kwargs):
        """Grabs all CVEs user is affected by"""
        args_desc = [{"arg_name": "cvss_from", "convert_func": None},
                     {"arg_name": "cvss_to", "convert_func": None},
                     {"arg_name": "public_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "public_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "impact", "convert_func": parse_int_list},
                     {"arg_name": "business_risk_id", "convert_func": parse_int_list},
                     {"arg_name": "status_id", "convert_func": parse_int_list},
                     {"arg_name": "rule_presence", "convert_func": unique_bool_list},
                     {"arg_name": "affecting", "convert_func": None},
                     {"arg_name": "affecting_host_type", "convert_func": None},
                     {"arg_name": "tags", "convert_func": parse_tags},
                     {"arg_name": "sap_system", "convert_func": None},
                     {"arg_name": "sap_sids", "convert_func": None},
                     {"arg_name": "known_exploit", "convert_func": unique_bool_list},
                     {"arg_name": "rhel_version", "convert_func": parse_str_list},
                     {"arg_name": "ansible", "convert_func": None},
                     {"arg_name": "mssql", "convert_func": None},
                     {"arg_name": "advisory_available", "convert_func": unique_bool_list},
                     {"arg_name": "group_ids", "convert_func": transform_ids},
                     {"arg_name": "group_names", "convert_func": transform_names},
                     ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        rh_account_id, cve_cache_from, cve_cache_keepalive, cves_without_errata = get_account_data(connexion.context["user"])
        cves_view = CvesListView(
            rh_account_id, cve_cache_from, cve_cache_keepalive, cves_without_errata, list_arguments, connexion.request.path, args,
        )
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = cls._format_data(list_arguments["data_format"], cls.assign_cves(cves_view), ids_only=cls._ids_only)

        res["meta"]["system_count"] = get_system_count(rh_account_id, edge=edge_feature_arg())
        res["meta"]["cves_without_errata"] = cves_without_errata
        return res

    @classmethod
    def assign_cves(cls, cves_view):
        """Provides CVE details"""
        result = []
        if cls._ids_only:
            for row in cves_view:
                result.append({
                    "business_risk_id": row["business_risk_id"],
                    "business_risk_text": row["business_risk_text"],
                    "id": row["cve_name"],
                    "status_id": row["status_id"],
                    "status_text": row["status_text"],
                })
        else:
            impact_id_map = _prepare_impact_id_map()
            cves_materialized = list(cves_view)  # execute query
            rules_map = get_rules_for_cves([row["cve_id"] for row in cves_materialized], edge=edge_feature_arg())
            for row in cves_materialized:
                entry = dict()
                res = {}
                entry["systems_affected"] = int(row["systems_affected"])
                entry["synopsis"] = row["cve_name"]
                entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else None
                entry["impact"] = impact_id_map[row["impact_id"]]
                entry["description"] = row["cve_description"]
                # Store everything we know about CVSS - maybe UI needs to decide what to show
                entry["cvss2_score"] = str(row["cvss2_score"]) if row["cvss2_score"] is not None else None
                entry["cvss3_score"] = str(row["cvss3_score"]) if row["cvss3_score"] is not None else None
                entry["business_risk"] = row["business_risk"]
                entry["business_risk_id"] = row["business_risk_id"]
                entry["business_risk_text"] = row["business_risk_text"]
                entry["status"] = row["status"]
                entry["status_id"] = row["status_id"]
                entry["status_text"] = row["status_text"]
                entry["systems_status_divergent"] = int(row["systems_status_divergent"])
                entry["rules"] = rules_map.get(row["cve_id"], [])
                entry["known_exploit"] = row["exploit_data"] is not None and bool(row["advisories_list"])
                entry["advisory_available"] = row["advisory_available"]
                res["type"] = "cve"
                res["id"] = row["cve_name"]
                res["attributes"] = entry
                result.append(res)
        return result


class GetCvesIds(GetCves):
    """GET to /v1/vulnerabilities/cves/ids"""

    _endpoint_name = r"/v1/vulnerabilities/cves/ids"
    _ids_only = True


class SimpleCvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, list_args, cve_list, uri):
        cve_list = [remove_str_nulls(elem) for elem in cve_list]
        query = (CveMetadata.select(CveMetadata.cve,
                                    fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).alias("cvss_score"),
                                    CveImpact.name.alias("impact"))
                 .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                 .where(CveMetadata.cve.in_(cve_list))
                 .dicts())

        sortable_columns = {
            "synopsis": CVE_SYNOPSIS_SORT,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
        }
        default_sort_columns = {
            "default": "synopsis"
        }

        super().__init__(query, sortable_columns, default_sort_columns, filterable_columns, {}, list_args, [], uri)


class PostCves(PostRequest):
    """POST to /v1/vulnerabilities/cves"""

    _endpoint_name = r"/v1/vulnerabilities/cves"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_post(cls, **kwargs):
        list_arguments = cls._parse_list_arguments(kwargs)
        cves_view = SimpleCvesListView(list_arguments, kwargs["data"]["cve_list"], connexion.request.path)
        data = []
        for row in cves_view:
            entry = {}
            res = {}
            entry["synopsis"] = row["cve"]
            entry["impact"] = row["impact"]
            entry["cvss_score"] = str(row["cvss_score"]) if row["cvss_score"] is not None else None
            res["type"] = "cve"
            res["id"] = row["cve"]
            res["attributes"] = entry
            data.append(res)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = data

        return res
