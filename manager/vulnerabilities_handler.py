"""
Module for /vulnerabilities API endpoint
"""

import dateutil.parser

import connexion
from peewee import Case, fn, JOIN, SQL

from common.peewee_model import BusinessRisk, CveAccountData, CveMetadata, CveImpact, RHAccount, Status, InsightsRule, CveRuleMapping
from .base import DEFAULT_BUSINESS_RISK, DEFAULT_STATUS, GetRequest, parse_int_list, CVE_SYNOPSIS_SORT, get_rules_for_cves, get_system_count, get_account_id, \
                  unique_bool_list
from .filters import apply_filters, filter_types
from .list_view import ListView


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, list_args, query_args, uri, args, ids_only=False):
        join_type = JOIN.INNER
        cve_count = CveAccountData.systems_affected
        if ('show_all' in args and args['show_all']) or (args['affecting'] is None or args['affecting'][1] or not args['affecting'][0]):
            join_type = JOIN.RIGHT_OUTER
            cve_count = fn.COALESCE(cve_count, 0)
        query = self._full_query(cve_count, join_type, query_args) if not ids_only else self._id_query(join_type, query_args)
        query = apply_filters(query, args, [filter_types.CVE_BUSINESS_RISK, filter_types.CVE_CVSS, filter_types.CVE_IMPACT, filter_types.CVE_PUBLIC_DATE,
                                            filter_types.CVE_RULE_PRESENCE, filter_types.CVE_SHOW_ALL, filter_types.CVE_STATUS,
                                            filter_types.CVE_RULE_PRESENCE_OLD, filter_types.CVE_AFFECTING])
        query = query.dicts()

        sortable_columns = {
            "systems_affected": SQL('systems_affected'),
            "id": CveMetadata.id,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "business_risk_id": SQL('business_risk_id'),
            "business_risk": SQL('business_risk_id'),
            "status_id": SQL('status_id'),
            "status": SQL('status_id'),
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description,
            "rule_description": InsightsRule.description_text
        }
        default_sort_columns = ['id']

        super(CvesListView, self).__init__(query, sortable_columns, default_sort_columns,
                                           filterable_columns, list_args, args, uri)

    @staticmethod
    def _full_query(cve_count, join_type, query_args):
        return (
            CveAccountData
            .select(cve_count.alias("systems_affected"),
                    CveMetadata.id.alias('cve_id'),
                    CveMetadata.cve.alias("cve_name"),
                    CveMetadata.cvss3_score,
                    CveMetadata.cvss2_score,
                    CveMetadata.impact_id,
                    CveMetadata.public_date,
                    CveMetadata.description.alias("cve_description"),
                    fn.COALESCE(CveAccountData.business_risk_id, 0).alias('business_risk_id'),
                    CveAccountData.business_risk_text.alias('business_risk_text'),
                    fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias('business_risk'),
                    fn.COALESCE(CveAccountData.status_id, 0).alias('status_id'),
                    CveAccountData.status_text.alias('status_text'),
                    fn.COALESCE(Status.name, DEFAULT_STATUS).alias('status'),
                    fn.COALESCE(CveAccountData.systems_status_divergent, 0).alias('systems_status_divergent'))
            .join(RHAccount, on=(CveAccountData.rh_account_id == RHAccount.id))
            .join(CveMetadata, join_type,
                  on=((CveAccountData.cve_id == CveMetadata.id)
                      & (RHAccount.name == query_args["rh_account_number"])))
            .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
            .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id))
            .join(CveRuleMapping, JOIN.LEFT_OUTER, on=(CveMetadata.id == CveRuleMapping.cve_id))
            .join(InsightsRule, JOIN.LEFT_OUTER, on=(CveRuleMapping.rule_id == InsightsRule.id))
        )

    @staticmethod
    def _id_query(join_type, query_args):
        return (
            CveAccountData
            .select(CveMetadata.cve.alias('cve_name'),)
            .join(RHAccount, on=(CveAccountData.rh_account_id == RHAccount.id))
            .join(CveMetadata, join_type,
                  on=((CveAccountData.cve_id == CveMetadata.id)
                      & (RHAccount.name == query_args["rh_account_number"])))
            .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
            .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id))
        )


def _prepare_impact_id_map():
    impact_id_map = {}
    for row in CveImpact.select().dicts():
        impact_id_map[row['id']] = row['name']
    return impact_id_map


class GetCves(GetRequest):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r'/v1/vulnerabilities/cves'
    _ids_only = False

    @classmethod
    def handle_get(cls, **kwargs):
        """Grabs all CVEs user is affected by"""
        args_desc = [{'arg_name': 'cvss_from', 'convert_func': None},
                     {'arg_name': 'cvss_to', 'convert_func': None},
                     {'arg_name': 'public_from', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'public_to', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'show_all', 'convert_func': None},
                     {'arg_name': 'impact', 'convert_func': parse_int_list},
                     {'arg_name': 'business_risk_id', 'convert_func': parse_int_list},
                     {'arg_name': 'status_id', 'convert_func': parse_int_list},
                     {'arg_name': 'rule_presence', 'convert_func': unique_bool_list},
                     {'arg_name': 'security_rule', 'convert_func': None},
                     {'arg_name': 'affecting', 'convert_func': None}]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        cves_view = CvesListView(list_arguments, {"rh_account_number": connexion.context['user']},
                                 connexion.request.path, args, cls._ids_only)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = cls._format_data(list_arguments["data_format"], cls.assign_cves(cves_view))

        rh_account_id = get_account_id(connexion.context['user'])
        res["meta"]["system_count"] = get_system_count(rh_account_id)
        return res

    @classmethod
    def assign_cves(cls, cves_view):
        """Provides CVE details"""
        result = []
        if cls._ids_only:
            for row in cves_view:
                result.append(row['cve_name'])
        else:
            impact_id_map = _prepare_impact_id_map()
            rules_map = get_rules_for_cves([row['cve_id'] for row in cves_view])
            for row in cves_view:
                entry = dict()
                res = {}
                entry["systems_affected"] = row["systems_affected"]
                entry["synopsis"] = row["cve_name"]
                entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else None
                entry["impact"] = impact_id_map[row["impact_id"]]
                entry["description"] = row["cve_description"]
                # Store everything we know about CVSS - maybe UI needs to decide what to show
                entry["cvss2_score"] = str(row["cvss2_score"]) if row['cvss2_score'] is not None else None
                entry["cvss3_score"] = str(row["cvss3_score"]) if row['cvss3_score'] is not None else None
                entry['business_risk'] = row['business_risk']
                entry['business_risk_id'] = row['business_risk_id']
                entry['business_risk_text'] = row['business_risk_text']
                entry['status'] = row['status']
                entry['status_id'] = row['status_id']
                entry['status_text'] = row['status_text']
                entry['systems_status_divergent'] = row['systems_status_divergent']
                entry['rules'] = rules_map.get(row['cve_id'], [])
                res["type"] = "cve"
                res["id"] = row["cve_name"]
                res["attributes"] = entry
                result.append(res)
        return result


class GetCvesIds(GetCves):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r'/v1/vulnerabilities/cves/ids'
    _ids_only = True
