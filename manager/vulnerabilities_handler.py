"""
Module for /vulnerabilities API endpoint
"""

import json
from distutils.util import strtobool # pylint: disable=import-error, no-name-in-module
import dateutil.parser

from peewee import fn, JOIN

from common import AuthenticatedHandler, ConnectionFinished, InvalidArgumentException, none2empty, parse_url
from database.peewee_model import SystemVulnerabilities, VulnerabilitySource, SystemPlatform, CveMetadata, \
    ProdsecErrorKey, SystemProdsecErrorKey, CveImpact
from list_view import ListView


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""
    def __init__(self, list_args, query_args, args={}): # pylint: disable=dangerous-default-value
        join_type = JOIN.INNER
        if 'show_all' in args and args['show_all']:
            join_type = JOIN.RIGHT_OUTER
        query = (
            SystemVulnerabilities
            .select(fn.Count(SystemVulnerabilities.cve).alias("system_count"),
                    CveMetadata.cve.alias("cve_name"),
                    fn.Min(VulnerabilitySource.name).alias("source_name"),
                    CveMetadata.cvss3_score,
                    CveMetadata.cvss2_score,
                    CveMetadata.impact_id,
                    CveMetadata.public_date,
                    CveMetadata.description.alias("cve_description"))
            .join(SystemPlatform, on=((SystemVulnerabilities.insights_id == SystemPlatform.insights_id)
                                      & (SystemPlatform.rh_account == query_args["rh_account_number"])))
            .join(VulnerabilitySource, on=(SystemVulnerabilities.vulnerability_source == VulnerabilitySource.id))
            .join(CveMetadata, join_type, on=(SystemVulnerabilities.cve == CveMetadata.cve))
            .group_by(CveMetadata.cve, CveMetadata.cvss3_score, CveMetadata.cvss2_score, CveMetadata.impact_id,
                      CveMetadata.public_date, CveMetadata.description)
        )
        if 'cvss_from' in args and args['cvss_from']:
            query = query.where(CveMetadata.cvss3_score >= args['cvss_from'])
        if 'cvss_to' in args and args['cvss_to']:
            query = query.where(CveMetadata.cvss3_score <= args['cvss_to'])
        if 'public_from' in args and args['public_from']:
            query = query.where(CveMetadata.public_date >= args['public_from'])
        if 'public_to' in args and args['public_to']:
            query = query.where(CveMetadata.public_date <= args['public_to'])
        query = query.dicts()
        sortable_columns = {
            "systems_affected": fn.Count(SystemVulnerabilities.cve),
            "synopsis": CveMetadata.cve,
            "celebrity": VulnerabilitySource.name,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": CveMetadata.cvss3_score if CveMetadata.cvss3_score else CveMetadata.cvss2_score,
            "impact": CveMetadata.impact_id
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description
        }
        super(CvesListView, self).__init__(query, sortable_columns, filterable_columns, list_args)


class ErrorKeysListView(ListView):
    """Database select for error_keys"""
    def __init__(self, list_args, query_args):
        query = (
            SystemProdsecErrorKey
            .select(fn.Count(SystemProdsecErrorKey.insights_id).alias("system_count"),
                    ProdsecErrorKey.name)
            .join(SystemPlatform, on=(SystemProdsecErrorKey.insights_id == SystemPlatform.insights_id))
            .join(ProdsecErrorKey, on=(SystemProdsecErrorKey.error_key_id == ProdsecErrorKey.id))
            .where(SystemPlatform.rh_account == query_args["rh_account_number"])
            .group_by(ProdsecErrorKey.name)
            .dicts()
        )
        sortable_columns = {
            "systems_affected": fn.Count(SystemProdsecErrorKey.insights_id),
            "id": ProdsecErrorKey.name,
        }
        filterable_columns = {
            "id": ProdsecErrorKey.name
        }
        super(ErrorKeysListView, self).__init__(query, sortable_columns, filterable_columns, list_args)


class VulnerabilitiesHandler(AuthenticatedHandler):
    """Handler class returning data related to vulnerabilities."""

    def __init__(self, application, request, **kwargs):
        self.arguments = None
        super(VulnerabilitiesHandler, self).__init__(application, request, **kwargs)

    def prepare(self):
        super(VulnerabilitiesHandler, self).prepare()
        self.arguments = dict()
        for key in self.request.arguments.keys():
            self.arguments[key] = self.get_argument(key, None)

    def get(self): # pylint: disable=arguments-differ
        """
        ---
        description: Get Vulnerabilities
        responses:
          200:
            description: Handler class returning data related to vulnerabilities.
        """
        route = parse_url(self.request.uri, "/vulnerabilities")
        if len(route) == 1:
            if route[0] == "impacts":
                self.get_impacts()
            elif route[0] == "changes":
                self.get_changes()
            elif route[0] == "cves":
                self.get_cves()
            elif route[0] == "error_keys":
                self.get_error_keys()
        else:
            self.raiseError(404)
        self.flush()

    def post(self): # pylint: disable=arguments-differ
        self.flush()

    def _prepare_impact_id_map(self): # pylint: disable=no-self-use
        impact_id_map = {}
        for row in CveImpact.select().dicts():
            impact_id_map[row['id']] = row['name']
        return impact_id_map

    # TODO: Needs to be tested, reduced and add error handling
    def get_impacts(self):
        """Counts CVE impacts thought user's systems"""
        try:
            cves_view = CvesListView(self._parse_list_arguments(), {"rh_account_number": self.rh_account_number})
        except InvalidArgumentException as exc:
            self.raiseError(400, str(exc))
            return
        cves = self.assign_cves(cves_view)
        important = moderate = critical = low = 0
        for cve in cves:
            impact = cve["attributes"]["impact"]
            if impact in ["Important", "High"]:
                important = important + 1
            if impact in ["Moderate", "Medium"]:
                moderate = moderate + 1
            if impact in ["Critical"]:
                critical = critical + 1
            if impact in ["Low"]:
                low = low + 1
        result = dict()
        result["Important"] = important
        result["Moderate"] = moderate
        result["Critical"] = critical
        result["Low"] = low
        self.write(json.dumps(result))

    # TODO: This is just a skeleton
    def get_changes(self):
        """Gets CVE hisotrical changes"""
        result = dict()
        new_vulnerabilities = {"count": 5, "percentage": 9, "direction": "up"}
        remediated = {"count": 21, "percentage": 50, "direction": "down"}
        newly_affected = {"count": 2, "percentage": 3, "direction": "up"}
        result["since"] = self.arguments.get("since", None)
        result["new_vulnerabilities"] = new_vulnerabilities
        result["remediated"] = remediated
        result["newly_affected"] = newly_affected
        self.write(json.dumps(result))

    # TODO: Needs to be tested, reduced and add error handling
    def get_cves(self):
        """Grabs all CVEs user is affected by"""
        args_desc = [{'arg_name' : 'cvss_from', 'convert_func' : float},
                     {'arg_name' : 'cvss_to', 'convert_func' : float},
                     {'arg_name' : 'public_from', 'convert_func' : dateutil.parser.parse},
                     {'arg_name' : 'public_to', 'convert_func' : dateutil.parser.parse},
                     {'arg_name' : 'show_all', 'convert_func' : strtobool}]
        try:
            args = self._parse_arguments(args_desc)
            list_arguments = self._parse_list_arguments()
            cves_view = CvesListView(list_arguments, {"rh_account_number": self.rh_account_number}, args)
        except ConnectionFinished:
            return
        except InvalidArgumentException as exc:
            self.raiseError(400, str(exc))
            return
        res = {}
        try:
            res["meta"] = cves_view.get_metadata()
            res["meta"]["show_all"] = 'true' if args['show_all'] else 'false'
            res["meta"]["cvss_from"] = none2empty(args['cvss_from'])
            res["meta"]["cvss_to"] = none2empty(args['cvss_to'])
            res["meta"]["public_from"] = args['public_from'].isoformat() if args['public_from'] else ''
            res["meta"]["public_to"] = args['public_to'].isoformat() if args['public_to'] else ''
            res["data"] = self._format_data(list_arguments["data_format"], self.assign_cves(cves_view))
        except Exception as exc: # pylint: disable=broad-except
            self.raiseError(500, str(exc))
            return
        self.write(json.dumps(res))

    # TODO: Needs to be tested, reduced and add error handling
    def assign_cves(self, cves_view): # pylint: disable=no-self-use
        """Provides CVE details"""
        result = []
        impact_id_map = self._prepare_impact_id_map()
        for row in cves_view:
            entry = dict()
            res = {}
            entry["systems_affected"] = row["system_count"]
            entry["celebrity"] = row["source_name"] == "RULES"
            entry["synopsis"] = row["cve_name"]
            entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else ''
            entry["impact"] = impact_id_map[row["impact_id"]]
            entry["description"] = row["cve_description"]
            # Store everything we know about CVSS - maybe UI needs to decide what to show
            entry["cvss2_score"] = str(row["cvss2_score"]) if row['cvss2_score'] is not None else ''
            entry["cvss3_score"] = str(row["cvss3_score"]) if row['cvss3_score'] is not None else ''
            res["type"] = "cve"
            res["id"] = row["cve_name"]
            res["attributes"] = entry
            result.append(res)
        return result

    # TODO: Needs to be tested, reduced and add error handling
    def get_error_keys(self):
        """Grabs available error keys"""
        try:
            list_arguments = self._parse_list_arguments()
            error_keys_view = ErrorKeysListView(list_arguments, {"rh_account_number": self.rh_account_number})
        except InvalidArgumentException as exc:
            self.raiseError(400, str(exc))
            return
        res = {}
        try:
            res["meta"] = error_keys_view.get_metadata()
            res["data"] = self._format_data(list_arguments["data_format"], self.assign_error_keys(error_keys_view))
        except Exception as exc: # pylint: disable=broad-except
            self.set_status(666)
            res["errors"] = str(exc)
            self.finish(res)
            return
        self.write(json.dumps(res))

    # TODO: Needs to be tested, reduced and add error handling
    def assign_error_keys(self, error_keys_view): #pylint: disable=no-self-use
        """Assigns error keys"""
        result = []
        for row in error_keys_view:
            res = {}
            res["type"] = "error_key"
            res["id"] = row["name"]
            res["attributes"] = {"systems_affected": row["system_count"]}
            result.append(res)
        return result
