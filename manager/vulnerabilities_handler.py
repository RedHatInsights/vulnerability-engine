"""
Module for /vulnerabilities API endpoint
"""

import dateutil.parser

import connexion
from peewee import Case, fn, JOIN, SQL

from common.constants import HostType
from common.peewee_model import BusinessRisk, CveAccountData, CveMetadata, CveImpact, Status, InsightsRule, CveRuleMapping, SystemVulnerabilities, \
    SystemPlatform, CveAccountCache
from .base import DEFAULT_BUSINESS_RISK, DEFAULT_STATUS, GetRequest, parse_int_list, CVE_SYNOPSIS_SORT, get_rules_for_cves, get_system_count, \
    get_account_data, parse_str_list, remove_str_nulls, unique_bool_list, cyndi_join, parse_tags, PostRequest, is_cyndi_request, DISABLE_ACCOUNT_CACHE, \
    update_cve_cache_keepalive
from .filters import apply_filters, filter_types
from .list_view import ListView
from .rbac_manager import RbacRoutePermissions, RbacFilterRoutePermissions, RbacManager as RBAC


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, rh_account_id, cve_cache_from, cve_cache_keepalive, list_args, uri, args):
        join_type = JOIN.INNER
        if args['affecting'] is None or False in args['affecting'] or True not in args['affecting']:
            join_type = JOIN.LEFT_OUTER

        # API using cache, set keepalive for account to enable maintaining cache
        update_cve_cache_keepalive(rh_account_id, cve_cache_keepalive)

        # Use cache if not disabled + systems are not filtered + cache exists
        if not DISABLE_ACCOUNT_CACHE and not is_cyndi_request(args) and cve_cache_from:
            count_subquery = self._cached_count_subquery(rh_account_id)
        else:
            count_subquery = self._count_subquery(rh_account_id)
            count_subquery = cyndi_join(count_subquery)
            if is_cyndi_request(args):
                count_subquery = apply_filters(count_subquery, args, [filter_types.SYSTEM_TAGS, filter_types.SYSTEM_SAP, filter_types.SYSTEM_SAP_SIDS,
                                                                      filter_types.SYSTEM_RHEL_VERSION, filter_types.SYSTEM_AAP, filter_types.SYSTEM_MSSQL,
                                                                      ], {})

        query = self._full_query(rh_account_id, join_type, count_subquery)
        query = apply_filters(query, args, [filter_types.CVE_BUSINESS_RISK, filter_types.CVE_CVSS, filter_types.CVE_IMPACT,
                                            filter_types.CVE_PUBLIC_DATE, filter_types.CVE_RULE_PRESENCE, filter_types.CVE_STATUS,
                                            filter_types.CVE_AFFECTING, filter_types.CVE_KNOWN_EXPLOITS],
                              {"count_subquery": count_subquery})
        query = query.dicts()

        sortable_columns = {
            "systems_affected": SQL('systems_affected'),
            "id": CveMetadata.id,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "business_risk_id": SQL('business_risk_id'),
            "business_risk": SQL('business_risk_id'),
            "status_id": SQL('status_id'),
            "status": SQL('status_id'),
        }
        default_sort_columns = {
            'default': 'id',
            'cvss_score': 'public_date',
            'cvss2_score': 'public_date',
            'cvss3_score': 'public_date',
            'public_date': 'synopsis',
            'impact': 'public_date',
            'systems_affected': 'public_date',
            'business_risk': 'public_date',
            'status': 'public_date',
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description,
        }

        if list_args["filter"]:
            filter_expressions = {
                "rule_description": fn.Exists(CveRuleMapping
                                              .select(CveRuleMapping.cve_id)
                                              .join(InsightsRule, on=(CveRuleMapping.rule_id == InsightsRule.id))
                                              .where(CveRuleMapping.cve_id == CveMetadata.id)
                                              .where(InsightsRule.description_text.contains(list_args["filter"])))
            }
        else:
            filter_expressions = {}

        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, args, uri)

    @staticmethod
    def _full_query(rh_account_id, join_type, count_subquery):
        return (CveMetadata
                .select(CveMetadata.id.alias("cve_id"),
                        CveMetadata.cve.alias("cve_name"),
                        CveMetadata.cvss3_score,
                        CveMetadata.cvss2_score,
                        CveMetadata.impact_id,
                        CveMetadata.public_date,
                        CveMetadata.description.alias("cve_description"),
                        CveMetadata.exploits,
                        fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                        CveAccountData.business_risk_text.alias("business_risk_text"),
                        fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                        fn.COALESCE(CveAccountData.status_id, 0).alias("status_id"),
                        CveAccountData.status_text.alias("status_text"),
                        fn.COALESCE(Status.name, DEFAULT_STATUS).alias("status"),
                        fn.COALESCE(count_subquery.c.systems_affected_, 0).alias("systems_affected"),
                        fn.COALESCE(count_subquery.c.systems_status_divergent_, 0).alias("systems_status_divergent"))
                .join(count_subquery, join_type, on=(CveMetadata.id == count_subquery.c.cve_id_))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveMetadata.id == CveAccountData.cve_id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id)))

    @staticmethod
    def _count_subquery(rh_account_id):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(SystemVulnerabilities.cve_id.alias("cve_id_"),
                        fn.Count(SystemVulnerabilities.id).alias("systems_affected_"),
                        fn.Sum(Case(None, ((SystemVulnerabilities.status_id != CveAccountData.status_id, 1),), 0)).alias("systems_status_divergent_"))
                .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                          (SystemPlatform.rh_account_id == rh_account_id) &
                                          (SystemPlatform.opt_out == False) &  # noqa: E712
                                          (SystemPlatform.stale == False) &  # noqa: E712
                                          (SystemPlatform.when_deleted.is_null(True)) &
                                          (fn.COALESCE(SystemPlatform.host_type, 'null') != HostType.EDGE)))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((SystemVulnerabilities.cve_id == CveAccountData.cve_id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where((SystemVulnerabilities.mitigation_reason.is_null(True)) |
                       (SystemVulnerabilities.rule_id << InsightsRule.select(InsightsRule.id).where(
                           (InsightsRule.active == False) & (~InsightsRule.rule_only))))
                .where((SystemVulnerabilities.when_mitigated.is_null(True)) |
                       (SystemVulnerabilities.rule_id << InsightsRule.select(InsightsRule.id).where((InsightsRule.active == True) & (~InsightsRule.rule_only))))
                .group_by(SystemVulnerabilities.cve_id))

    @staticmethod
    def _cached_count_subquery(rh_account_id):
        return (CveAccountCache
                .select(CveAccountCache.cve_id.alias("cve_id_"),
                        CveAccountCache.systems_affected.alias("systems_affected_"),
                        CveAccountCache.systems_status_divergent.alias("systems_status_divergent_"))
                .where(CveAccountCache.rh_account_id == rh_account_id))


def _prepare_impact_id_map():
    impact_id_map = {}
    for row in CveImpact.select().dicts():
        impact_id_map[row['id']] = row['name']
    return impact_id_map


class GetCves(GetRequest):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r'/v1/vulnerabilities/cves'
    _ids_only = False

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.VULNERABILITIES_CVES_ENDPOINT)
    def handle_get(cls, **kwargs):
        """Grabs all CVEs user is affected by"""
        args_desc = [{'arg_name': 'cvss_from', 'convert_func': None},
                     {'arg_name': 'cvss_to', 'convert_func': None},
                     {'arg_name': 'public_from', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'public_to', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'impact', 'convert_func': parse_int_list},
                     {'arg_name': 'business_risk_id', 'convert_func': parse_int_list},
                     {'arg_name': 'status_id', 'convert_func': parse_int_list},
                     {'arg_name': 'rule_presence', 'convert_func': unique_bool_list},
                     {'arg_name': 'affecting', 'convert_func': None},
                     {'arg_name': 'tags', 'convert_func': parse_tags},
                     {'arg_name': 'sap_system', 'convert_func': None},
                     {'arg_name': 'sap_sids', 'convert_func': None},
                     {'arg_name': 'known_exploit', 'convert_func': unique_bool_list},
                     {'arg_name': 'rhel_version', 'convert_func': parse_str_list}, ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        rh_account_id, cve_cache_from, cve_cache_keepalive = get_account_data(connexion.context['user'])
        cves_view = CvesListView(rh_account_id, cve_cache_from, cve_cache_keepalive, list_arguments, connexion.request.path, args)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = cls._format_data(list_arguments["data_format"], cls.assign_cves(cves_view), ids_only=cls._ids_only)

        res["meta"]["system_count"] = get_system_count(rh_account_id)
        return res

    @classmethod
    def assign_cves(cls, cves_view):
        """Provides CVE details"""
        result = []
        if cls._ids_only:
            for row in cves_view:
                result.append({
                    'business_risk_id': row['business_risk_id'],
                    'business_risk_text': row['business_risk_text'],
                    'id': row['cve_name'],
                    'status_id': row['status_id'],
                    'status_text': row['status_text'],
                })
        else:
            impact_id_map = _prepare_impact_id_map()
            cves_materialized = list(cves_view)  # execute query
            rules_map = get_rules_for_cves([row['cve_id'] for row in cves_materialized])
            for row in cves_materialized:
                entry = dict()
                res = {}
                entry["systems_affected"] = row["systems_affected"]
                entry["synopsis"] = row["cve_name"]
                entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else None
                entry["impact"] = impact_id_map[row["impact_id"]]
                entry["description"] = row["cve_description"]
                # Store everything we know about CVSS - maybe UI needs to decide what to show
                entry["cvss2_score"] = str(row["cvss2_score"]) if row['cvss2_score'] is not None else None
                entry["cvss3_score"] = str(row["cvss3_score"]) if row['cvss3_score'] is not None else None
                entry['business_risk'] = row['business_risk']
                entry['business_risk_id'] = row['business_risk_id']
                entry['business_risk_text'] = row['business_risk_text']
                entry['status'] = row['status']
                entry['status_id'] = row['status_id']
                entry['status_text'] = row['status_text']
                entry['systems_status_divergent'] = row['systems_status_divergent']
                entry['rules'] = rules_map.get(row['cve_id'], [])
                entry['known_exploit'] = bool(row['exploits'])
                res["type"] = "cve"
                res["id"] = row["cve_name"]
                res["attributes"] = entry
                result.append(res)
        return result


class GetCvesIds(GetCves):
    """GET to /v1/vulnerabilities/cves/ids"""

    _endpoint_name = r'/v1/vulnerabilities/cves/ids'
    _ids_only = True


class SimpleCvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, list_args, cve_list, uri):
        cve_list = [remove_str_nulls(elem) for elem in cve_list]
        query = (CveMetadata.select(CveMetadata.cve,
                                    fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).alias('cvss_score'),
                                    CveImpact.name.alias('impact'))
                 .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                 .where(CveMetadata.cve.in_(cve_list))
                 .dicts())

        sortable_columns = {
            'synopsis': CVE_SYNOPSIS_SORT,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            'cvss_score': Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            'impact_id': CveMetadata.impact_id,
            'impact': CveMetadata.impact_id,
        }
        filterable_columns = {
            'synopsis': CveMetadata.cve,
        }
        default_sort_columns = {
            'default': 'synopsis'
        }

        super().__init__(query, sortable_columns, default_sort_columns, filterable_columns, {}, list_args, [], uri)


class PostCves(PostRequest):
    """POST to /v1/vulnerabilities/cves"""

    _endpoint_name = r'/v1/vulnerabilities/cves'

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_post(cls, **kwargs):
        list_arguments = cls._parse_list_arguments(kwargs)
        cves_view = SimpleCvesListView(list_arguments, kwargs['data']['cve_list'], connexion.request.path)
        data = []
        for row in cves_view:
            entry = {}
            res = {}
            entry['synopsis'] = row['cve']
            entry['impact'] = row['impact']
            entry['cvss_score'] = str(row['cvss_score']) if row['cvss_score'] is not None else None
            res['type'] = 'cve'
            res['id'] = row['cve']
            res['attributes'] = entry
            data.append(res)
        res = {}
        res['meta'] = cves_view.get_metadata()
        res['links'] = cves_view.get_pagination_links()
        res['data'] = data

        return res
