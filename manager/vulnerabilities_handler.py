"""
Module for /vulnerabilities API endpoint
"""

import dateutil.parser

import connexion
from peewee import Case, fn, JOIN, SQL

from common.peewee_model import BusinessRisk, CveAccountData, CveMetadata, CveImpact, Status, InsightsRule, CveRuleMapping, SystemVulnerabilities, \
    SystemPlatform
from .base import DEFAULT_BUSINESS_RISK, DEFAULT_STATUS, GetRequest, parse_int_list, CVE_SYNOPSIS_SORT, get_rules_for_cves, get_system_count, get_account_id, \
                  unique_bool_list, cyndi_query, parse_tags, PostRequest, is_cyndi_request
from .filters import apply_filters, filter_types
from .list_view import ListView


class CvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, rh_account_id, list_args, query_args, uri, args):
        join_type = JOIN.INNER
        if args['affecting'] is None or args['affecting'][1] or not args['affecting'][0]:
            join_type = JOIN.LEFT_OUTER
        count_subquery = self._count_subquery(rh_account_id)
        if is_cyndi_request(args):
            count_subquery = cyndi_query(count_subquery)
            count_subquery = apply_filters(count_subquery, args, [filter_types.SYSTEM_TAGS, filter_types.SYSTEM_SAP, filter_types.SYSTEM_SAP_SIDS], {})

        query = self._full_query(rh_account_id, join_type, count_subquery)
        query = apply_filters(query, args, [filter_types.CVE_BUSINESS_RISK, filter_types.CVE_CVSS, filter_types.CVE_IMPACT,
                                            filter_types.CVE_PUBLIC_DATE, filter_types.CVE_RULE_PRESENCE, filter_types.CVE_STATUS,
                                            filter_types.CVE_AFFECTING],
                              {"count_subquery": count_subquery})
        query = query.dicts()

        sortable_columns = {
            "systems_affected": SQL('systems_affected'),
            "id": CveMetadata.id,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "business_risk_id": SQL('business_risk_id'),
            "business_risk": SQL('business_risk_id'),
            "status_id": SQL('status_id'),
            "status": SQL('status_id'),
        }
        filterable_columns = {
            "synopsis": CveMetadata.cve,
            "description": CveMetadata.description,
        }
        filter_expressions = {
            "rule_description": fn.Exists(CveRuleMapping
                                          .select(CveRuleMapping.cve_id)
                                          .join(InsightsRule, on=(CveRuleMapping.rule_id == InsightsRule.id))
                                          .where(CveRuleMapping.cve_id == CveMetadata.id)
                                          .where(InsightsRule.description_text.contains(list_args["filter"])))
        }
        default_sort_columns = ['id']

        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, args, uri)

    @staticmethod
    def _full_query(rh_account_id, join_type, count_subquery):
        return (
            CveMetadata
            .select(CveMetadata.id.alias("cve_id"),
                    CveMetadata.cve.alias("cve_name"),
                    CveMetadata.cvss3_score,
                    CveMetadata.cvss2_score,
                    CveMetadata.impact_id,
                    CveMetadata.public_date,
                    CveMetadata.description.alias("cve_description"),
                    fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                    CveAccountData.business_risk_text.alias("business_risk_text"),
                    fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                    fn.COALESCE(CveAccountData.status_id, 0).alias("status_id"),
                    CveAccountData.status_text.alias("status_text"),
                    fn.COALESCE(Status.name, DEFAULT_STATUS).alias("status"),
                    fn.COALESCE(count_subquery.c.systems_affected_, 0).alias("systems_affected"),
                    fn.COALESCE(count_subquery.c.systems_status_divergent_, 0).alias("systems_status_divergent"))
            .join(count_subquery, join_type, on=(CveMetadata.id == count_subquery.c.cve_id_))
            .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveMetadata.id == CveAccountData.cve_id)
                                                       & (CveAccountData.rh_account_id == rh_account_id)))
            .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
            .join(Status, JOIN.LEFT_OUTER, on=(CveAccountData.status_id == Status.id))
        )

    @staticmethod
    def _count_subquery(rh_account_id):
        return (
            # pylint: disable=singleton-comparison
            SystemVulnerabilities
            .select(SystemVulnerabilities.cve_id.alias("cve_id_"),
                    fn.Count(SystemVulnerabilities.id).alias("systems_affected_"),
                    fn.Sum(Case(None, ((SystemVulnerabilities.status_id != CveAccountData.status_id, 1),), 0)).alias("systems_status_divergent_"))
            .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
            .join(InsightsRule, JOIN.LEFT_OUTER, on=(SystemVulnerabilities.rule_id == InsightsRule.id))
            .join(CveAccountData, JOIN.LEFT_OUTER, on=((SystemVulnerabilities.cve_id == CveAccountData.cve_id)
                                                       & (SystemVulnerabilities.rh_account_id == CveAccountData.rh_account_id)))
            .where(SystemVulnerabilities.rh_account_id == rh_account_id)
            .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False))
            .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True))
            .where((SystemPlatform.opt_out == False)  # noqa: E712
                   & (SystemPlatform.stale == False)  # noqa: E712
                   & (SystemPlatform.when_deleted.is_null(True)))
            .group_by(SystemVulnerabilities.cve_id)
        )


def _prepare_impact_id_map():
    impact_id_map = {}
    for row in CveImpact.select().dicts():
        impact_id_map[row['id']] = row['name']
    return impact_id_map


class GetCves(GetRequest):
    """GET to /v1/vulnerabilities/cves"""

    _endpoint_name = r'/v1/vulnerabilities/cves'
    _ids_only = False

    @classmethod
    def handle_get(cls, **kwargs):
        """Grabs all CVEs user is affected by"""
        args_desc = [{'arg_name': 'cvss_from', 'convert_func': None},
                     {'arg_name': 'cvss_to', 'convert_func': None},
                     {'arg_name': 'public_from', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'public_to', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'impact', 'convert_func': parse_int_list},
                     {'arg_name': 'business_risk_id', 'convert_func': parse_int_list},
                     {'arg_name': 'status_id', 'convert_func': parse_int_list},
                     {'arg_name': 'rule_presence', 'convert_func': unique_bool_list},
                     {'arg_name': 'affecting', 'convert_func': None},
                     {'arg_name': 'tags', 'convert_func': parse_tags},
                     {'arg_name': 'sap_system', 'convert_func': None},
                     {'arg_name': 'sap_sids', 'convert_func': None}]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        rh_account_id = get_account_id(connexion.context['user'])
        cves_view = CvesListView(rh_account_id, list_arguments, {"rh_account_number": connexion.context['user']},
                                 connexion.request.path, args)
        res = {}
        res["meta"] = cves_view.get_metadata()
        res["links"] = cves_view.get_pagination_links()
        res["data"] = cls._format_data(list_arguments["data_format"], cls.assign_cves(cves_view))

        res["meta"]["system_count"] = get_system_count(rh_account_id)
        return res

    @classmethod
    def assign_cves(cls, cves_view):
        """Provides CVE details"""
        result = []
        if cls._ids_only:
            for row in cves_view:
                result.append(row['cve_name'])
        else:
            impact_id_map = _prepare_impact_id_map()
            cves_materialized = list(cves_view)  # execute query
            rules_map = get_rules_for_cves([row['cve_id'] for row in cves_materialized])
            for row in cves_materialized:
                entry = dict()
                res = {}
                entry["systems_affected"] = row["systems_affected"]
                entry["synopsis"] = row["cve_name"]
                entry["public_date"] = row["public_date"].isoformat() if row["public_date"] else None
                entry["impact"] = impact_id_map[row["impact_id"]]
                entry["description"] = row["cve_description"]
                # Store everything we know about CVSS - maybe UI needs to decide what to show
                entry["cvss2_score"] = str(row["cvss2_score"]) if row['cvss2_score'] is not None else None
                entry["cvss3_score"] = str(row["cvss3_score"]) if row['cvss3_score'] is not None else None
                entry['business_risk'] = row['business_risk']
                entry['business_risk_id'] = row['business_risk_id']
                entry['business_risk_text'] = row['business_risk_text']
                entry['status'] = row['status']
                entry['status_id'] = row['status_id']
                entry['status_text'] = row['status_text']
                entry['systems_status_divergent'] = row['systems_status_divergent']
                entry['rules'] = rules_map.get(row['cve_id'], [])
                res["type"] = "cve"
                res["id"] = row["cve_name"]
                res["attributes"] = entry
                result.append(res)
        return result


class GetCvesIds(GetCves):
    """GET to /v1/vulnerabilities/cves/ids"""

    _endpoint_name = r'/v1/vulnerabilities/cves/ids'
    _ids_only = True


class SimpleCvesListView(ListView):
    """Database select for CVEs affecting user systems"""

    def __init__(self, list_args, cve_list, uri):
        query = (CveMetadata.select(CveMetadata.cve,
                                    fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).alias('cvss_score'),
                                    CveImpact.name.alias('impact'))
                 .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                 .where(CveMetadata.cve.in_(cve_list))
                 .dicts())

        sortable_columns = {
            'synopsis': CVE_SYNOPSIS_SORT,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            'cvss_score': Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            'impact_id': CveMetadata.impact_id,
            'impact': CveMetadata.impact_id,
        }
        filterable_columns = {
            'synopsis': CveMetadata.cve,
        }
        default_sort_columns = ['synopsis']

        super().__init__(query, sortable_columns, default_sort_columns, filterable_columns, {}, list_args, [], uri)


class PostCves(PostRequest):
    """POST to /v1/vulnerabilities/cves"""

    _endpoint_name = r'/v1/vulnerabilities/cves'

    @classmethod
    def handle_post(cls, **kwargs):
        list_arguments = cls._parse_list_arguments(kwargs)
        cves_view = SimpleCvesListView(list_arguments, kwargs['data']['cve_list'], connexion.request.path)
        data = []
        for row in cves_view:
            entry = {}
            res = {}
            entry['synopsis'] = row['cve']
            entry['impact'] = row['impact']
            entry['cvss_score'] = str(row['cvss_score']) if row['cvss_score'] is not None else None
            res['type'] = 'cve'
            res['id'] = row['cve']
            res['attributes'] = entry
            data.append(res)
        res = {}
        res['meta'] = cves_view.get_metadata()
        res['links'] = cves_view.get_pagination_links()
        res['data'] = data

        return res
