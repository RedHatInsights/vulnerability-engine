"""
Module for /systems API endpoint
"""

import connexion
import dateutil.parser
from peewee import JOIN, SQL, Case, DoesNotExist, fn

from common.constants import remediation
from common.logging import get_logger
from common.peewee_model import (BusinessRisk, CveAccountData, CveImpact,
                                 CveMetadata, InsightsRule, InventoryHosts,
                                 Status, SystemPlatform, SystemVulnerabilities)
from common.peewee_conditions import (system_is_active, system_is_vulnerable)

from .base import (CVE_SYNOPSIS_SORT, DEFAULT_BUSINESS_RISK, OS_INFO_QUERY,
                   OS_INFO_SORT, ApplicationException, GetRequest,
                   PatchRequest, cyndi_join, get_account_data, parse_int_list,
                   parse_str_list, parse_str_or_list, parse_tags, reporter, unique_bool_list)
from .filters import apply_filters, filter_types
from .list_view import ListView
from .rbac_filters import filter_excluded
from .rbac_manager import RbacFilterRoutePermissions
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions

LOGGER = get_logger(__name__)


class SystemCvesView(ListView):
    """Database select for /systems endpoint"""

    def __init__(self, rh_account_id, list_args, query_args, parsed_args, uri, ids_only=False):
        query = self._full_query(rh_account_id, query_args) if not ids_only else self._id_query(rh_account_id, query_args)
        query = cyndi_join(query)
        filters = [filter_types.CVE_BUSINESS_RISK,
                   filter_types.CVE_CVSS,
                   filter_types.CVE_IMPACT,
                   filter_types.CVE_PUBLIC_DATE,
                   filter_types.SYSTEM_CVE_STATUS,
                   filter_types.SYSTEM_CVE_RULE_PRESENCE,
                   filter_types.SYSTEM_CVE_RULE,
                   filter_types.CVE_KNOWN_EXPLOITS,
                   filter_types.SYSTEM_VULNERABILITES_BY_ADVISORY,
                   filter_types.SYSTEM_CVE_FIRST_REPORTED,
                   filter_types.SYSTEM_CVE_ADVISORY_AVAILABLE,
                   filter_types.SYSTEM_CVE_REMEDIATION,
                   ]

        query = apply_filters(query, parsed_args, filters, {})

        query = query.dicts()

        sortable_columns = {
            "id": CveMetadata.id,
            "cve": CVE_SYNOPSIS_SORT,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            "impact_id": CveMetadata.impact_id,
            "impact": CveMetadata.impact_id,
            "status_id": Status.id,
            "status": Status.id,
            "business_risk_id": SQL("business_risk_id"),
            "business_risk": SQL("business_risk_id"),
            "first_reported": SystemVulnerabilities.first_reported,
            "advisory_available": SQL("advisory_available"),
            "remediation": SQL("remediation_type_id"),
            "advisories_list": SystemVulnerabilities.advisories,
        }
        default_sort_columns = {
            "default": "id",
            "cvss_score": "public_date",
            "cvss2_score": "public_date",
            "cvss3_score": "public_date",
            "public_date": "synopsis",
            "impact": "public_date",
            "business_risk": "public_date",
            "status": "public_date",
        }
        filterable_columns = {
            "cve": CveMetadata.cve,
            "description": CveMetadata.description,
            "status": Status.name,
            "rule_description": InsightsRule.description_text
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id, query_args):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(CveMetadata.cve.alias("cve_name"),
                        CveMetadata.cvss3_score,
                        CveMetadata.cvss2_score,
                        CveImpact.name.alias("impact"),
                        CveMetadata.public_date,
                        CveMetadata.description.alias("cve_description"),
                        CveMetadata.exploit_data,
                        fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                        Status.id.alias("status_id"),
                        Status.name.alias("status_name"),
                        SystemVulnerabilities.status_text.alias("status_text"),
                        SystemVulnerabilities.when_mitigated,
                        SystemVulnerabilities.first_reported,
                        SystemVulnerabilities.advisories,
                        CveAccountData.status_text.alias("cve_status_text"),
                        fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                        CveAccountData.business_risk_text.alias("business_risk_text"),
                        fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                        InsightsRule.name.alias("rule_id"),
                        InsightsRule.description_text,
                        InsightsRule.summary_text,
                        InsightsRule.reboot_required,
                        InsightsRule.playbook_count,
                        InsightsRule.change_risk,
                        InsightsRule.kbase_node_id,
                        InsightsRule.active.alias("rule_active"),
                        InsightsRule.generate_autoplaybook,
                        fn.COALESCE(SystemVulnerabilities.advisory_available, True).alias("advisory_available"),
                        fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation_type_id"),
                        )
                .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                          system_is_active(edge=None, stale=None, rh_account_id=rh_account_id)))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(system_is_vulnerable(rule_subselect=False))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(SystemPlatform.inventory_id == query_args["inventory_id"]))

    @staticmethod
    def _id_query(rh_account_id, query_args):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(CveMetadata.cve.alias("id"),
                        SystemVulnerabilities.status_id,
                        SystemVulnerabilities.status_text,
                        InsightsRule.name.alias("rule_id"),
                        fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                        CveAccountData.status_text.alias("cve_status_text"),
                        fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation"),
                        )
                .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                          system_is_active(edge=None, stale=None, rh_account_id=rh_account_id)))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(system_is_vulnerable(rule_subselect=False))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(SystemPlatform.inventory_id == query_args["inventory_id"]))


class SystemView(ListView):
    """Database select for all systems and count of their vulnerabilities"""

    def __init__(self, rh_account_id, list_args, parsed_args, uri, ids_only=True):
        query = self._full_query(rh_account_id) if not ids_only else self._id_query(rh_account_id, list_args)
        query = cyndi_join(query)

        filters = [filter_types.SYSTEM_STALE,
                   filter_types.SYSTEM_UUID,
                   filter_types.SYSTEM_EXCLUDED,
                   filter_types.SYSTEM_TAGS,
                   filter_types.SYSTEM_SAP,
                   filter_types.SYSTEM_SAP_SIDS,
                   filter_types.SYSTEM_RHEL_VERSION,
                   filter_types.SYSTEM_AAP,
                   filter_types.SYSTEM_MSSQL,
                   ]

        query = apply_filters(query, parsed_args, filters, {})

        sortable_columns = {
            "id": SystemPlatform.id,
            "cve_count": SQL("cve_count"),
            "inventory_id": SystemPlatform.inventory_id,
            "last_evaluation": SystemPlatform.last_evaluation,
            "last_upload": SystemPlatform.last_upload,
            "display_name": SystemPlatform.display_name,
            "rules_evaluation": SystemPlatform.advisor_evaluated,
            "updated": InventoryHosts.updated,
            "os": OS_INFO_SORT,
        }
        default_sort_columns = {
            "default": ["-updated", "id"]
        }
        filterable_columns = {
            "display_name": SystemPlatform.display_name
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id):
        # pylint: disable=singleton-comparison
        selectables = [SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias("rules_evaluation"),
                       SystemPlatform.opt_out,
                       SystemPlatform.last_upload,
                       SystemPlatform.stale_timestamp,
                       SystemPlatform.stale_warning_timestamp,
                       SystemPlatform.culled_timestamp,
                       Case(None, (((SystemPlatform.opt_out == False), SystemPlatform.cve_count_cache),), None).alias("cve_count"),
                       InventoryHosts.tags,
                       InventoryHosts.updated,
                       InventoryHosts.insights_id,
                       OS_INFO_QUERY.alias("os"),
                       ]

        return (SystemPlatform
                .select(*selectables)
                .where(system_is_active(rh_account_id=rh_account_id, deleted=False, edge=False, opt_out=None, stale=None))
                .where(SystemPlatform.last_evaluation.is_null(False) | SystemPlatform.advisor_evaluated.is_null(False))
                .dicts())

    @staticmethod
    def _id_query(rh_account_id, list_args):
        selectables = [SystemPlatform.inventory_id,
                       SystemPlatform.opt_out,
                       SystemPlatform.display_name]

        # pylint: disable=singleton-comparison
        if list_args["sort"] and "cve_count" in list_args["sort"]:
            selectables.append(Case(None, (((SystemPlatform.opt_out == False), SystemPlatform.cve_count_cache),), None).alias("cve_count"))

        query = (SystemPlatform
                 .select(*selectables)
                 .where(system_is_active(rh_account_id=rh_account_id, deleted=False, edge=False, opt_out=None, stale=None))
                 .where(SystemPlatform.last_evaluation.is_null(False) | SystemPlatform.advisor_evaluated.is_null(False))
                 .dicts())

        return query


class GetSystems(GetRequest):
    """GET to /v1/systems"""

    _endpoint_name = r"/v1/systems"
    _ids_only = False

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.SYSTEMS_ENDPOINT_VALUES)
    @RBAC.filter_parameters([filter_excluded])
    def handle_get(cls, **kwargs):
        """Gets all systems and count of their vulnerabilities"""
        args_desc = [
            {"arg_name": "stale", "convert_func": None},
            {"arg_name": "uuid", "convert_func": None},
            {"arg_name": "tags", "convert_func": parse_tags},
            {"arg_name": "sap_system", "convert_func": None},
            {"arg_name": "excluded", "convert_func": None},
            {"arg_name": "sap_sids", "convert_func": None},
            {"arg_name": "rhel_version", "convert_func": parse_str_list},
            {"arg_name": "ansible", "convert_func": None},
            {"arg_name": "mssql", "convert_func": None},
        ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        rh_account_id, _, _ = get_account_data(connexion.context["user"])
        system_view = SystemView(rh_account_id, list_arguments, args, connexion.request.path, cls._ids_only)
        data = []
        if not cls._ids_only:
            for system in system_view:
                record = {}
                system["last_evaluation"] = system["last_evaluation"].isoformat() if system["last_evaluation"] else None
                system["rules_evaluation"] = system["rules_evaluation"].isoformat() if system["rules_evaluation"] else None
                system["last_upload"] = system["last_upload"].isoformat() if system["last_upload"] else None
                system["stale_timestamp"] = system["stale_timestamp"].isoformat() if system["stale_timestamp"] else None
                system["stale_warning_timestamp"] = system["stale_warning_timestamp"].isoformat() if system["stale_warning_timestamp"] else None
                system["culled_timestamp"] = system["culled_timestamp"].isoformat() if system["culled_timestamp"] else None
                system["updated"] = system["updated"]
                system["tags"] = system["tags"] if system["tags"] is not None else []
                system["insights_id"] = system["insights_id"]
                system["os"] = system.get("os", "N/A")
                record["attributes"] = system
                record["id"] = system["inventory_id"]
                record["type"] = "system"
                data.append(record)
        else:
            for system in system_view:
                data.append({"id": system["inventory_id"], "opt_out": system["opt_out"], "display_name": system["display_name"]})

        response = {}
        response["data"] = cls._format_data(list_arguments["data_format"], data, ids_only=cls._ids_only)
        response["meta"] = system_view.get_metadata()
        response["links"] = system_view.get_pagination_links()
        return response


class GetSystemsIds(GetSystems):
    """GET to /v1/systems/ids"""

    _endpoint_name = r"/v1/systems/ids"
    _ids_only = True


class GetSystemsCves(GetRequest):
    """GET to /v1/systems/{inventory_id}/cves"""

    _endpoint_name = r"/v1/systems/{inventory_id}/cves"
    _ids_only = False

    @staticmethod
    def _build_attributes(cve):
        """Build attributes for response"""
        record = {}
        record["synopsis"] = cve["cve_name"]
        record["public_date"] = cve["public_date"].isoformat() if cve["public_date"] else None
        record["impact"] = cve["impact"]
        record["description"] = cve["cve_description"]
        # Store everything we know about CVSS - maybe UI needs to decide what to show
        record["cvss2_score"] = str(cve["cvss2_score"]) if cve["cvss2_score"] is not None else None
        record["cvss3_score"] = str(cve["cvss3_score"]) if cve["cvss3_score"] is not None else None
        # Store status information
        record["cve_status_id"] = cve["cve_status_id"]
        record["status_id"] = cve["status_id"]
        record["status"] = cve["status_name"]
        record["status_text"] = cve["status_text"]
        record["cve_status_text"] = cve["cve_status_text"]
        record["business_risk"] = cve["business_risk"]
        record["business_risk_id"] = cve["business_risk_id"]
        record["business_risk_text"] = cve["business_risk_text"]
        record["reporter"] = (reporter.VMAAS.value if not cve["when_mitigated"] else 0) | (reporter.RULE.value if cve["rule_active"] else 0)
        record["known_exploit"] = cve["exploit_data"] is not None and bool(cve["advisories"])
        record["first_reported"] = cve["first_reported"].isoformat()
        if cve["rule_active"]:
            record["rule"] = {
                "rule_id": cve["rule_id"],
                "description": cve["description_text"],
                "summary": cve["summary_text"],
                "reboot_required": cve["reboot_required"],
                "playbook_count": cve["playbook_count"],
                "change_risk": cve["change_risk"],
                "kbase_node_id": cve["kbase_node_id"],
                "generate_autoplaybook": cve["generate_autoplaybook"],
            }
        else:
            record["rule"] = None
        record["advisories_list"] = cve["advisories"].split(",") if cve["advisories"] is not None else []
        # Defaults to True and playbook - backwards compatibility for NULL values
        record["advisory_available"] = cve["advisory_available"]
        record["remediation"] = cve["remediation_type_id"]
        return record

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.REPORTABLE_ENDPOINTS)
    def handle_get(cls, **kwargs):  # pylint: disable=too-many-statements,too-many-branches
        """Gets affected CVEs for a system"""
        inventory_id = kwargs["inventory_id"]
        args_desc = [{"arg_name": "cvss_from", "convert_func": None},
                     {"arg_name": "cvss_to", "convert_func": None},
                     {"arg_name": "public_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "public_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "impact", "convert_func": parse_int_list},
                     {"arg_name": "status_id", "convert_func": parse_int_list},
                     {"arg_name": "business_risk_id", "convert_func": parse_int_list},
                     {"arg_name": "rule_presence", "convert_func": unique_bool_list},
                     {"arg_name": "show_advisories", "convert_func": None},
                     {"arg_name": "advisory", "convert_func": None},
                     {"arg_name": "rule_key", "convert_func": None},
                     {"arg_name": "known_exploit", "convert_func": unique_bool_list},
                     {"arg_name": "first_reported_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "first_reported_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "advisory_available", "convert_func": unique_bool_list},
                     {"arg_name": "remediation", "convert_func": parse_int_list},
                     ]

        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)

        rh_account_id, _, _ = get_account_data(connexion.context["user"])

        # check if system was evaluated
        try:
            system = (SystemPlatform
                      .select(SystemPlatform.last_evaluation, SystemPlatform.advisor_evaluated, SystemPlatform.opt_out)
                      .where(SystemPlatform.inventory_id == inventory_id)
                      .where(SystemPlatform.rh_account_id == rh_account_id)
                      .where(SystemPlatform.when_deleted.is_null(True))
                      .get())
        except DoesNotExist as exc:
            raise ApplicationException("inventory_id must exist and inventory_id must be visible to user", 404) from exc
        if system.last_evaluation is None and system.advisor_evaluated is None:
            raise ApplicationException("inventory_id exists but is not evaluated", 404)

        cves_view = SystemCvesView(rh_account_id, list_arguments, {"inventory_id": inventory_id}, args, connexion.request.path, cls._ids_only)
        cves = list(cves_view)

        response = {}
        result = []
        if not cls._ids_only:
            for cve in cves:
                record = cls._build_attributes(cve)
                result.append({"type": "cve", "id": cve["cve_name"], "attributes": record})
        else:
            result = cves

        response["meta"] = cves_view.get_metadata()
        response["meta"]["patch_access"] = True  # remove patch_access from response
        response["links"] = cves_view.get_pagination_links()
        response["data"] = cls._format_data(list_arguments["data_format"], result, ids_only=cls._ids_only)
        return response


class GetSystemsCvesIds(GetSystemsCves):
    """GET to /v1/systems/{inventory_id}/cves/ids"""

    _endpoint_name = r"/v1/systems/{inventory_id}/cves/ids"
    _ids_only = True


class GetSystemDetails(GetRequest):
    """GET to /systems/{inventory_id}"""

    _endpoint_name = r"/v1/systems/{inventory_id}"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_get(cls, **kwargs):
        """Get system details"""
        inventory_id = kwargs["inventory_id"]
        rh_account_id, _, _ = get_account_data(connexion.context["user"])
        try:
            selectables = [SystemPlatform.last_evaluation,
                           SystemPlatform.advisor_evaluated,
                           SystemPlatform.opt_out,
                           SystemPlatform.last_upload,
                           SystemPlatform.stale,
                           InventoryHosts.tags,
                           InventoryHosts.updated,
                           InventoryHosts.insights_id,
                           OS_INFO_QUERY.alias("os"),
                           ]

            query = (SystemPlatform.select(*selectables)
                     .where(SystemPlatform.inventory_id == inventory_id)
                     .where(SystemPlatform.rh_account_id == rh_account_id)
                     .where(SystemPlatform.when_deleted.is_null(True)).dicts())
            system = cyndi_join(query).get()
        except DoesNotExist as exc:
            raise ApplicationException("inventory_id must exist and inventory_id must be visible to user", 404) from exc
        return {"data": {"last_evaluation": system["last_evaluation"], "rules_evaluation": system["advisor_evaluated"], "opt_out": system["opt_out"],
                         "last_upload": system["last_upload"], "stale": system["stale"], "os": system.get("os", "N/A"),
                         "tags": system["tags"] if system["tags"] is not None else [],
                         "updated": system["updated"],
                         "insights_id": system["insights_id"]}}


class PatchBulkSystemsOptOut(PatchRequest):
    """PATCH to /systems/opt_out"""

    _endpoint_name = r"/v1/systems/opt_out"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.SYSTEM_OPT_OUT_EDIT)
    def handle_patch(cls, **kwargs):
        """Bulk/single system change of opt_out status"""

        args_desc = [
            {"arg_name": "opt_out", "convert_func": None},
            {"arg_name": "inventory_id", "convert_func": parse_str_or_list}
        ]
        args = cls._parse_arguments(kwargs["data"], args_desc)

        opt_out = args["opt_out"]
        system_list = args["inventory_id"]

        rh_account_id, _, _ = get_account_data(connexion.context["user"])
        if rh_account_id is None:
            raise ApplicationException("user does not exist", 403)

        update = (SystemPlatform.update(opt_out=opt_out)
                  .where((SystemPlatform.rh_account_id == rh_account_id) &
                         (SystemPlatform.inventory_id << system_list) &
                         (SystemPlatform.when_deleted.is_null(True)))
                  .returning(SystemPlatform))
        updated = []
        for system in update.execute():
            updated.append(system.inventory_id)
        if not updated:
            raise ApplicationException("inventory_id must exist and inventory_id must be visible to user", 404)
        return {"updated": updated}
