"""
Module for /systems API endpoint
"""

import dateutil.parser

import connexion
from peewee import Case, DoesNotExist, fn, JOIN, SQL

from common.config import Config
from common.constants import remediation
from common.logging import get_logger
from common.peewee_model import BusinessRisk, CveAccountData, CveMetadata, SystemPlatform, \
    SystemVulnerabilities, CveImpact, Status, RHAccount, InsightsRule, InventoryHosts
from common.utils import external_service_request
from .base import ApplicationException, DEFAULT_BUSINESS_RISK, GetRequest, OS_INFO_QUERY, OS_INFO_SORT, parse_int_list, PatchRequest, \
    CVE_SYNOPSIS_SORT, parse_str_list, parse_str_or_list, reporter, unique_bool_list, parse_tags, \
    cyndi_join, ServiceAccess, get_advisories_per_cve_from_db, filter_by_advisory, \
    get_account_data, has_advisory
from .filters import apply_filters, filter_types
from .list_view import ListView
from .rbac_manager import RbacRoutePermissions, RbacFilterValuePermissions, RbacManager as RBAC

LOGGER = get_logger(__name__)
CFG = Config()


class SystemCvesView(ListView):
    """Database select for /systems endpoint"""

    def __init__(self, rh_account_id, list_args, query_args, filter_args, parsed_args, uri, ids_only=False, cve_advisories=None):
        query = self._full_query(rh_account_id, query_args) if not ids_only else self._id_query(rh_account_id, query_args)
        query = cyndi_join(query)
        filters = [filter_types.CVE_BUSINESS_RISK,
                   filter_types.CVE_CVSS,
                   filter_types.CVE_IMPACT,
                   filter_types.CVE_PUBLIC_DATE,
                   filter_types.SYSTEM_CVE_STATUS,
                   filter_types.SYSTEM_CVE_RULE_PRESENCE,
                   filter_types.SYSTEM_CVE_RULE,
                   filter_types.CVE_KNOWN_EXPLOITS,
                   filter_types.CVE_BY_ADVISORY,
                   filter_types.SYSTEM_CVE_FIRST_REPORTED,
                   filter_types.SYSTEM_CVE_ADVISORY_AVAILABLE,
                   filter_types.SYSTEM_CVE_REMEDIATION,
                   ]

        query = apply_filters(query, filter_args, filters, {'cve_advisories': cve_advisories})

        query = query.dicts()

        sortable_columns = {
            'id': CveMetadata.id,
            'cve': CVE_SYNOPSIS_SORT,
            'synopsis': CVE_SYNOPSIS_SORT,
            'public_date': CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            'cvss_score': Case(None, ((CveMetadata.cvss3_score.is_null(True), CveMetadata.cvss2_score),), \
                               CveMetadata.cvss3_score),
            "cvss3_score": CveMetadata.cvss3_score,
            "cvss2_score": CveMetadata.cvss2_score,
            'impact_id': CveMetadata.impact_id,
            'impact': CveMetadata.impact_id,
            'status_id': Status.id,
            'status': Status.id,
            'business_risk_id': SQL('business_risk_id'),
            'business_risk': SQL('business_risk_id'),
            'first_reported': SystemVulnerabilities.first_reported,
            'advisory_available': SQL('advisory_available'),
            'remediation': SQL('remediation_type_id'),
        }
        default_sort_columns = {
            'default': 'id',
            'cvss_score': 'public_date',
            'cvss2_score': 'public_date',
            'cvss3_score': 'public_date',
            'public_date': 'synopsis',
            'impact': 'public_date'
        }
        filterable_columns = {
            'cve': CveMetadata.cve,
            'description': CveMetadata.description,
            'status': Status.name,
            "rule_description": InsightsRule.description_text
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id, query_args):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(CveMetadata.cve.alias('cve_name'),
                        CveMetadata.cvss3_score,
                        CveMetadata.cvss2_score,
                        CveImpact.name.alias('impact'),
                        CveMetadata.public_date,
                        CveMetadata.description.alias('cve_description'),
                        CveMetadata.exploits,
                        fn.COALESCE(CveAccountData.status_id, 0).alias('cve_status_id'),
                        Status.id.alias('status_id'),
                        Status.name.alias('status_name'),
                        SystemVulnerabilities.status_text.alias('status_text'),
                        SystemVulnerabilities.when_mitigated,
                        SystemVulnerabilities.first_reported,
                        CveAccountData.status_text.alias('cve_status_text'),
                        fn.COALESCE(CveAccountData.business_risk_id, 0).alias('business_risk_id'),
                        CveAccountData.business_risk_text.alias('business_risk_text'),
                        fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias('business_risk'),
                        InsightsRule.name.alias('rule_id'),
                        InsightsRule.description_text,
                        InsightsRule.summary_text,
                        InsightsRule.reboot_required,
                        InsightsRule.playbook_count,
                        InsightsRule.change_risk,
                        InsightsRule.kbase_node_id,
                        InsightsRule.active.alias('rule_active'),
                        fn.COALESCE(SystemVulnerabilities.advisory_available, True).alias('advisory_available'),
                        fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias('remediation_type_id'),
                        )
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False) & (~InsightsRule.rule_only))
                .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True) & (~InsightsRule.rule_only))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(SystemPlatform.inventory_id == query_args['inventory_id'])
                .where(SystemPlatform.opt_out == False)  # noqa: E712
                .where(SystemPlatform.when_deleted.is_null(True)))

    @staticmethod
    def _id_query(rh_account_id, query_args):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(CveMetadata.cve.alias('id'),
                        SystemVulnerabilities.status_id,
                        SystemVulnerabilities.status_text,
                        InsightsRule.name.alias('rule_id'),
                        )
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False) & (~InsightsRule.rule_only))
                .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True) & (~InsightsRule.rule_only))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(SystemPlatform.inventory_id == query_args['inventory_id'])
                .where(SystemPlatform.opt_out == False)  # noqa: E712
                .where(SystemPlatform.when_deleted.is_null(True)))


class SystemView(ListView):
    """Database select for all systems and count of their vulnerabilities"""

    def __init__(self, rh_account_id, list_args, filter_args, parsed_args, uri, ids_only=True):
        query = self._full_query(rh_account_id) if not ids_only else self._id_query(rh_account_id, list_args)
        query = cyndi_join(query)

        filters = [filter_types.SYSTEM_STALE,
                   filter_types.SYSTEM_UUID,
                   filter_types.SYSTEM_EXCLUDED,
                   filter_types.SYSTEM_TAGS,
                   filter_types.SYSTEM_SAP,
                   filter_types.SYSTEM_SAP_SIDS,
                   filter_types.SYSTEM_RHEL_VERSION,
                   ]

        query = apply_filters(query, filter_args, filters, {})

        sortable_columns = {
            'id': SystemPlatform.id,
            'cve_count': SQL("cve_count"),
            'inventory_id': SystemPlatform.inventory_id,
            'last_evaluation': SystemPlatform.last_evaluation,
            'last_upload': SystemPlatform.last_upload,
            'display_name': SystemPlatform.display_name,
            'rules_evaluation': SystemPlatform.advisor_evaluated,
            'updated': InventoryHosts.updated,
            'os': OS_INFO_SORT,
        }
        default_sort_columns = {
            'default': ['-updated', 'id']
        }
        filterable_columns = {
            'display_name': SystemPlatform.display_name
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id):
        # pylint: disable=singleton-comparison
        selectables = [SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias('rules_evaluation'),
                       SystemPlatform.opt_out,
                       SystemPlatform.last_upload,
                       SystemPlatform.stale_timestamp,
                       SystemPlatform.stale_warning_timestamp,
                       SystemPlatform.culled_timestamp,
                       Case(None, (((SystemPlatform.opt_out == False), SystemPlatform.cve_count_cache),), None).alias("cve_count"),
                       InventoryHosts.tags,
                       InventoryHosts.updated,
                       InventoryHosts.insights_id,
                       OS_INFO_QUERY.alias('os'),
                       ]

        return (SystemPlatform
                .select(*selectables)
                .where(SystemPlatform.rh_account_id == rh_account_id)
                .where(SystemPlatform.last_evaluation.is_null(False) | SystemPlatform.advisor_evaluated.is_null(False))
                .where(SystemPlatform.when_deleted.is_null(True))
                .dicts())

    @staticmethod
    def _id_query(rh_account_id, list_args):
        selectables = [SystemPlatform.inventory_id,
                       SystemPlatform.opt_out]

        # pylint: disable=singleton-comparison
        if list_args["sort"] and "cve_count" in list_args["sort"]:
            selectables.append(Case(None, (((SystemPlatform.opt_out == False), SystemPlatform.cve_count_cache),), None).alias("cve_count"))

        query = (SystemPlatform
                 .select(*selectables)
                 .where(SystemPlatform.rh_account_id == rh_account_id)
                 .where(SystemPlatform.last_evaluation.is_null(False) | SystemPlatform.advisor_evaluated.is_null(False))
                 .where(SystemPlatform.when_deleted.is_null(True))
                 .dicts())

        return query


class GetSystems(GetRequest):
    """GET to /v1/systems"""

    _endpoint_name = r'/v1/systems'
    _ids_only = False

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterValuePermissions.SHOW_OPTED_OUT)
    def handle_get(cls, **kwargs):
        """Gets all systems and count of their vulnerabilities"""
        args_desc = [
            {'arg_name': 'stale', 'convert_func': None},
            {'arg_name': 'uuid', 'convert_func': None},
            {'arg_name': 'tags', 'convert_func': parse_tags},
            {'arg_name': 'sap_system', 'convert_func': None},
            {'arg_name': 'excluded', 'convert_func': None},
            {'arg_name': 'sap_sids', 'convert_func': None},
            {'arg_name': 'rhel_version', 'convert_func': parse_str_list},
        ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        rh_account_id, _ = get_account_data(connexion.context['user'])
        system_view = SystemView(rh_account_id, list_arguments, args, args, connexion.request.path, cls._ids_only)
        data = []
        if not cls._ids_only:
            for system in system_view:
                record = {}
                system['last_evaluation'] = system['last_evaluation'].isoformat() if system['last_evaluation'] else None
                system['rules_evaluation'] = system['rules_evaluation'].isoformat() if system['rules_evaluation'] else None
                system['last_upload'] = system['last_upload'].isoformat() if system['last_upload'] else None
                system['stale_timestamp'] = system['stale_timestamp'].isoformat() if system['stale_timestamp'] else None
                system['stale_warning_timestamp'] = system['stale_warning_timestamp'].isoformat() if system['stale_warning_timestamp'] else None
                system['culled_timestamp'] = system['culled_timestamp'].isoformat() if system['culled_timestamp'] else None
                system['updated'] = system['updated']
                system['tags'] = system['tags'] if system['tags'] is not None else []
                system['insights_id'] = system['insights_id']
                system['os'] = system.get('os', 'N/A')
                record['attributes'] = system
                record['id'] = system['inventory_id']
                record['type'] = 'system'
                data.append(record)
        else:
            for system in system_view:
                data.append({'id': system['inventory_id'], 'opt_out': system['opt_out']})

        response = {}
        response['data'] = cls._format_data(list_arguments["data_format"], data)
        response['meta'] = system_view.get_metadata()
        response['links'] = system_view.get_pagination_links()
        return response


class GetSystemsIds(GetSystems):
    """GET to /v1/systems/ids"""

    _endpoint_name = r'/v1/systems/ids'
    _ids_only = True


class GetSystemsCves(GetRequest):
    """GET to /v1/systems/{inventory_id}/cves"""

    _endpoint_name = r'/v1/systems/{inventory_id}/cves'
    _ids_only = False
    patch_advisories_endpoint = "%s%s" % (CFG.patch_host, CFG.patch_views_advisories_api)

    @staticmethod
    def _patch_request_advisories(payload, x_rh_identity, patch_access):
        """Make Patch request for advisories"""
        advisories_response_json = external_service_request(GetSystemsCves.patch_advisories_endpoint,
                                                            method='POST',
                                                            headers={'x-rh-identity': x_rh_identity},
                                                            service_access=patch_access,
                                                            data_json=payload)
        return dict(advisories_response_json['data']) if advisories_response_json is not None else {}

    @classmethod
    def _get_advisories_per_cve(cls, cve_names: list, inv_id: str, adv: str = None):
        """Get advisories per CVE by a specific system"""
        patch_access = ServiceAccess(False)
        cve_advisories = {cve_name: [] for cve_name in cve_names}
        x_rh_identity = connexion.request.headers['x-rh-identity']

        advisories_list = []
        for cve_name in cve_names:
            data = get_advisories_per_cve_from_db(cve_name)
            cve_advisories[cve_name] = data
            advisories_list.extend(data)

        if adv:
            if not has_advisory(adv, advisories_list):
                advisories_list = []

        filtered_cves_advisories = {}
        if advisories_list:
            payload = {'systems': [inv_id],
                       'advisories': advisories_list}
            resp_data = cls._patch_request_advisories(payload, x_rh_identity, patch_access)
            resp_advisories = resp_data.get(inv_id, [])

            for cve, advisories in cve_advisories.items():
                for advisory in resp_advisories:
                    if advisory in advisories:
                        filtered_cves_advisories.setdefault(cve, []).append(advisory)
        return filtered_cves_advisories, patch_access

    @staticmethod
    def _build_attributes(cve, advisories_list=None):
        """Build attributes for response"""
        record = {}
        record['synopsis'] = cve['cve_name']
        record['public_date'] = cve['public_date'].isoformat() if cve['public_date'] else None
        record['impact'] = cve['impact']
        record['description'] = cve['cve_description']
        # Store everything we know about CVSS - maybe UI needs to decide what to show
        record['cvss2_score'] = str(cve['cvss2_score']) if cve['cvss2_score'] is not None else None
        record['cvss3_score'] = str(cve['cvss3_score']) if cve['cvss3_score'] is not None else None
        # Store status information
        record['cve_status_id'] = cve['cve_status_id']
        record['status_id'] = cve['status_id']
        record['status'] = cve['status_name']
        record['status_text'] = cve['status_text']
        record['cve_status_text'] = cve['cve_status_text']
        record['business_risk'] = cve['business_risk']
        record['business_risk_id'] = cve['business_risk_id']
        record['business_risk_text'] = cve['business_risk_text']
        record['reporter'] = (reporter.VMAAS.value if not cve['when_mitigated'] else 0) | (reporter.RULE.value if cve['rule_active'] else 0)
        record['known_exploit'] = bool(cve['exploits'])
        record['first_reported'] = cve['first_reported'].isoformat()
        if cve['rule_active']:
            record['rule'] = {
                'rule_id': cve['rule_id'],
                'description': cve['description_text'],
                'summary': cve['summary_text'],
                'reboot_required': cve['reboot_required'],
                'playbook_count': cve['playbook_count'],
                'change_risk': cve['change_risk'],
                'kbase_node_id': cve['kbase_node_id'],
            }
        else:
            record['rule'] = None
        if advisories_list is not None:
            record['advisories_list'] = advisories_list
        # Defaults to True and playbook - backwards compatibility for NULL values
        record['advisory_available'] = cve['advisory_available']
        record['remediation'] = cve['remediation_type_id']
        return record

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_get(cls, **kwargs):  # pylint: disable=too-many-statements,too-many-branches
        """Gets affected CVEs for a system"""
        inventory_id = kwargs['inventory_id']
        args_desc = [{'arg_name': 'cvss_from', 'convert_func': None},
                     {'arg_name': 'cvss_to', 'convert_func': None},
                     {'arg_name': 'public_from', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'public_to', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'impact', 'convert_func': parse_int_list},
                     {'arg_name': 'status_id', 'convert_func': parse_int_list},
                     {'arg_name': 'business_risk_id', 'convert_func': parse_int_list},
                     {'arg_name': 'rule_presence', 'convert_func': unique_bool_list},
                     {'arg_name': 'show_advisories', 'convert_func': None},
                     {'arg_name': 'advisory', 'convert_func': None},
                     {'arg_name': 'rule_key', 'convert_func': None},
                     {'arg_name': 'known_exploit', 'convert_func': unique_bool_list},
                     {'arg_name': 'first_reported_from', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'first_reported_to', 'convert_func': dateutil.parser.parse},
                     ]

        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)

        # check if advisory parameter comes with show_advisories parameter
        if 'advisory' in args and args['advisory'] and ('show_advisories' not in args or not args['show_advisories']):
            raise ApplicationException("Advisory parameter shouldn't be used without show_advisories parameter", 400)

        # check if system was evaluated
        try:
            system = (SystemPlatform
                      .select(SystemPlatform.last_evaluation, SystemPlatform.advisor_evaluated, SystemPlatform.opt_out)
                      .join(RHAccount, on=(SystemPlatform.rh_account_id == RHAccount.id))
                      .where(SystemPlatform.inventory_id == inventory_id)
                      .where(RHAccount.name == connexion.context['user'])
                      .where(SystemPlatform.when_deleted.is_null(True))
                      .get())
        except DoesNotExist as exc:
            raise ApplicationException('inventory_id must exist and inventory_id must be visible to user', 404) from exc
        if system.last_evaluation is None and system.advisor_evaluated is None:
            raise ApplicationException('inventory_id exists but is not evaluated', 404)

        rh_account_id, _ = get_account_data(connexion.context['user'])

        cve_advisories = {}
        patch_access = None
        if 'show_advisories' in args and args['show_advisories'] and 'advisory' in args and args['advisory']:
            raw_cve_names = (SystemVulnerabilities.select(CveMetadata.cve.alias('cve_name'), )
                             .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                             .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                             .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                                        & (CveAccountData.rh_account_id == rh_account_id)))
                             .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                             .where(SystemPlatform.inventory_id == inventory_id)).dicts()
            cve_names = [cve['cve_name'] for cve in raw_cve_names]
            # get advisory data from PATCH
            cve_advisories, patch_access = cls._get_advisories_per_cve(cve_names, inventory_id, adv=args['advisory'])
            # filter advisories by advisory name
            cve_advisories = filter_by_advisory(args['advisory'], cve_advisories)

            cves_view = SystemCvesView(rh_account_id, list_arguments, {'inventory_id': inventory_id}, args, args, connexion.request.path, cls._ids_only,
                                       cve_advisories)
            cves = list(cves_view)
        elif 'show_advisories' in args and args['show_advisories'] and ('advisory' not in args or not args['advisory']):
            cves_view = SystemCvesView(rh_account_id, list_arguments, {'inventory_id': inventory_id}, args, args, connexion.request.path, cls._ids_only)
            cves = list(cves_view)
            cve_names = [cve['cve_name'] if not cls._ids_only else cve['id'] for cve in cves]
            # get advisory data from PATCH
            cve_advisories, patch_access = cls._get_advisories_per_cve(cve_names, inventory_id)
        else:
            cves_view = SystemCvesView(rh_account_id, list_arguments, {'inventory_id': inventory_id}, args, args, connexion.request.path, cls._ids_only)
            cves = list(cves_view)

        response = {}
        result = []
        if not cls._ids_only:
            for cve in cves:
                if 'show_advisories' in args and args['show_advisories']:
                    record = cls._build_attributes(cve, cve_advisories.get(cve['cve_name'], []))
                    result.append({'type': 'cve', 'id': cve['cve_name'], 'attributes': record})
                else:
                    record = cls._build_attributes(cve)
                    result.append({'type': 'cve', 'id': cve['cve_name'], 'attributes': record})
        else:
            result = cves

        response['meta'] = cves_view.get_metadata()
        response['meta']['patch_access'] = patch_access.status if patch_access else None
        response['links'] = cves_view.get_pagination_links()
        response['data'] = cls._format_data(list_arguments["data_format"], result)
        return response


class GetSystemsCvesIds(GetSystemsCves):
    """GET to /v1/systems/{inventory_id}/cves/ids"""

    _endpoint_name = r'/v1/systems/{inventory_id}/cves/ids'
    _ids_only = True


class GetSystemDetails(GetRequest):
    """GET to /systems/{inventory_id}"""

    _endpoint_name = r'/v1/systems/{inventory_id}'

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_get(cls, **kwargs):
        """Get system details"""
        inventory_id = kwargs['inventory_id']
        try:
            selectables = [SystemPlatform.last_evaluation,
                           SystemPlatform.advisor_evaluated,
                           SystemPlatform.opt_out,
                           SystemPlatform.last_upload,
                           SystemPlatform.stale,
                           InventoryHosts.tags,
                           InventoryHosts.updated,
                           InventoryHosts.insights_id,
                           OS_INFO_QUERY.alias('os'),
                           ]

            query = (SystemPlatform.select(*selectables)
                     .join(RHAccount, on=(SystemPlatform.rh_account_id == RHAccount.id))
                     .where(SystemPlatform.inventory_id == inventory_id)
                     .where(RHAccount.name == connexion.context['user'])
                     .where(SystemPlatform.when_deleted.is_null(True)).dicts())
            system = cyndi_join(query).get()
        except DoesNotExist as exc:
            raise ApplicationException('inventory_id must exist and inventory_id must be visible to user', 404) from exc
        return {'data': {'last_evaluation': system['last_evaluation'], 'rules_evaluation': system['advisor_evaluated'], 'opt_out': system['opt_out'],
                         'last_upload': system['last_upload'], 'stale': system['stale'], 'os': system.get('os', 'N/A'),
                         'tags': system['tags'] if system['tags'] is not None else [],
                         'updated': system['updated'],
                         'insights_id': system['insights_id']}}


class PatchSystemsOptOut(PatchRequest):
    """PATCH to /systems/{inventory_id}/opt_out?value={value}"""

    _endpoint_name = r'/v1/systems/{inventory_id}/opt_out'

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.SYSTEM_OPT_OUT_EDIT)
    def handle_patch(cls, **kwargs):
        """Logic of the opt out feature"""
        inventory_id = kwargs['inventory_id']
        value = kwargs['value']
        update = (SystemPlatform.update(opt_out=value)
                  .where(((RHAccount.select(RHAccount.id)
                           .where(RHAccount.name == connexion.context['user'])
                           .get()).id == SystemPlatform.rh_account_id) &
                         (SystemPlatform.inventory_id == inventory_id) &
                         (SystemPlatform.when_deleted.is_null(True))))
        rows_affected = update.execute()
        if rows_affected == 0:
            raise ApplicationException('inventory_id must exist and inventory_id must be visible to user', 404)


class PatchBulkSystemsOptOut(PatchRequest):
    """PATCH to /systems/opt_out"""

    _endpoint_name = r'/v1/systems/opt_out'

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.SYSTEM_OPT_OUT_EDIT)
    def handle_patch(cls, **kwargs):
        """Bulk/single system change of opt_out status"""

        args_desc = [
            {'arg_name': 'opt_out', 'convert_func': None},
            {'arg_name': 'inventory_id', 'convert_func': parse_str_or_list}
        ]
        args = cls._parse_arguments(kwargs['data'], args_desc)

        opt_out = args['opt_out']
        system_list = args['inventory_id']

        update = (SystemPlatform.update(opt_out=opt_out)
                  .where(((RHAccount.select(RHAccount.id)
                           .where(RHAccount.name == connexion.context['user'])
                           .get()).id == SystemPlatform.rh_account_id) &
                         (SystemPlatform.inventory_id << system_list) &
                         (SystemPlatform.when_deleted.is_null(True)))
                  .returning(SystemPlatform))
        updated = []
        for system in update.execute():
            updated.append(system.inventory_id)
        if not updated:
            raise ApplicationException('inventory_id must exist and inventory_id must be visible to user', 404)
        return {'updated': updated}
