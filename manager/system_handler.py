"""
Module for /systems API endpoint
"""
import connexion
import dateutil.parser
from peewee import Case
from peewee import DoesNotExist
from peewee import fn
from peewee import JOIN
from peewee import SQL
from peewee import Value

from .base import ApplicationException
from .base import CVE_SYNOPSIS_SORT
from .base import cyndi_join
from .base import DEFAULT_BUSINESS_RISK
from .base import DEFAULT_REMEDIATION_FILTER
from .base import get_account_data
from .base import get_remediation_filter
from .base import GetRequest
from .base import OS_INFO_QUERY
from .base import OS_INFO_SORT
from .base import parse_int_list
from .base import parse_str_list
from .base import parse_str_or_list
from .base import parse_tags
from .base import PatchRequest
from .base import reporter
from .base import transform_ids
from .base import transform_names
from .base import unique_bool_list
from .filters import apply_filters
from .filters import filter_types
from .list_view import ListView
from .rbac_filters import filter_excluded
from .rbac_manager import RbacFilterRoutePermissions
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions
from common.config import Config
from common.constants import remediation
from common.feature_flags import UNLEASH
from common.logging import get_logger
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import BusinessRisk
from common.peewee_model import CveAccountData
from common.peewee_model import CveImpact
from common.peewee_model import CveMetadata
from common.peewee_model import InsightsRule
from common.peewee_model import InventoryHosts
from common.peewee_model import Status
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities
from common.peewee_model import SystemVulnerablePackage
from common.peewee_model import VulnerablePackageCVE

LOGGER = get_logger(__name__)
CFG = Config()


class SystemCvesView(ListView):
    """Database select for /systems/{system_id}/cves endpoint"""

    def __init__(self, account_data, list_args, query_args, parsed_args, uri, ids_only=False):
        filters = [filter_types.SYSTEM_CVE_FIRST_REPORTED,
                   filter_types.SYSTEM_CVE_REMEDIATION,
                   filter_types.SYSTEM_CVE_RULE_PRESENCE,
                   filter_types.SYSTEM_VULNERABILITES_BY_ADVISORY,
                   filter_types.SYSTEM_CVE_STATUS,
                   filter_types.CVE_BUSINESS_RISK,
                   filter_types.CVE_CVSS,
                   filter_types.CVE_IMPACT,
                   filter_types.CVE_PUBLIC_DATE,
                   filter_types.CVE_KNOWN_EXPLOITS,
                   ]

        if not account_data.cves_without_errata:
            query = (self._full_query(account_data.id, query_args, parsed_args, filters, remediation_filter=DEFAULT_REMEDIATION_FILTER) if not ids_only
                     else self._id_query(account_data.id, query_args, parsed_args, filters, remediation_filter=DEFAULT_REMEDIATION_FILTER))
        else:
            query = (self._unpatched_full_query(account_data.id, query_args, parsed_args, filters) if not ids_only
                     else self._unpatched_id_query(account_data.id, query_args, parsed_args, filters))
        if not ids_only:
            query = query.select_from(
                query.c.id,
                query.c.cve_name,
                query.c.cvss3_score,
                query.c.cvss2_score,
                query.c.impact,
                query.c.public_date,
                query.c.cve_description,
                query.c.exploit_data,
                query.c.impact_id,
                query.c.cve_status_id,
                query.c.status_id,
                query.c.status_name,
                query.c.status_text,
                query.c.when_mitigated,
                query.c.first_reported,
                query.c.advisories,
                query.c.cve_status_text,
                query.c.business_risk_id,
                query.c.business_risk_text,
                query.c.business_risk,
                query.c.rule_id,
                query.c.description_text,
                query.c.summary_text,
                query.c.reboot_required,
                query.c.playbook_count,
                query.c.change_risk,
                query.c.kbase_node_id,
                query.c.rule_active,
                query.c.generate_autoplaybook,
                query.c.advisory_available,
                query.c.remediation_type_id,
            )
        else:
            query = query.select_from(
                query.c.id,
                query.c.cve_name,
                query.c.status_id,
                query.c.status_text,
                query.c.rule_id,
                query.c.cve_status_id,
                query.c.cve_status_text,
                query.c.remediation,
            )
        query = query.dicts()

        sortable_columns = {
            "id": SQL("id"),
            "cve": CVE_SYNOPSIS_SORT,
            "synopsis": CVE_SYNOPSIS_SORT,
            "public_date": SQL("public_date"),
            # This assumes we only show one score, and that cvss3 wins over cvss2
            "cvss_score": Case(None, ((SQL("cvss3_score").is_null(True), SQL("cvss2_score")),), \
                               SQL("cvss3_score")),
            "cvss3_score": SQL("cvss3_score"),
            "cvss2_score": SQL("cvss2_score"),
            "impact_id": SQL("impact_id"),
            "impact": SQL("impact_id"),
            "status_id": SQL("status_id"),
            "status": SQL("status_id"),
            "business_risk_id": SQL("business_risk_id"),
            "business_risk": SQL("business_risk_id"),
            "first_reported": SQL("first_reported"),
            "advisory_available": SQL("advisory_available"),
            "remediation": SQL("remediation_type_id"),
            "advisories_list": SQL("advisories"),
        }
        default_sort_columns = {
            "default": "id",
            "cvss_score": "public_date",
            "cvss2_score": "public_date",
            "cvss3_score": "public_date",
            "public_date": "synopsis",
            "impact": "public_date",
            "business_risk": "public_date",
            "status": "public_date",
        }
        filterable_columns = {
            "cve": SQL("cve_name"),
            "description": SQL("cve_description"),
            "status": SQL("status_name"),
            "rule_description": SQL("description_text")
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id, query_args, parsed_args, filters, remediation_filter=None):
        # pylint: disable=singleton-comparison
        subq = (SystemVulnerabilities
                .select(CveMetadata.id,
                        CveMetadata.cve.alias("cve_name"),
                        CveMetadata.cvss3_score,
                        CveMetadata.cvss2_score,
                        CveImpact.name.alias("impact"),
                        CveMetadata.public_date,
                        CveMetadata.description.alias("cve_description"),
                        CveMetadata.exploit_data,
                        CveMetadata.impact_id,
                        fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                        Status.id.alias("status_id"),
                        Status.name.alias("status_name"),
                        SystemVulnerabilities.status_text.alias("status_text"),
                        SystemVulnerabilities.when_mitigated,
                        SystemVulnerabilities.first_reported,
                        SystemVulnerabilities.advisories,
                        CveAccountData.status_text.alias("cve_status_text"),
                        fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                        CveAccountData.business_risk_text.alias("business_risk_text"),
                        fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                        InsightsRule.name.alias("rule_id"),
                        InsightsRule.description_text,
                        InsightsRule.summary_text,
                        InsightsRule.reboot_required,
                        InsightsRule.playbook_count,
                        InsightsRule.change_risk,
                        InsightsRule.kbase_node_id,
                        InsightsRule.active.alias("rule_active"),
                        InsightsRule.generate_autoplaybook,
                        fn.COALESCE(SystemVulnerabilities.advisory_available, True).alias("advisory_available"),
                        fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation_type_id"),
                        )
                .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                          system_is_active(edge=None, stale=None, rh_account_id=rh_account_id)))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(system_is_vulnerable(rule_subselect=False))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(SystemPlatform.inventory_id == query_args["inventory_id"]))
        if remediation_filter:
            subq = subq.where(SystemVulnerabilities.remediation_type_id << remediation_filter)

        subq = cyndi_join(subq)
        return apply_filters(subq, parsed_args, filters, {"unfixed": [False]})

    @staticmethod
    def _unpatched_full_query(rh_account_id, query_args, parsed_args, filters):
        # pylint: disable=singleton-comparison
        remediation_filter, return_only_first_subq = get_remediation_filter(parsed_args["advisory_available"])

        fixed_subq = SystemCvesView._full_query(rh_account_id, query_args, parsed_args, filters, remediation_filter=remediation_filter)
        unfixed_subq = (SystemVulnerablePackage
                        .select(CveMetadata.id,
                                CveMetadata.cve.alias("cve_name"),
                                CveMetadata.cvss3_score,
                                CveMetadata.cvss2_score,
                                CveImpact.name.alias("impact"),
                                CveMetadata.public_date,
                                CveMetadata.description.alias("cve_description"),
                                CveMetadata.exploit_data,
                                CveMetadata.impact_id,
                                fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                                Value(0).alias("status_id"),
                                Value("Not Reviewed").alias("status_name"),
                                Value(None).alias("status_text"),
                                Value(None).alias("when_mitigated"),
                                SystemVulnerablePackage.first_reported,
                                Value(None).alias("advisories"),
                                CveAccountData.status_text.alias("cve_status_text"),
                                fn.COALESCE(CveAccountData.business_risk_id, 0).alias("business_risk_id"),
                                CveAccountData.business_risk_text.alias("business_risk_text"),
                                fn.COALESCE(BusinessRisk.name, DEFAULT_BUSINESS_RISK).alias("business_risk"),
                                Value(None).alias("rule_id"),
                                Value(None).alias("description_text"),
                                Value(None).alias("summary_text"),
                                Value(False).alias("reboot_required"),
                                Value(0).alias("playbook_count"),
                                Value(0).alias("change_risk"),
                                Value(0).alias("kbase_node_id"),
                                Value(False).alias("rule_active"),
                                Value(False).alias("generate_autoplaybook"),
                                Value(False).alias("advisory_available"),
                                Value(remediation.NONE.value).alias("remediation_type_id"),
                                )
                        .join(SystemPlatform, on=(SystemVulnerablePackage.system_id == SystemPlatform.id) &
                              system_is_active(edge=None, stale=None, rh_account_id=rh_account_id))
                        .join(VulnerablePackageCVE, on=(SystemVulnerablePackage.vulnerable_package_id == VulnerablePackageCVE.vulnerable_package_id))
                        .join(CveMetadata, on=(VulnerablePackageCVE.cve_id == CveMetadata.id))
                        .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                        .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                                   & (CveAccountData.rh_account_id == rh_account_id)))
                        .join(BusinessRisk, JOIN.LEFT_OUTER, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                        .where(SystemVulnerablePackage.rh_account_id == rh_account_id)
                        .where(SystemPlatform.inventory_id == query_args["inventory_id"]))
        unfixed_subq = cyndi_join(unfixed_subq)
        unfixed_subq = apply_filters(unfixed_subq, parsed_args, filters, {"unfixed": [True]})

        if return_only_first_subq:
            return fixed_subq
        else:
            return (fixed_subq + unfixed_subq)

    @staticmethod
    def _id_query(rh_account_id, query_args, parsed_args, filters, remediation_filter=None):
        # pylint: disable=singleton-comparison
        subq = (SystemVulnerabilities
                .select(CveMetadata.id,
                        CveMetadata.cve.alias("cve_name"),
                        CveMetadata.description.alias("cve_description"),
                        SystemVulnerabilities.status_id,
                        Status.name.alias("status_name"),
                        SystemVulnerabilities.status_text,
                        InsightsRule.name.alias("rule_id"),
                        InsightsRule.description_text,
                        fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                        CveAccountData.status_text.alias("cve_status_text"),
                        fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation"),
                        )
                .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                          system_is_active(edge=None, stale=None, rh_account_id=rh_account_id)))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id)
                                                           & (CveAccountData.rh_account_id == rh_account_id)))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(system_is_vulnerable(rule_subselect=False))
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(SystemPlatform.inventory_id == query_args["inventory_id"]))
        if remediation_filter:
            subq = subq.where(SystemVulnerabilities.remediation_type_id << remediation_filter)

        subq = cyndi_join(subq)
        return apply_filters(subq, parsed_args, filters, {})

    @staticmethod
    def _unpatched_id_query(rh_account_id, query_args, parsed_args, filters):
        # pylint: disable=singleton-comparison
        remediation_filter, return_only_first_subq = get_remediation_filter(parsed_args["advisory_available"])

        fixed_subq = SystemCvesView._id_query(rh_account_id, query_args, parsed_args, filters, remediation_filter=remediation_filter)
        unfixed_subq = (SystemVulnerablePackage
                        .select(CveMetadata.id,
                                CveMetadata.cve.alias("cve_name"),
                                CveMetadata.description.alias("cve_description"),
                                Value(0).alias("status_id"),
                                Value("Not Reviewed").alias("status_name"),
                                Value(None).alias("status_text"),
                                Value(None).alias("rule_id"),
                                Value(None).alias("description_text"),
                                fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                                CveAccountData.status_text.alias("cve_status_text"),
                                Value(remediation.NONE.value).alias("remediation"),
                                )
                        .join(SystemPlatform, on=(SystemVulnerablePackage.system_id == SystemPlatform.id) &
                              system_is_active(edge=None, stale=None, rh_account_id=rh_account_id))
                        .join(VulnerablePackageCVE, on=(SystemVulnerablePackage.vulnerable_package_id == VulnerablePackageCVE.vulnerable_package_id))
                        .join(CveMetadata, on=(VulnerablePackageCVE.cve_id == CveMetadata.id))
                        .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.cve_id == CveMetadata.id) &
                              (CveAccountData.rh_account_id == rh_account_id)))
                        .where(SystemVulnerablePackage.rh_account_id == rh_account_id)
                        .where(SystemPlatform.inventory_id == query_args["inventory_id"]))
        unfixed_subq = cyndi_join(unfixed_subq)
        unfixed_subq = apply_filters(unfixed_subq, parsed_args, filters, {"unfixed": [True]})

        if return_only_first_subq:
            return fixed_subq
        else:
            return (fixed_subq + unfixed_subq)


class SystemView(ListView):
    """Database select for all systems and count of their vulnerabilities"""

    def __init__(self, account_data, list_args, parsed_args, uri, ids_only=True):
        query = self._full_query(account_data.id) if not ids_only else self._id_query(account_data.id, list_args)
        query = cyndi_join(query)

        filters = [filter_types.SYSTEM_STALE,
                   filter_types.SYSTEM_UUID,
                   filter_types.SYSTEM_EXCLUDED,
                   filter_types.SYSTEM_TAGS,
                   filter_types.SYSTEM_SAP,
                   filter_types.SYSTEM_SAP_SIDS,
                   filter_types.SYSTEM_RHEL_VERSION,
                   filter_types.SYSTEM_AAP,
                   filter_types.SYSTEM_MSSQL,
                   filter_types.INVENTORY_GROUP_NAMES,
                   filter_types.INVENTORY_GROUP_IDS,
                   ]

        query = apply_filters(query, parsed_args, filters, {})

        sortable_columns = {
            "id": SystemPlatform.id,
            "cve_count": SQL("cve_count"),
            "inventory_id": SystemPlatform.inventory_id,
            "last_evaluation": SystemPlatform.last_evaluation,
            "last_upload": SystemPlatform.last_upload,
            "display_name": SystemPlatform.display_name,
            "rules_evaluation": SystemPlatform.advisor_evaluated,
            "updated": InventoryHosts.updated,
            "os": OS_INFO_SORT,
        }
        default_sort_columns = {
            "default": ["-updated", "id"]
        }
        filterable_columns = {
            "display_name": SystemPlatform.display_name
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id):
        # pylint: disable=singleton-comparison
        selectables = [SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias("rules_evaluation"),
                       SystemPlatform.opt_out,
                       SystemPlatform.last_upload,
                       SystemPlatform.stale_timestamp,
                       SystemPlatform.stale_warning_timestamp,
                       SystemPlatform.culled_timestamp,
                       Case(None, (((SystemPlatform.opt_out == False), SystemPlatform.cve_count_cache),), None).alias("cve_count"),
                       InventoryHosts.tags,
                       InventoryHosts.updated,
                       InventoryHosts.insights_id,
                       OS_INFO_QUERY.alias("os"),
                       InventoryHosts.groups.alias("inventory_group"),
                       ]

        return (SystemPlatform
                .select(*selectables)
                .where(system_is_active(rh_account_id=rh_account_id, deleted=False, edge=False, opt_out=None, stale=None))
                .where(SystemPlatform.last_evaluation.is_null(False) | SystemPlatform.advisor_evaluated.is_null(False))
                .dicts())

    @staticmethod
    def _id_query(rh_account_id, list_args):
        selectables = [SystemPlatform.inventory_id,
                       SystemPlatform.opt_out,
                       SystemPlatform.display_name]

        # pylint: disable=singleton-comparison
        if list_args["sort"] and "cve_count" in list_args["sort"]:
            selectables.append(Case(None, (((SystemPlatform.opt_out == False), SystemPlatform.cve_count_cache),), None).alias("cve_count"))

        query = (SystemPlatform
                 .select(*selectables)
                 .where(system_is_active(rh_account_id=rh_account_id, deleted=False, edge=False, opt_out=None, stale=None))
                 .where(SystemPlatform.last_evaluation.is_null(False) | SystemPlatform.advisor_evaluated.is_null(False))
                 .dicts())

        return query


class GetSystems(GetRequest):
    """GET to /v1/systems"""

    _endpoint_name = r"/v1/systems"
    _ids_only = False

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.SYSTEMS_ENDPOINT_VALUES)
    @RBAC.filter_parameters([filter_excluded])
    def handle_get(cls, **kwargs):
        """Gets all systems and count of their vulnerabilities"""
        args_desc = [
            {"arg_name": "stale", "convert_func": None},
            {"arg_name": "uuid", "convert_func": None},
            {"arg_name": "tags", "convert_func": parse_tags},
            {"arg_name": "sap_system", "convert_func": None},
            {"arg_name": "excluded", "convert_func": None},
            {"arg_name": "sap_sids", "convert_func": None},
            {"arg_name": "rhel_version", "convert_func": parse_str_list},
            {"arg_name": "ansible", "convert_func": None},
            {"arg_name": "mssql", "convert_func": None},
            {"arg_name": "group_ids", "convert_func": transform_ids},
            {"arg_name": "group_names", "convert_func": transform_names},
        ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        account_data = get_account_data(connexion.context["user"])
        system_view = SystemView(account_data, list_arguments, args, connexion.request.path, cls._ids_only)
        data = []
        if not cls._ids_only:
            for system in system_view:
                record = {}
                system["last_evaluation"] = system["last_evaluation"].isoformat() if system["last_evaluation"] else None
                system["rules_evaluation"] = system["rules_evaluation"].isoformat() if system["rules_evaluation"] else None
                system["last_upload"] = system["last_upload"].isoformat() if system["last_upload"] else None
                system["stale_timestamp"] = system["stale_timestamp"].isoformat() if system["stale_timestamp"] else None
                system["stale_warning_timestamp"] = system["stale_warning_timestamp"].isoformat() if system["stale_warning_timestamp"] else None
                system["culled_timestamp"] = system["culled_timestamp"].isoformat() if system["culled_timestamp"] else None
                system["updated"] = system["updated"]
                system["tags"] = system["tags"] if system["tags"] is not None else []
                system["insights_id"] = system["insights_id"]
                system["os"] = system.get("os", "N/A")
                record["attributes"] = system
                record["id"] = system["inventory_id"]
                record["type"] = "system"
                data.append(record)
        else:
            for system in system_view:
                data.append({"id": system["inventory_id"], "opt_out": system["opt_out"], "display_name": system["display_name"]})

        response = {}
        response["data"] = cls._format_data(list_arguments["data_format"], data, ids_only=cls._ids_only)
        response["meta"] = system_view.get_metadata()
        response["links"] = system_view.get_pagination_links()
        return response


class GetSystemsIds(GetSystems):
    """GET to /v1/systems/ids"""

    _endpoint_name = r"/v1/systems/ids"
    _ids_only = True


class GetSystemsCves(GetRequest):
    """GET to /v1/systems/{inventory_id}/cves"""

    _endpoint_name = r"/v1/systems/{inventory_id}/cves"
    _ids_only = False

    @staticmethod
    def _build_attributes(cve):
        """Build attributes for response"""
        record = {}
        record["synopsis"] = cve["cve_name"]
        record["public_date"] = cve["public_date"].isoformat() if cve["public_date"] else None
        record["impact"] = cve["impact"]
        record["description"] = cve["cve_description"]
        # Store everything we know about CVSS - maybe UI needs to decide what to show
        record["cvss2_score"] = str(cve["cvss2_score"]) if cve["cvss2_score"] is not None else None
        record["cvss3_score"] = str(cve["cvss3_score"]) if cve["cvss3_score"] is not None else None
        # Store status information
        record["cve_status_id"] = cve["cve_status_id"]
        record["status_id"] = cve["status_id"]
        record["status"] = cve["status_name"]
        record["status_text"] = cve["status_text"]
        record["cve_status_text"] = cve["cve_status_text"]
        record["business_risk"] = cve["business_risk"]
        record["business_risk_id"] = cve["business_risk_id"]
        record["business_risk_text"] = cve["business_risk_text"]
        record["reporter"] = (reporter.VMAAS.value if not cve["when_mitigated"] else 0) | (reporter.RULE.value if cve["rule_active"] else 0)
        record["known_exploit"] = cve["exploit_data"] is not None and cve["advisory_available"]
        record["first_reported"] = cve["first_reported"].isoformat()
        if cve["rule_active"]:
            record["rule"] = {
                "rule_id": cve["rule_id"],
                "description": cve["description_text"],
                "summary": cve["summary_text"],
                "reboot_required": cve["reboot_required"],
                "playbook_count": cve["playbook_count"],
                "change_risk": cve["change_risk"],
                "kbase_node_id": cve["kbase_node_id"],
                "generate_autoplaybook": cve["generate_autoplaybook"],
            }
        else:
            record["rule"] = None
        if UNLEASH.is_enabled("vulnerability.cves_without_errata") or cve["remediation_type_id"] == 2:  # playbook
            record["advisories_list"] = cve["advisories"].split(",") if cve["advisories"] is not None else []
        else:
            record["advisories_list"] = []
        # Defaults to True and playbook - backwards compatibility for NULL values
        record["advisory_available"] = cve["advisory_available"]
        record["remediation"] = cve["remediation_type_id"]
        return record

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.REPORTABLE_ENDPOINTS)
    def handle_get(cls, **kwargs):  # pylint: disable=too-many-statements,too-many-branches
        """Gets affected CVEs for a system"""
        inventory_id = kwargs["inventory_id"]
        args_desc = [{"arg_name": "cvss_from", "convert_func": None},
                     {"arg_name": "cvss_to", "convert_func": None},
                     {"arg_name": "public_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "public_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "impact", "convert_func": parse_int_list},
                     {"arg_name": "status_id", "convert_func": parse_int_list},
                     {"arg_name": "business_risk_id", "convert_func": parse_int_list},
                     {"arg_name": "rule_presence", "convert_func": unique_bool_list},
                     {"arg_name": "show_advisories", "convert_func": None},
                     {"arg_name": "advisory", "convert_func": None},
                     {"arg_name": "rule_key", "convert_func": None},
                     {"arg_name": "known_exploit", "convert_func": unique_bool_list},
                     {"arg_name": "first_reported_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "first_reported_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "advisory_available", "convert_func": unique_bool_list},
                     {"arg_name": "remediation", "convert_func": parse_int_list},
                     ]

        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)

        account_data = get_account_data(connexion.context["user"])

        # check if system was evaluated
        try:
            system = (SystemPlatform
                      .select(SystemPlatform.last_evaluation, SystemPlatform.advisor_evaluated, SystemPlatform.opt_out)
                      .where(SystemPlatform.inventory_id == inventory_id)
                      .where(SystemPlatform.rh_account_id == account_data.id)
                      .where(SystemPlatform.when_deleted.is_null(True))
                      .get())
        except DoesNotExist as exc:
            raise ApplicationException("inventory_id must exist and inventory_id must be visible to user", 404) from exc
        if system.last_evaluation is None and system.advisor_evaluated is None:
            raise ApplicationException("inventory_id exists but is not evaluated", 404)

        cves_view = SystemCvesView(
            account_data, list_arguments, {"inventory_id": inventory_id}, args, connexion.request.path, cls._ids_only
        )
        cves = list(cves_view)

        response = {}
        result = []
        if not cls._ids_only:
            for cve in cves:
                record = cls._build_attributes(cve)
                result.append({"type": "cve", "id": cve["cve_name"], "attributes": record})
        else:
            for cve in cves:
                result.append(
                    {
                        "id": cve["cve_name"],
                        "status_id": cve["status_id"],
                        "status_text": cve["status_text"],
                        "rule_id": cve["rule_id"],
                        "cve_status_id": cve["cve_status_id"],
                        "cve_status_text": cve["cve_status_text"],
                        "remediation": cve["remediation"],
                    }
                )

        response["meta"] = cves_view.get_metadata()
        response["meta"]["patch_access"] = True  # remove patch_access from response
        response["meta"]["cves_without_errata"] = account_data.cves_without_errata
        response["links"] = cves_view.get_pagination_links()
        response["data"] = cls._format_data(list_arguments["data_format"], result, ids_only=cls._ids_only)
        return response


class GetSystemsCvesIds(GetSystemsCves):
    """GET to /v1/systems/{inventory_id}/cves/ids"""

    _endpoint_name = r"/v1/systems/{inventory_id}/cves/ids"
    _ids_only = True


class GetSystemDetails(GetRequest):
    """GET to /systems/{inventory_id}"""

    _endpoint_name = r"/v1/systems/{inventory_id}"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_get(cls, **kwargs):
        """Get system details"""
        inventory_id = kwargs["inventory_id"]
        rh_account_id = get_account_data(connexion.context["user"]).id
        try:
            selectables = [SystemPlatform.last_evaluation,
                           SystemPlatform.advisor_evaluated,
                           SystemPlatform.opt_out,
                           SystemPlatform.last_upload,
                           SystemPlatform.stale,
                           InventoryHosts.tags,
                           InventoryHosts.updated,
                           InventoryHosts.insights_id,
                           OS_INFO_QUERY.alias("os"),
                           InventoryHosts.groups.alias("inventory_group"),
                           ]

            query = (SystemPlatform.select(*selectables)
                     .where(SystemPlatform.inventory_id == inventory_id)
                     .where(SystemPlatform.rh_account_id == rh_account_id)
                     .where(SystemPlatform.when_deleted.is_null(True)).dicts())
            system = cyndi_join(query).get()
        except DoesNotExist as exc:
            raise ApplicationException("inventory_id must exist and inventory_id must be visible to user", 404) from exc
        return {"data": {"last_evaluation": system["last_evaluation"], "rules_evaluation": system["advisor_evaluated"], "opt_out": system["opt_out"],
                         "last_upload": system["last_upload"], "stale": system["stale"], "os": system.get("os", "N/A"),
                         "tags": system["tags"] if system["tags"] is not None else [],
                         "updated": system["updated"],
                         "insights_id": system["insights_id"],
                         "inventory_group": system.get("inventory_group", [])
                         }}


class PatchBulkSystemsOptOut(PatchRequest):
    """PATCH to /systems/opt_out"""

    _endpoint_name = r"/v1/systems/opt_out"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.SYSTEM_OPT_OUT_EDIT)
    def handle_patch(cls, **kwargs):
        """Bulk/single system change of opt_out status"""

        args_desc = [
            {"arg_name": "opt_out", "convert_func": None},
            {"arg_name": "inventory_id", "convert_func": parse_str_or_list}
        ]
        args = cls._parse_arguments(kwargs["data"], args_desc)

        opt_out = args["opt_out"]
        system_list = args["inventory_id"]

        rh_account_id = get_account_data(connexion.context["user"]).id
        if rh_account_id is None:
            raise ApplicationException("user does not exist", 403)

        update = (SystemPlatform.update(opt_out=opt_out)
                  .where((SystemPlatform.rh_account_id == rh_account_id) &
                         (SystemPlatform.inventory_id << system_list) &
                         (SystemPlatform.when_deleted.is_null(True)))
                  .returning(SystemPlatform))
        updated = []
        for system in update.execute():
            updated.append(system.inventory_id)
        if not updated:
            raise ApplicationException("inventory_id must exist and inventory_id must be visible to user", 404)
        return {"updated": updated}
