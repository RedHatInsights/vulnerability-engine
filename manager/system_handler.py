"""
Module for /systems API endpoint
"""

import json

from common import AuthenticatedHandler, parse_url, InvalidArgumentException
from database.peewee_model import CveMetadata, SystemPlatform, SystemVulnerabilities, CveImpact
from list_view import ListView

class SystemCvesView(ListView):
    """Database select for /systems endpoint"""
    def __init__(self, list_args, query_args):
        query = (
            SystemVulnerabilities
            .select(CveMetadata.cve.alias('cve_name'),
                    CveMetadata.cvss3_score,
                    CveMetadata.cvss2_score,
                    CveImpact.name.alias('impact'),
                    CveMetadata.public_date,
                    CveMetadata.description.alias('cve_description'))
            .join(SystemPlatform, on=(SystemVulnerabilities.platform_id == SystemPlatform.platform_id))
            .join(CveMetadata, on=(SystemVulnerabilities.cve == CveMetadata.cve))
            .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
            .where(SystemPlatform.rh_account == query_args['rh_account_number'])
            .where(SystemPlatform.platform_id == query_args['platform_id'])
            .dicts()
        )
        sortable_columns = {
            'cve' : SystemVulnerabilities.cve,
            'public_date' : CveMetadata.public_date,
            # This assumes we only show one score, and that cvss3 wins over cvss2
            'cvss_score' : CveMetadata.cvss3_score if CveMetadata.cvss3_score else CveMetadata.cvss2_score,
            'impact' : CveMetadata.impact_id
        }
        filterable_columns = {
            'cve' : SystemVulnerabilities.cve,
            'description' : CveMetadata.description
        }
        super(SystemCvesView, self).__init__(query, sortable_columns, filterable_columns, list_args)

class SystemHandler(AuthenticatedHandler):
    """Handler for /systems endpoint"""

    def get(self): # pylint: disable=arguments-differ
        """Get CVEs for a system
           ---
           description: Get CVEs for a system
           responses:
             200:
               description: JSON containing CVEs for a systems is returuned
        """
        route = parse_url(self.request.uri, "/systems")
        if len(route) == 2 and route[1] == 'cves':
            self.get_cves(route[0])
        else:
            self.raiseError(404)
        self.flush()

    def post(self): # pylint: disable=arguments-differ
        self.flush()

    def get_cves(self, platform_id):
        """Gets affected CVEs for a system"""
        try:
            cves_view = SystemCvesView(self._parse_list_arguments(),
                                       {"rh_account_number": self.rh_account_number, 'platform_id' : platform_id})
        except InvalidArgumentException as exc: # pylint: disable=broad-except
            self.raiseError(400, str(exc))
            return
        response = {}
        result = []
        for cve in cves_view:
            record = {}
            record['synopsis'] = cve['cve_name']
            record['public_date'] = cve['public_date'].isoformat()
            record['impact'] = cve['impact']
            record['description'] = cve['cve_description']
            # Store everything we know about CVSS - maybe UI needs to decide what to show
            record['cvss2_score'] = str(cve['cvss2_score']) if cve['cvss2_score'] is not None else ''
            record['cvss3_score'] = str(cve['cvss3_score']) if cve['cvss3_score'] is not None else ''
            # cvss_score might be cvss3, or 2, or empty, because CVE-data is filthy
            if cve["cvss3_score"]:
                record["cvss_score"] = str(cve["cvss3_score"])
            elif cve["cvss2_score"]:
                record["cvss_score"] = str(cve["cvss2_score"])
            else:
                record["cvss_score"] = ''

            result.append({'type' : 'cve', 'id' : cve['cve_name'], 'attributes' : record})
        try:
            response['meta'] = cves_view.get_metadata()
            response['data'] = result
        except Exception as exc: # pylint: disable=broad-except
            self.raiseError(500, str(exc))
            return
        self.write(json.dumps(response))
