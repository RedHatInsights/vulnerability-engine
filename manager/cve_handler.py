"""
Module for /cves API endpoint
"""
import json

from datetime import datetime, timezone
import dateutil.parser

import connexion
from peewee import DoesNotExist, IntegrityError, fn, DataError, JOIN, SQL
from psycopg2 import IntegrityError as psycopg2IntegrityError

from common.config import Config
from common.constants import remediation
from common.logging import get_logger
from common.utils import str_or_none, format_datetime, external_service_request
from common.peewee_model import BusinessRisk, CveAccountData, CveMetadata, DB, RHAccount, \
    Status, SystemPlatform, SystemVulnerabilities, CveImpact, InsightsRule, InventoryHosts
from .base import ApplicationException, DEFAULT_BUSINESS_RISK, DEFAULT_STATUS, OS_INFO_QUERY, OS_INFO_SORT, get_or_create_account, \
    GetRequest, parse_int_list, PatchRequest, get_rules_for_cves, parse_str_list, reporter, unique_bool_list, \
    parse_tags, cyndi_join, ServiceAccess, \
    get_advisories_per_cve_from_db, filter_by_advisory, get_account_data, has_advisory
from .filters import apply_filters, filter_types
from .list_view import ListView
from .rbac_manager import RbacRoutePermissions, RbacFilterRoutePermissions, RbacManager as RBAC

LOGGER = get_logger(__name__)
CFG = Config()


class SystemCvesView(ListView):
    """Database select for /cves/{cve_id}/{affected,mitigated}_systems API endpoints"""

    def __init__(self, rh_account_id, synopsis, list_args, filter_args, parsed_args, uri, ids_only=False, system_advisories=None):
        query = self._full_query(rh_account_id, synopsis) if not ids_only else self._id_query(rh_account_id, synopsis)
        query = cyndi_join(query)
        filters = [filter_types.SYSTEM_CVE_RULE,
                   filter_types.SYSTEM_CVE_RULE_KEY,
                   filter_types.SYSTEM_CVE_STATUS,
                   filter_types.SYSTEM_UUID,
                   filter_types.SYSTEM_CVE_RULE_PRESENCE,
                   filter_types.SYSTEM_BY_ADVISORY,
                   filter_types.SYSTEM_CVE_FIRST_REPORTED,
                   filter_types.SYSTEM_TAGS,
                   filter_types.SYSTEM_SAP,
                   filter_types.SYSTEM_SAP_SIDS,
                   filter_types.SYSTEM_RHEL_VERSION,
                   filter_types.SYSTEM_CVE_ADVISORY_AVAILABLE,
                   filter_types.SYSTEM_CVE_REMEDIATION,
                   ]

        query = apply_filters(query, filter_args, filters, {'system_advisories': system_advisories})
        query = query.dicts()

        sortable_columns = {
            'display_name': SystemPlatform.display_name,
            'id': SystemPlatform.id,
            'inventory_id': SystemPlatform.inventory_id,
            'last_evaluation': SystemPlatform.last_evaluation,
            'last_upload': SystemPlatform.last_upload,
            'rules_evaluation': SystemPlatform.advisor_evaluated,
            'status_id': Status.id,
            'status': Status.id,
            'updated': InventoryHosts.updated,
            'first_reported': SystemVulnerabilities.first_reported,
            'os': OS_INFO_SORT,
            'advisory_available': SQL('advisory_available'),
            'remediation': SQL('remediation_type_id'),
        }
        default_sort_columns = {
            'default': ['-updated', 'id'],
        }
        filterable_columns = {
            'display_name': SystemPlatform.display_name
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id, synopsis):
        """To be implemented in child classes"""
        raise NotImplementedError

    @staticmethod
    def _id_query(rh_account_id, synopsis):
        """To be implemented in child classes"""
        raise NotImplementedError


class AffectedSystemsView(SystemCvesView):
    """Database select queries for /cves/{cve_id}/affected_systems API endpoint"""

    @staticmethod
    def _full_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        selectables = [fn.COALESCE(CveAccountData.status_id, 0).alias('cve_status_id'),
                       SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias('rules_evaluation'),
                       SystemPlatform.last_upload,
                       SystemPlatform.stale_timestamp,
                       SystemPlatform.stale_warning_timestamp,
                       SystemPlatform.culled_timestamp,
                       Status.id.alias('status_id'),
                       Status.name.alias('status_name'),
                       SystemVulnerabilities.status_text.alias('status_text'),
                       SystemVulnerabilities.rule_hit_details,
                       SystemVulnerabilities.when_mitigated,
                       SystemVulnerabilities.first_reported,
                       InsightsRule.name.alias('rule_id'),
                       InsightsRule.active.alias('rule_active'),
                       InsightsRule.description_text,
                       InsightsRule.reason_text,
                       InsightsRule.resolution_text,
                       InsightsRule.kbase_node_id,
                       InsightsRule.more_info_text,
                       InventoryHosts.tags,
                       InventoryHosts.updated,
                       InventoryHosts.insights_id,
                       OS_INFO_QUERY.alias('os'),
                       fn.COALESCE(SystemVulnerabilities.advisory_available, True).alias('advisory_available'),
                       fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias('remediation_type_id'),
                       ]

        return (SystemVulnerabilities
                .select(*selectables)
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.rh_account_id == rh_account_id)
                                                           & (CveMetadata.id == CveAccountData.cve_id)))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False) & (~InsightsRule.rule_only))
                .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True) & (~InsightsRule.rule_only))
                .where((SystemPlatform.opt_out == False)
                       & (SystemPlatform.stale == False)
                       & (SystemPlatform.when_deleted.is_null(True))
                       & (fn.COALESCE(SystemPlatform.host_type, 'null') != 'edge')))

    @staticmethod
    def _id_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(SystemPlatform.inventory_id,
                        InsightsRule.name.alias('rule_id'),
                        SystemVulnerabilities.status_id.alias('status_id'),
                        SystemVulnerabilities.status_text.alias('status_text'),
                        )
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False) & (~InsightsRule.rule_only))
                .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True) & (~InsightsRule.rule_only))
                .where((SystemPlatform.opt_out == False)
                       & (SystemPlatform.stale == False)
                       & (SystemPlatform.when_deleted.is_null(True))
                       & (fn.COALESCE(SystemPlatform.host_type, 'null') != 'edge')))


class MitigatedSystemsView(SystemCvesView):
    """Database queries for /cves/{cve_id}/mitigated_systems API endpoint"""

    @staticmethod
    def _full_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        selectables = [fn.COALESCE(CveAccountData.status_id, 0).alias('cve_status_id'),
                       SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias('rules_evaluation'),
                       SystemPlatform.last_upload,
                       SystemPlatform.stale_timestamp,
                       SystemPlatform.stale_warning_timestamp,
                       SystemPlatform.culled_timestamp,
                       Status.id.alias('status_id'),
                       Status.name.alias('status_name'),
                       SystemVulnerabilities.status_text.alias('status_text'),
                       SystemVulnerabilities.mitigation_reason,
                       SystemVulnerabilities.when_mitigated,
                       InsightsRule.name.alias('rule_id'),
                       InventoryHosts.tags,
                       InventoryHosts.updated,
                       InventoryHosts.insights_id,
                       OS_INFO_QUERY.alias('os'),
                       fn.COALESCE(SystemVulnerabilities.advisory_available, True).alias('advisory_available'),
                       fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias('remediation_type_id'),
                       ]

        return (SystemVulnerabilities
                .select(*selectables)
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.rh_account_id == rh_account_id)
                                                           & (CveMetadata.id == CveAccountData.cve_id)))
                .join(InsightsRule, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where((SystemVulnerabilities.mitigation_reason.is_null(False)) & (InsightsRule.active == True))
                .where((SystemPlatform.opt_out == False)
                       & (SystemPlatform.stale == False)
                       & (SystemPlatform.when_deleted.is_null(True))
                       & (fn.COALESCE(SystemPlatform.host_type, 'null') != 'edge')))

    @staticmethod
    def _id_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(SystemPlatform.inventory_id,
                        InsightsRule.name.alias('rule_id'),
                        SystemVulnerabilities.status_id.alias('status_id'),
                        SystemVulnerabilities.status_text.alias('status_text'),
                        )
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(InsightsRule, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where((SystemVulnerabilities.mitigation_reason.is_null(False)) & (InsightsRule.active == True))
                .where((SystemPlatform.opt_out == False)
                       & (SystemPlatform.stale == False)
                       & (SystemPlatform.when_deleted.is_null(True))
                       & (fn.COALESCE(SystemPlatform.host_type, 'null') != 'edge')))


class GetCves(GetRequest):
    """GET to /v1/cves/{cve_id}"""

    _endpoint_name = r'/v1/cves/{cve_id}'
    patch_advisories_endpoint = "%s%s%s%s" % (CFG.patch_host, CFG.patch_advisories_api, CFG.patch_id_query_filter, CFG.patch_filter_prefix)

    @staticmethod
    def _patch_request_advisories(patch_request_list):
        """Make Patch request for advisories"""
        query = ','.join(patch_request_list)
        endpoint_with_query = '%s%s' % (GetCves.patch_advisories_endpoint, query)
        x_rh_identity = connexion.request.headers['x-rh-identity']
        advisories_response_json = external_service_request(endpoint_with_query, method='GET', headers={'x-rh-identity': x_rh_identity})
        return list(advisories_response_json['data']) if advisories_response_json is not None else None

    @staticmethod
    def _get_cve_details(synopsis, args):
        try:
            data = (CveMetadata.select(CveImpact.name.alias('impact'), CveMetadata.cve.alias('synopsis'),
                                       CveMetadata.description, CveMetadata.cvss2_metrics,
                                       CveMetadata.cvss2_score, CveMetadata.cvss3_score,
                                       CveMetadata.cvss3_metrics, CveMetadata.modified_date, CveMetadata.celebrity_name,
                                       CveMetadata.public_date, CveMetadata.redhat_url,
                                       CveMetadata.secondary_url, CveMetadata.id, CveMetadata.advisories_list,
                                       CveMetadata.exploits)
                    .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                    .where(CveMetadata.cve == synopsis)).dicts()[0]
            rules_map = get_rules_for_cves([data['id']], connexion.context['user'])
            retval = {
                "celebrity_name": str_or_none(data['celebrity_name']),
                "cvss2_metrics": str_or_none(data['cvss2_metrics']),
                "cvss2_score": str_or_none(data['cvss2_score']),
                "cvss3_metrics": str_or_none(data['cvss3_metrics']),
                "cvss3_score": str_or_none(data['cvss3_score']),
                "description": data['description'],
                "impact": data['impact'],
                "public_date": format_datetime(data['public_date']),
                "modified_date": format_datetime(data['modified_date']),
                "redhat_url": data['redhat_url'],
                "rules": rules_map.get(data['id'], []),
                "secondary_url": data['secondary_url'],
                "synopsis": data['synopsis'],
                "known_exploit": bool(data['exploits'])
            }

            advisories_list = [] if data.get('advisories_list') is None else data['advisories_list']
            if 'show_advisories_details' in args and args['show_advisories_details'] is True and advisories_list:
                retval["advisories_list"] = GetCves._patch_request_advisories(advisories_list)
            else:
                retval["advisories_list"] = advisories_list
        except IndexError as exc:
            raise ApplicationException('No such CVE ID', 404) from exc
        return retval

    @classmethod
    def _cve_details(cls, synopsis, args):
        retval = cls._get_cve_details(synopsis, args)
        cve_details = (CveAccountData.select(BusinessRisk.name.alias('risk'),
                                             CveAccountData.business_risk_id.alias('risk_id'),
                                             CveAccountData.business_risk_text.alias('risk_text'),
                                             Status.name.alias("status"),
                                             CveAccountData.status_id.alias("status_id"),
                                             CveAccountData.status_text.alias("status_text"))
                       .join(BusinessRisk, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                       .join(Status, on=(CveAccountData.status_id == Status.id))
                       .join(CveMetadata, on=(CveAccountData.cve_id == CveMetadata.id))
                       .where(CveAccountData.rh_account_id == (RHAccount.select(RHAccount.id)
                                                               .where(RHAccount.name == connexion.context['user'])))
                       .where(CveMetadata.cve == synopsis)).dicts()
        if cve_details.count():
            retval['business_risk'] = cve_details[0]['risk']
            retval['business_risk_id'] = cve_details[0]['risk_id']
            retval['business_risk_text'] = cve_details[0]['risk_text']
            retval['status'] = cve_details[0]['status']
            retval['status_id'] = cve_details[0]['status_id']
            retval['status_text'] = cve_details[0]['status_text']
        else:
            retval['business_risk'] = DEFAULT_BUSINESS_RISK
            retval['business_risk_id'] = 0
            retval['business_risk_text'] = None
            retval['status'] = DEFAULT_STATUS
            retval['status_id'] = 0
            retval['status_text'] = None

        # add counts of systems with all statuses
        retval['systems_status_detail'] = {}
        # pylint: disable=singleton-comparison
        rh_account_id, _, _ = get_account_data(connexion.context['user'])
        status_detail = (SystemVulnerabilities
                         .select(SystemVulnerabilities.status_id, fn.Count(SystemVulnerabilities.status_id).alias('systems'))
                         .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                         .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                         .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                         .where(CveMetadata.cve == synopsis)
                         .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                         .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False) & (~InsightsRule.rule_only))
                         .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True) & (~InsightsRule.rule_only))
                         .where((SystemPlatform.opt_out == False)
                                & (SystemPlatform.stale == False)
                                & (SystemPlatform.when_deleted.is_null(True))
                                & (fn.COALESCE(SystemPlatform.host_type, 'null') != 'edge'))
                         .group_by(SystemVulnerabilities.status_id)
                         .dicts())

        divergent_systems = 0
        status_detail = cyndi_join(status_detail)
        for row in status_detail:
            retval['systems_status_detail'][row['status_id']] = row['systems']
            if row['status_id'] != retval['status_id']:
                divergent_systems += row['systems']
        retval['systems_status_divergent'] = divergent_systems
        return retval

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.CSV_FORMAT_ENDPOINTS)
    def handle_get(cls, **kwargs):
        res = {}
        args_desc = [{'arg_name': 'show_advisories_details', 'convert_func': None}]
        args = cls._parse_arguments(kwargs, args_desc)
        cve_details = cls._cve_details(kwargs['cve_id'], args)

        patch_access = None
        if cve_details['advisories_list'] is None:
            patch_access = False
        elif args.get('show_advisories_details'):
            patch_access = True

        res['data'] = {
            'attributes': cve_details,
            'id': kwargs['cve_id'],
            'type': 'cve',
            'patch_access': patch_access
        }
        return res


class GetCveSystems(GetRequest):
    """Parent class for {affected,mitigated}_systems endpoints"""

    patch_advisories_endpoint = f"{CFG.patch_host}{CFG.patch_views_advisories_api}"
    _DB_View = AffectedSystemsView
    _ids_only = False

    @staticmethod
    def _build_attributes(sys, advisories_list=None):
        """To be implemented by child classes"""
        raise NotImplementedError

    @staticmethod
    def _patch_request_advisories(payload, x_rh_identity, patch_access):
        """Make Patch request for advisories"""
        advisories_response_json = external_service_request(GetCvesAffectedSystems.patch_advisories_endpoint,
                                                            method='POST',
                                                            headers={'x-rh-identity': x_rh_identity},
                                                            service_access=patch_access,
                                                            data_json=payload)
        return dict(advisories_response_json['data']) if advisories_response_json is not None else {}

    @staticmethod
    def _cve_exists(synopsis):
        try:
            (CveMetadata.select(CveMetadata.cve)
             .where(CveMetadata.cve == synopsis)
             .get())
        except DoesNotExist as exc:
            raise ApplicationException('No such CVE ID', 404) from exc

    @classmethod
    def _get_advisories_per_system(cls, advisories_list, inv_ids):
        """Get advisories per system by a specific CVE"""
        patch_access = ServiceAccess(False)
        x_rh_identity = connexion.request.headers['x-rh-identity']
        data = {}
        if advisories_list:
            payload = {'systems': inv_ids,
                       'advisories': advisories_list}
            data = cls._patch_request_advisories(payload, x_rh_identity, patch_access)
        return data, patch_access

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.REPORTABLE_ENDPOINTS)
    def handle_get(cls, **kwargs):
        """Gets systems affected by a CVE"""
        synopsis = kwargs['cve_id']
        cls._cve_exists(synopsis)
        args_desc = [{'arg_name': 'status_id', 'convert_func': parse_int_list},
                     {'arg_name': 'uuid', 'convert_func': None},
                     {'arg_name': 'rule_presence', 'convert_func': unique_bool_list},
                     {'arg_name': 'rule_key', 'convert_func': None},
                     {'arg_name': 'tags', 'convert_func': parse_tags},
                     {'arg_name': 'sap_system', 'convert_func': None},
                     {'arg_name': 'show_advisories', 'convert_func': None},
                     {'arg_name': 'advisory', 'convert_func': None},
                     {'arg_name': 'sap_sids', 'convert_func': None},
                     {'arg_name': 'rhel_version', 'convert_func': parse_str_list},
                     {'arg_name': 'first_reported_from', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'first_reported_to', 'convert_func': dateutil.parser.parse},
                     {'arg_name': 'rule', 'convert_func': None},
                     {'arg_name': 'advisory_available', 'convert_func': unique_bool_list},
                     {'arg_name': 'remediation', 'convert_func': parse_int_list},
                     ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)

        # check if advisory parameter comes with show_advisories parameter
        if 'advisory' in args and args['advisory'] and ('show_advisories' not in args or not args['show_advisories']):
            raise ApplicationException("Advisory parameter shouldn't be used without show_advisories parameter", 400)
        rh_account_id, _, _ = get_account_data(connexion.context['user'])

        system_advisories = {}
        patch_access = None
        if 'show_advisories' in args and args['show_advisories'] and 'advisory' in args and args['advisory']:
            # pylint: disable=singleton-comparison
            raw_inv_ids = (SystemVulnerabilities.select(SystemPlatform.inventory_id)
                           .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                           .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                           .where(CveMetadata.cve == synopsis)
                           .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                           .where((SystemPlatform.opt_out == False)  # noqa: E712
                                  & (SystemPlatform.stale == False)  # noqa: E712
                                  & (SystemPlatform.when_deleted.is_null(True))
                                  & (fn.COALESCE(SystemPlatform.host_type, 'null') != 'edge'))).dicts()
            raw_inv_ids = [inv_id['inventory_id'] for inv_id in raw_inv_ids]
            # Pass advisory argument for filtering advisories list by advisory to prevent redundant patch requests
            advisories_list = get_advisories_per_cve_from_db(synopsis)
            if not has_advisory(args['advisory'], advisories_list):
                advisories_list = []

            # get advisory data from PATCH
            system_advisories, patch_access = cls._get_advisories_per_system(advisories_list, raw_inv_ids)
            # Filter systems by advisory
            system_advisories = filter_by_advisory(args['advisory'], system_advisories)

            asys_view = cls._DB_View(rh_account_id, synopsis, list_arguments, args, args, connexion.request.path, cls._ids_only, system_advisories)
            systems = list(asys_view)  # execute query
        elif 'show_advisories' in args and args['show_advisories'] and ('advisory' not in args or not args['advisory']):
            asys_view = cls._DB_View(rh_account_id, synopsis, list_arguments, args, args, connexion.request.path, cls._ids_only)
            systems = list(asys_view)  # execute query
            inv_ids = [sys['inventory_id'] for sys in systems]
            # get advisory data from PATCH
            advisories_list = get_advisories_per_cve_from_db(synopsis)
            system_advisories, patch_access = cls._get_advisories_per_system(advisories_list, inv_ids)
        else:
            asys_view = cls._DB_View(rh_account_id, synopsis, list_arguments, args, args, connexion.request.path, cls._ids_only)
            systems = list(asys_view)  # execute query

        response = {}
        result = []
        if cls._ids_only:
            result = systems
        else:
            for sys in systems:
                if 'show_advisories' in args and args['show_advisories']:
                    record = cls._build_attributes(sys, system_advisories.get(sys['inventory_id'], []))
                    result.append({'type': 'system', 'id': sys['inventory_id'], 'attributes': record})
                else:
                    record = cls._build_attributes(sys)
                    result.append({'type': 'system', 'id': sys['inventory_id'], 'attributes': record})

        response['meta'] = asys_view.get_metadata()
        response['meta']['patch_access'] = patch_access.status if patch_access else None
        response['links'] = asys_view.get_pagination_links()
        response['data'] = cls._format_data(list_arguments["data_format"], result, ids_only=cls._ids_only)
        return response


class GetCvesAffectedSystems(GetCveSystems):
    """GET to /v1/cves/{cve_id}/affected_systems"""

    _endpoint_name = r'/v1/cves/{cve_id}/affected_systems'

    @staticmethod
    def _build_attributes(sys, advisories_list=None):
        """Build attributes for response"""
        record = {}
        record['cve_status_id'] = sys['cve_status_id']
        record['inventory_id'] = sys['inventory_id']
        record['insights_id'] = sys['insights_id']
        record['display_name'] = sys['display_name']
        record['status_id'] = sys['status_id']
        record['status_name'] = sys['status_name']
        record['status_text'] = sys['status_text']
        record['last_evaluation'] = sys['last_evaluation'].isoformat() if sys['last_evaluation'] else ''
        record['rules_evaluation'] = sys['rules_evaluation'].isoformat() if sys['rules_evaluation'] else None
        record['reporter'] = (reporter.VMAAS.value if not sys['when_mitigated'] else 0) | (reporter.RULE.value if sys['rule_active'] else 0)
        record['rule'] = {
            'details': json.loads(sys['rule_hit_details']) if sys['rule_hit_details'] else {},
            'resolution': {
                'resolution': sys['resolution_text']
            },
            'rule': {
                'description': sys['description_text'],
                'more_info': sys['more_info_text'],
                'node_id': sys['kbase_node_id'],
                'reason': sys['reason_text'],
                'rule_id': sys['rule_id'],
            }
        } if sys['rule_active'] else None
        record['tags'] = sys['tags'] if sys['tags'] is not None else []
        if advisories_list is not None:
            record['advisories_list'] = advisories_list
        record['updated'] = sys['updated']
        record['os'] = sys.get('os', 'N/A')
        record['first_reported'] = sys['first_reported'].isoformat()
        # Defaults to True and playbook - backwards compatibility for NULL values
        record['advisory_available'] = sys['advisory_available']
        record['remediation'] = sys['remediation_type_id']
        record['stale_timestamp'] = sys['stale_timestamp'].isoformat() if sys['stale_timestamp'] else None
        record['stale_warning_timestamp'] = sys['stale_warning_timestamp'].isoformat() if sys['stale_warning_timestamp'] else None
        record['culled_timestamp'] = sys['culled_timestamp'].isoformat() if sys['culled_timestamp'] else None
        return record


class GetCvesAffectedSystemsIds(GetCvesAffectedSystems):
    """ GET to /v1/cves/{cve_id}/affected_systems/ids """

    _endpoint_name = r'/v1/cves/{cve_id}/affected_systems/ids'
    _ids_only = True


class GetCvesMitigatedSystems(GetCveSystems):
    """GET to /v1/cves/{cve_id}/rule_mitigated_systems"""

    _endpoint_name = r'/v1/cves/{cve_id}/rule_mitigated_systems'
    _DB_View = MitigatedSystemsView

    @staticmethod
    def _build_attributes(sys, advisories_list=None):
        """Build attributes for response"""
        record = {}
        record['cve_status_id'] = sys['cve_status_id']
        record['inventory_id'] = sys['inventory_id']
        record['insights_id'] = sys['insights_id']
        record['display_name'] = sys['display_name']
        record['mitigation_reason'] = sys['mitigation_reason']
        record['status_id'] = sys['status_id']
        record['status_name'] = sys['status_name']
        record['status_text'] = sys['status_text']
        record['last_evaluation'] = sys['last_evaluation'].isoformat() if sys['last_evaluation'] else ''
        record['rule_id'] = sys['rule_id']
        record['rules_evaluation'] = sys['rules_evaluation'].isoformat() if sys['rules_evaluation'] else None
        record['reporter'] = (reporter.VMAAS.value if not sys['when_mitigated'] else 0) | reporter.RULE.value
        record['tags'] = sys['tags'] if sys['tags'] is not None else []
        if advisories_list is not None:
            record['advisories_list'] = advisories_list
        record['updated'] = sys['updated']
        record['os'] = sys.get('os', 'N/A')
        # Defaults to True and playbook - backwards compatibility for NULL values
        record['advisory_available'] = sys['advisory_available']
        record['remediation'] = sys['remediation_type_id']
        record['stale_timestamp'] = sys['stale_timestamp'].isoformat() if sys['stale_timestamp'] else None
        record['stale_warning_timestamp'] = sys['stale_warning_timestamp'].isoformat() if sys['stale_warning_timestamp'] else None
        record['culled_timestamp'] = sys['culled_timestamp'].isoformat() if sys['culled_timestamp'] else None
        return record


class GetCvesMitigatedSystemsIds(GetCvesMitigatedSystems):
    """ GET to /v1/cves/{cve_id}/rule_mitigated_systems/ids """

    _endpoint_name = r'/v1/cves/{cve_id}/rule_mitigated_systems/ids'
    _ids_only = True


class PatchCveRisk(PatchRequest):
    """ PATCH to /v1/cves/business_risk"""

    _endpoint_name = r'/v1/cves/business_risk'

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.business_risk_id, CveAccountData.business_risk_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.CVE_BR_AND_STATUS_EDIT)
    def handle_patch(cls, **kwargs):
        """Set business risk for a CVE"""
        data = kwargs['data']
        cve_list = data['cve']
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if 'business_risk_id' in data:
            values['business_risk_id'] = data['business_risk_id']
        if 'business_risk_text' in data:
            try:
                values['business_risk_text'] = data['business_risk_text'].strip() \
                    if data['business_risk_text'].strip() else None
            except AttributeError:
                values['business_risk_text'] = None
        if not values:
            return cls.format_exception(
                'At least one of the "business_risk_id" or "business_risk_text" parameters is required.', 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account = get_or_create_account()
            for cve in cves:  # pylint: disable=not-an-iterable
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account[0].id, values.get('business_risk_id', 0),
                                  values.get('business_risk_text', None)))
            if not to_insert:
                return cls.format_exception('At least one given CVE must exist', 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad business_risk_id
            LOGGER.exception('Error during setting business risk (IntegrityError):')
            DB.rollback()
            return cls.format_exception(f"business_risk_id={data['business_risk_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception('Error during setting business risk (ValueError):')
            DB.rollback()
            return cls.format_exception(f'business_risk_text or other key value is invalid ({value_error})', 400)
        return {'updated': updated}


class PatchCveStatus(PatchRequest):
    """ PATCH to /v1/cves/status"""

    _endpoint_name = r'/v1/cves/status'

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.status_id, CveAccountData.status_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.CVE_BR_AND_STATUS_EDIT)
    def handle_patch(cls, **kwargs):
        """Set status for a CVE"""
        data = kwargs['data']
        cve_list = data['cve']
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if 'status_id' in data:
            values['status_id'] = data['status_id']
        if 'status_text' in data:
            try:
                values['status_text'] = data['status_text'].strip() \
                    if data['status_text'].strip() else None
            except AttributeError:
                values['status_text'] = None
        if not values:
            return cls.format_exception(
                'At least one of the "status_id" or "status_text" parameters is required.', 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account = get_or_create_account()
            for cve in cves:  # pylint: disable=not-an-iterable
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account[0].id, values.get('status_id', 0), values.get('status_text', None)))
            if not to_insert:
                return cls.format_exception('At least one given CVE must exist', 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
            RHAccount.update(last_status_change=datetime.now(timezone.utc)).where(RHAccount.id == rh_account[0].id).execute()
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad status
            LOGGER.exception('Error during setting status (IntegrityError):')
            DB.rollback()
            return cls.format_exception(f"status_id={data['status_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception('Error during setting status (ValueError):')
            DB.rollback()
            return cls.format_exception(f'status_text or other key value is invalid ({value_error})', 400)
        return {'updated': updated}
