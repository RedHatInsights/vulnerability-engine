"""
Module for /cves API endpoint
"""
import concurrent.futures
import json
import os

import connexion
from peewee import DoesNotExist, IntegrityError, fn, DataError, JOIN
from psycopg2 import IntegrityError as psycopg2IntegrityError

from common.logging import get_logger
from common.utils import str_or_none, format_datetime, external_service_request, FUTURE_ERR
from common.peewee_model import BusinessRisk, CveAccountData, CveMetadata, DB, RHAccount, \
    Status, SystemPlatform, SystemVulnerabilities, CveImpact, InsightsRule, InventoryHosts
from .base import ApplicationException, DEFAULT_BUSINESS_RISK, DEFAULT_STATUS, get_or_create_account, \
    GetRequest, parse_int_list, PatchRequest, get_rules_for_cves, reporter, unique_bool_list, bool_or_rules_list, \
    CYNDI_ENABLED, parse_tags, cyndi_query, PATCH_HOST, PATCH_ID_QUERY_FILTER, PATCH_FILTER_PREFIX, WORKER_THREADS, ServiceAccess, \
    get_advisories_per_cve_from_db, filter_by_advisory, get_account_id
from .filters import apply_filters, filter_types
from .list_view import ListView

LOGGER = get_logger(__name__)

PATCH_ADVISORIES_API = os.getenv("PATCH_ADVISORIES_API", "/api/patch/v1/advisories")


class AffectedSystemsView(ListView):
    """Database select for /cves API endpoint"""

    def __init__(self, rh_account_id, synopsis, list_args, filter_args, parsed_args, uri, ids_only=False):
        query = self._full_query(rh_account_id, synopsis) if not ids_only else self._id_query(rh_account_id, synopsis)
        query = cyndi_query(query)
        filters = [filter_types.SYSTEM_CVE_RULE,
                   filter_types.SYSTEM_CVE_STATUS,
                   filter_types.SYSTEM_UUID,
                   filter_types.SYSTEM_CVE_RULE_PRESENCE,
                   filter_types.SYSTEM_CVE_RULE_OLD]
        if CYNDI_ENABLED:
            filters.append(filter_types.SYSTEM_TAGS)
            filters.append(filter_types.SYSTEM_SAP)
            filters.append(filter_types.SYSTEM_SAP_SIDS)

        query = apply_filters(query, filter_args, filters, {})

        query = query.dicts()

        sortable_columns = {
            'display_name': SystemPlatform.display_name,
            'id': SystemPlatform.id,
            'inventory_id': SystemPlatform.inventory_id,
            'last_evaluation': SystemPlatform.last_evaluation,
            'last_upload': SystemPlatform.last_upload,
            'rules_evaluation': SystemPlatform.advisor_evaluated,
            'status_id': Status.id,
            'status': Status.id,
            'updated': InventoryHosts.updated if CYNDI_ENABLED else SystemPlatform.last_upload
        }
        default_sort_columns = ['-updated', 'id']
        filterable_columns = {
            'display_name': SystemPlatform.display_name
        }
        filter_expressions = {}
        super(AffectedSystemsView, self).__init__(query, sortable_columns, default_sort_columns,
                                                  filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        selectables = [fn.COALESCE(CveAccountData.status_id, 0).alias('cve_status_id'),
                       SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias('rules_evaluation'),
                       Status.id.alias('status_id'),
                       Status.name.alias('status_name'),
                       SystemVulnerabilities.status_text.alias('status_text'),
                       SystemVulnerabilities.rule_hit_details,
                       SystemVulnerabilities.when_mitigated,
                       InsightsRule.name.alias('rule_id'),
                       InsightsRule.active.alias('rule_active'),
                       InsightsRule.description_text,
                       InsightsRule.reason_text,
                       InsightsRule.resolution_text,
                       InsightsRule.kbase_node_id,
                       InsightsRule.more_info_text]
        if CYNDI_ENABLED:
            selectables.append(InventoryHosts.tags)

        return (
            SystemVulnerabilities
            .select(*selectables)
            .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
            .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
            .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
            .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.rh_account_id == rh_account_id)
                                                       & (CveMetadata.id == CveAccountData.cve_id)))
            .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
            .where(CveMetadata.cve == synopsis)
            .where(SystemVulnerabilities.rh_account_id == rh_account_id)
            .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False))
            .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True))
            .where((SystemPlatform.opt_out == False)  # noqa: E712
                   & (SystemPlatform.stale == False)  # noqa: E712
                   & (SystemPlatform.when_deleted.is_null(True)))
        )

    @staticmethod
    def _id_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        return (
            SystemVulnerabilities
            .select(SystemPlatform.inventory_id)
            .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
            .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
            .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
            .where(CveMetadata.cve == synopsis)
            .where(SystemVulnerabilities.rh_account_id == rh_account_id)
            .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False))
            .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True))
            .where((SystemPlatform.opt_out == False)  # noqa: E712
                   & (SystemPlatform.stale == False)  # noqa: E712
                   & (SystemPlatform.when_deleted.is_null(True)))
        )


class GetCves(GetRequest):
    """GET to /v1/cves/{cve_id}"""

    _endpoint_name = r'/v1/cves/{cve_id}'
    patch_advisories_endpoint = "%s%s%s%s" % (PATCH_HOST, PATCH_ADVISORIES_API, PATCH_ID_QUERY_FILTER, PATCH_FILTER_PREFIX)

    @staticmethod
    def _patch_request_advisories(patch_request_list):
        """Make Patch request for advisories"""
        query = ','.join(patch_request_list)
        endpoint_with_query = '%s%s' % (GetCves.patch_advisories_endpoint, query)
        x_rh_identity = connexion.request.headers['x-rh-identity']
        advisories_response_json = external_service_request(endpoint_with_query, method='GET', headers={'x-rh-identity': x_rh_identity})
        return list(advisories_response_json['data']) if advisories_response_json is not None else None

    @staticmethod
    def _get_cve_details(synopsis, args):
        try:
            data = (CveMetadata.select(CveImpact.name.alias('impact'), CveMetadata.cve.alias('synopsis'),
                                       CveMetadata.description, CveMetadata.cvss2_metrics,
                                       CveMetadata.cvss2_score, CveMetadata.cvss3_score,
                                       CveMetadata.cvss3_metrics, CveMetadata.modified_date,
                                       CveMetadata.public_date, CveMetadata.redhat_url,
                                       CveMetadata.secondary_url, CveMetadata.id, CveMetadata.advisories_list)
                    .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                    .where(CveMetadata.cve == synopsis)).dicts()[0]
            rules_map = get_rules_for_cves([data['id']], connexion.context['user'])
            retval = {
                "cvss2_metrics": str_or_none(data['cvss2_metrics']),
                "cvss2_score": str_or_none(data['cvss2_score']),
                "cvss3_metrics": str_or_none(data['cvss3_metrics']),
                "cvss3_score": str_or_none(data['cvss3_score']),
                "description": data['description'],
                "impact": data['impact'],
                "public_date": format_datetime(data['public_date']),
                "modified_date": format_datetime(data['modified_date']),
                "redhat_url": data['redhat_url'],
                "rules": rules_map.get(data['id'], []),
                "secondary_url": data['secondary_url'],
                "synopsis": data['synopsis']
            }

            advisories_list = [] if data.get('advisories_list') is None else data['advisories_list']
            if 'show_advisories_details' in args and args['show_advisories_details'] is True and advisories_list:
                retval["advisories_list"] = GetCves._patch_request_advisories(advisories_list)
            else:
                retval["advisories_list"] = advisories_list
        except IndexError:
            raise ApplicationException('No such CVE ID', 404)
        return retval

    @classmethod
    def _cve_details(cls, synopsis, args):
        retval = cls._get_cve_details(synopsis, args)
        cve_details = (CveAccountData.select(BusinessRisk.name.alias('risk'),
                                             CveAccountData.business_risk_id.alias('risk_id'),
                                             CveAccountData.business_risk_text.alias('risk_text'),
                                             Status.name.alias("status"),
                                             CveAccountData.status_id.alias("status_id"),
                                             CveAccountData.status_text.alias("status_text"))
                       .join(BusinessRisk, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                       .join(Status, on=(CveAccountData.status_id == Status.id))
                       .join(CveMetadata, on=(CveAccountData.cve_id == CveMetadata.id))
                       .where(CveAccountData.rh_account_id == (RHAccount.select(RHAccount.id)
                                                               .where(RHAccount.name == connexion.context['user'])))
                       .where(CveMetadata.cve == synopsis)).dicts()
        if cve_details.count():
            retval['business_risk'] = cve_details[0]['risk']
            retval['business_risk_id'] = cve_details[0]['risk_id']
            retval['business_risk_text'] = cve_details[0]['risk_text']
            retval['status'] = cve_details[0]['status']
            retval['status_id'] = cve_details[0]['status_id']
            retval['status_text'] = cve_details[0]['status_text']
        else:
            retval['business_risk'] = DEFAULT_BUSINESS_RISK
            retval['business_risk_id'] = 0
            retval['business_risk_text'] = None
            retval['status'] = DEFAULT_STATUS
            retval['status_id'] = 0
            retval['status_text'] = None

        # add counts of systems with all statuses
        retval['systems_status_detail'] = {}
        # pylint: disable=singleton-comparison
        rh_account_id = get_account_id(connexion.context['user'])
        status_detail = (
            SystemVulnerabilities
            .select(SystemVulnerabilities.status_id, fn.Count(SystemVulnerabilities.status_id).alias('systems'))
            .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
            .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
            .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
            .where(CveMetadata.cve == synopsis)
            .where(SystemVulnerabilities.rh_account_id == rh_account_id)
            .where((SystemVulnerabilities.mitigation_reason.is_null(True)) | (InsightsRule.active == False))
            .where((SystemVulnerabilities.when_mitigated.is_null(True)) | (InsightsRule.active == True))
            .where((SystemPlatform.opt_out == False)  # noqa: E712
                   & (SystemPlatform.stale == False)  # noqa: E712
                   & (SystemPlatform.when_deleted.is_null(True)))
            .group_by(SystemVulnerabilities.status_id)
            .dicts()
        )
        divergent_systems = 0
        status_detail = cyndi_query(status_detail)
        for row in status_detail:
            retval['systems_status_detail'][row['status_id']] = row['systems']
            if row['status_id'] != retval['status_id']:
                divergent_systems += row['systems']
        retval['systems_status_divergent'] = divergent_systems
        return retval

    @classmethod
    def handle_get(cls, **kwargs):
        res = {}
        args_desc = [{'arg_name': 'show_advisories_details', 'convert_func': None}]
        args = cls._parse_arguments(kwargs, args_desc)
        cve_details = cls._cve_details(kwargs['cve_id'], args)

        patch_access = None
        if cve_details['advisories_list'] is None:
            patch_access = False
        elif args.get('show_advisories_details'):
            patch_access = True

        res['data'] = {
            'attributes': cve_details,
            'id': kwargs['cve_id'],
            'type': 'cve',
            'patch_access': patch_access
        }
        return res


class GetCvesAffectedSystems(GetRequest):
    """GET to /v1/cves/{cve_id}/affected_systems"""

    _endpoint_name = r'/v1/cves/{cve_id}/affected_systems'
    _ids_only = False
    patch_advisories_endpoint = "%s%s" % (PATCH_HOST, PATCH_ADVISORIES_API)

    @staticmethod
    def _patch_request_advisories(inventory_id_list, advisory_id, x_rh_identity, patch_access):
        """Make Patch request for advisories"""
        query = ','.join(inventory_id_list)
        full_endpoint = '%s/%s/systems%s%s' % (GetCvesAffectedSystems.patch_advisories_endpoint, advisory_id,
                                               PATCH_ID_QUERY_FILTER, PATCH_FILTER_PREFIX)
        endpoint_with_query = '%s%s' % (full_endpoint, query)
        advisories_response_json = external_service_request(endpoint_with_query, method='GET', headers={'x-rh-identity': x_rh_identity},
                                                            service_access=patch_access)
        return list(advisories_response_json['data']) if advisories_response_json is not None else None

    @staticmethod
    def _cve_exists(synopsis):
        try:
            (CveMetadata.select(CveMetadata.cve)
             .where(CveMetadata.cve == synopsis)
             .get())
        except DoesNotExist:
            raise ApplicationException('No such CVE ID', 404)

    @classmethod
    def _get_advisories_per_system(cls, advisories_list, inv_ids):
        """Get advisories per system by a specific CVE"""
        with concurrent.futures.ThreadPoolExecutor(max_workers=WORKER_THREADS) as executor:
            patch_access = ServiceAccess(False)
            future_to_advisory = {}
            system_advisories = {inv_id: [] for inv_id in inv_ids}
            x_rh_identity = connexion.request.headers['x-rh-identity']
            if advisories_list is not None and system_advisories:
                for advisory in advisories_list:
                    future_to_advisory[executor.submit(cls._patch_request_advisories, inv_ids, advisory, x_rh_identity, patch_access)] = advisory
                for future in concurrent.futures.as_completed(future_to_advisory):
                    advisory = future_to_advisory[future]
                    try:
                        patch_systems_per_advisory = future.result()
                        if patch_systems_per_advisory is not None:
                            for patch_system in patch_systems_per_advisory:
                                system_advisories[patch_system['id']].append(advisory)
                    except Exception:  # pylint: disable=broad-except
                        FUTURE_ERR.inc()
                        LOGGER.exception("Future %s hit exception: ", future)
        return system_advisories, patch_access

    @staticmethod
    def _build_attributes(sys, system_advisories):
        """Build attributes for response"""
        record = {}
        record['cve_status_id'] = sys['cve_status_id']
        record['inventory_id'] = sys['inventory_id']
        record['display_name'] = sys['display_name']
        record['status_id'] = sys['status_id']
        record['status_name'] = sys['status_name']
        record['status_text'] = sys['status_text']
        record['last_evaluation'] = sys['last_evaluation'].isoformat() if sys['last_evaluation'] else ''
        record['rules_evaluation'] = sys['rules_evaluation'].isoformat() if sys['rules_evaluation'] else None
        record['reporter'] = (reporter.VMAAS.value if not sys['when_mitigated'] else 0) | (reporter.RULE.value if sys['rule_active'] else 0)
        record['rule'] = {
            'details': json.loads(sys['rule_hit_details']) if sys['rule_hit_details'] else {},
            'resolution': {
                'resolution': sys['resolution_text']
            },
            'rule': {
                'description': sys['description_text'],
                'more_info': sys['more_info_text'],
                'node_id': sys['kbase_node_id'],
                'reason': sys['reason_text'],
                'rule_id': sys['rule_id'],
            }
        } if sys['rule_active'] else None
        record['tags'] = sys['tags'] if CYNDI_ENABLED and sys['tags'] is not None else []
        if system_advisories:
            record['advisories_list'] = system_advisories[sys['inventory_id']]
        return record

    @classmethod
    def handle_get(cls, **kwargs):
        """Gets systems affected by a CVE"""
        synopsis = kwargs['cve_id']
        cls._cve_exists(synopsis)
        args_desc = [{'arg_name': 'status_id', 'convert_func': parse_int_list},
                     {'arg_name': 'security_rule', 'convert_func': bool_or_rules_list},
                     {'arg_name': 'uuid', 'convert_func': None},
                     {'arg_name': 'rule_presence', 'convert_func': unique_bool_list},
                     {'arg_name': 'rule_key', 'convert_func': None},
                     {'arg_name': 'tags', 'convert_func': parse_tags},
                     {'arg_name': 'sap_system', 'convert_func': None},
                     {'arg_name': 'show_advisories', 'convert_func': None},
                     {'arg_name': 'advisory', 'convert_func': None},
                     {'arg_name': 'sap_sids', 'convert_func': None}]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)

        # check if advisory parameter comes with show_advisories parameter
        if 'advisory' in args and args['advisory'] and ('show_advisories' not in args or not args['show_advisories']):
            raise ApplicationException("Advisory parameter shouldn't be used without show_advisories parameter", 400)

        rh_account_id = get_account_id(connexion.context['user'])
        asys_view = AffectedSystemsView(rh_account_id, synopsis, list_arguments, args, args, connexion.request.path, cls._ids_only)
        systems = list(asys_view)  # execute query
        inv_ids = [sys['inventory_id'] for sys in systems]

        response = {}
        result = []
        patch_access = None
        total_items = None
        if cls._ids_only:
            if 'advisory' in args and args['advisory']:
                advisories_list = get_advisories_per_cve_from_db(synopsis)
                data, patch_access = cls._get_advisories_per_system(advisories_list, inv_ids)
                system_advisories = filter_by_advisory(args['advisory'], data)
                total_items = len(system_advisories)
                result = [sys['inventory_id'] for sys in systems if sys['inventory_id'] in system_advisories]
            else:
                result = inv_ids
        else:
            system_advisories = {}
            if 'show_advisories' in args and args['show_advisories'] is True:
                advisories_list = get_advisories_per_cve_from_db(synopsis)
                data, patch_access = cls._get_advisories_per_system(advisories_list, inv_ids)
                system_advisories = data
                if 'advisory' in args and args['advisory']:
                    system_advisories = filter_by_advisory(args['advisory'], data)
                    total_items = len(system_advisories)

            for sys in systems:
                if 'advisory' in args and args['advisory'] and 'show_advisories' in args and args['show_advisories']:
                    if sys['inventory_id'] in system_advisories:
                        record = cls._build_attributes(sys, system_advisories)
                        result.append({'type': 'system', 'id': sys['inventory_id'], 'attributes': record})
                else:
                    record = cls._build_attributes(sys, system_advisories)
                    result.append({'type': 'system', 'id': sys['inventory_id'], 'attributes': record})

        response['meta'] = asys_view.get_metadata(total_items)
        response['meta']['patch_access'] = patch_access.status if patch_access else None
        response['links'] = asys_view.get_pagination_links()
        response['data'] = cls._format_data(list_arguments["data_format"], result)
        return response


class GetCvesAffectedSystemsIds(GetCvesAffectedSystems):
    """ GET to /v1/cves/{cve_id}/affected_systems/ids """

    _endpoint_name = r'/v1/cves/{cve_id}/affected_systems/ids'
    _ids_only = True


class PatchCveRisk(PatchRequest):
    """ PATCH to /v1/cves/business_risk"""

    _endpoint_name = r'/v1/cves/business_risk'

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.business_risk_id, CveAccountData.business_risk_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    def handle_patch(cls, **kwargs):
        """Set business risk for a CVE"""
        data = kwargs['data']
        cve_list = data['cve']
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if 'business_risk_id' in data:
            values['business_risk_id'] = data['business_risk_id']
        if 'business_risk_text' in data:
            try:
                values['business_risk_text'] = data['business_risk_text'].strip() \
                                               if data['business_risk_text'].strip() else None
            except AttributeError:
                values['business_risk_text'] = None
        if not values:
            return cls.format_exception(
                'At least one of the "business_risk_id" or "business_risk_text" parameters is required.', 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account = get_or_create_account()
            for cve in cves:
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account[0].id, values.get('business_risk_id', 0),
                                  values.get('business_risk_text', None)))
            if not to_insert:
                return cls.format_exception('At least one given CVE must exist', 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad business_risk_id
            LOGGER.exception('Error during setting business risk (IntegrityError):')
            DB.rollback()
            return cls.format_exception(f"business_risk_id={data['business_risk_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception('Error during setting business risk (ValueError):')
            DB.rollback()
            return cls.format_exception(f'business_risk_text or other key value is invalid ({value_error})', 400)
        return {'updated': updated}


class PatchCveStatus(PatchRequest):
    """ PATCH to /v1/cves/status"""

    _endpoint_name = r'/v1/cves/status'

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.status_id, CveAccountData.status_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    def handle_patch(cls, **kwargs):
        """Set status for a CVE"""
        data = kwargs['data']
        cve_list = data['cve']
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if 'status_id' in data:
            values['status_id'] = data['status_id']
        if 'status_text' in data:
            try:
                values['status_text'] = data['status_text'].strip() \
                                        if data['status_text'].strip() else None
            except AttributeError:
                values['status_text'] = None
        if not values:
            return cls.format_exception(
                'At least one of the "status_id" or "status_text" parameters is required.', 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account = get_or_create_account()
            for cve in cves:
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account[0].id, values.get('status_id', 0), values.get('status_text', None)))
            if not to_insert:
                return cls.format_exception('At least one given CVE must exist', 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad status
            LOGGER.exception('Error during setting status (IntegrityError):')
            DB.rollback()
            return cls.format_exception(f"status_id={data['status_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception('Error during setting status (ValueError):')
            DB.rollback()
            return cls.format_exception(f'status_text or other key value is invalid ({value_error})', 400)
        return {'updated': updated}
