"""
Module for /cves API endpoint
"""
import json
from datetime import datetime
from datetime import timezone

import connexion
import dateutil.parser
from peewee import DataError
from peewee import DoesNotExist
from peewee import fn
from peewee import IntegrityError
from peewee import JOIN
from peewee import SQL
from peewee import Value
from psycopg2 import IntegrityError as psycopg2IntegrityError

from .base import ApplicationException
from .base import cyndi_join
from .base import DEFAULT_BUSINESS_RISK
from .base import DEFAULT_STATUS
from .base import edge_feature_arg
from .base import get_account_data
from .base import get_or_create_account
from .base import get_rules_for_cves
from .base import GetRequest
from .base import OS_INFO_QUERY
from .base import OS_INFO_SORT
from .base import parse_int_list
from .base import parse_str_list
from .base import parse_tags
from .base import PatchRequest
from .base import reporter
from .base import transform_ids
from .base import transform_names
from .base import unique_bool_list
from .filters import apply_filters
from .filters import filter_types
from .list_view import ListView
from .rbac_manager import RbacFilterRoutePermissions
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions
from common.config import Config
from common.constants import remediation
from common.feature_flags import UNLEASH
from common.logging import get_logger
from common.peewee_conditions import system_is_abnv
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import BusinessRisk
from common.peewee_model import CveAccountData
from common.peewee_model import CveImpact
from common.peewee_model import CveMetadata
from common.peewee_model import DB
from common.peewee_model import InsightsRule
from common.peewee_model import InventoryHosts
from common.peewee_model import RHAccount
from common.peewee_model import Status
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities
from common.peewee_model import SystemVulnerablePackage
from common.peewee_model import VulnerablePackageCVE
from common.utils import format_datetime
from common.utils import str_or_none

LOGGER = get_logger(__name__)
CFG = Config()


class SystemCvesView(ListView):
    """Database select for /cves/{cve_id}/affected_systems API endpoints"""

    def __init__(self, account_data, synopsis, list_args, parsed_args, uri, ids_only=False):
        filters = [filter_types.SYSTEM_CVE_RULE,
                   filter_types.SYSTEM_CVE_STATUS,
                   filter_types.SYSTEM_VULNERABILITES_BY_ADVISORY,
                   filter_types.SYSTEM_CVE_FIRST_REPORTED,
                   filter_types.SYSTEM_CVE_RULE_KEY,
                   filter_types.SYSTEM_CVE_RULE_PRESENCE,
                   filter_types.SYSTEM_CVE_REMEDIATION,
                   filter_types.SYSTEM_UUID,
                   filter_types.SYSTEM_TAGS,
                   filter_types.SYSTEM_SAP,
                   filter_types.SYSTEM_SAP_SIDS,
                   filter_types.SYSTEM_RHEL_VERSION,
                   filter_types.SYSTEM_AAP,
                   filter_types.SYSTEM_MSSQL,
                   filter_types.INVENTORY_GROUP_NAMES,
                   filter_types.INVENTORY_GROUP_IDS,
                   filter_types.HOST_TYPE,
                   ]

        if not account_data.cves_without_errata:
            query = (self._full_query(account_data.id, synopsis, parsed_args, filters) if not ids_only
                     else self._id_query(account_data.id, synopsis, parsed_args, filters))
        else:
            query = (self._unpatched_full_query(account_data.id, synopsis, parsed_args, filters) if not ids_only
                     else self._unpatched_id_query(account_data.id, synopsis, parsed_args, filters))
        if not ids_only:
            query = query.select_from(
                query.c.cve_status_id,
                query.c.id,
                query.c.inventory_id,
                query.c.display_name,
                query.c.last_evaluation,
                query.c.rules_evaluation,
                query.c.last_upload,
                query.c.stale_timestamp,
                query.c.stale_warning_timestamp,
                query.c.culled_timestamp,
                query.c.status_id,
                query.c.status_name,
                query.c.status_text,
                query.c.rule_hit_details,
                query.c.when_mitigated,
                query.c.first_reported,
                query.c.mitigation_reason,
                query.c.advisories,
                query.c.rule_id,
                query.c.rule_active,
                query.c.description_text,
                query.c.reason_text,
                query.c.resolution_text,
                query.c.kbase_node_id,
                query.c.more_info_text,
                query.c.tags,
                query.c.updated,
                query.c.insights_id,
                query.c.inventory_group,
                query.c.system_profile,
                query.c.os,
                query.c.advisory_available,
                query.c.remediation_type_id,
            )
        else:
            query = query.select_from(
                query.c.id,
                query.c.inventory_id,
                query.c.rule_id,
                query.c.status_id,
                query.c.status_text,
                query.c.display_name,
                query.c.mitigation_reason,
                query.c.remediation,
                query.c.tags,
                query.c.updated,
                query.c.insights_id,
                query.c.inventory_group,
            )
        query = query.dicts()

        sortable_columns = {
            "display_name": SQL("display_name"),
            "id": SQL("id"),
            "inventory_id": SQL("inventory_id"),
            "inventory_group": [
                # put Ungrouped first
                SQL("inventory_group->0->>'name' IS NOT NULL"),
                SQL("inventory_group->0->>'name'")
            ],
            "last_evaluation": SQL("last_evaluation"),
            "last_upload": SQL("last_upload"),
            "rules_evaluation": SQL("rules_evaluation"),
            "status_id": SQL("status_id"),
            "status": SQL("status_id"),
            "updated": SQL("updated"),
            "first_reported": SQL("first_reported"),
            "os": OS_INFO_SORT,
            "advisory_available": SQL("advisory_available"),
            "remediation": SQL("remediation_type_id"),
            "advisories_list": SQL("advisories"),
        }
        default_sort_columns = {
            "default": ["-updated", "id"],
        }
        filterable_columns = {
            "display_name": SQL("display_name")
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id, synopsis, parsed_args, filters):
        """To be implemented in child classes"""
        raise NotImplementedError

    @staticmethod
    def _unpatched_full_query(rh_account_id, synopsis, parsed_args, filters):
        """To be implemented in child classes"""
        raise NotImplementedError

    @staticmethod
    def _id_query(rh_account_id, synopsis, parsed_args, filters):
        """To be implemented in child classes"""
        raise NotImplementedError

    @staticmethod
    def _unpatched_id_query(rh_account_id, synopsis, parsed_args, filters):
        """To be implemented in child classes"""
        raise NotImplementedError


class AffectedSystemsView(SystemCvesView):
    """Database select queries for /cves/{cve_id}/affected_systems API endpoint"""

    @staticmethod
    def _full_query(rh_account_id, synopsis, parsed_args, filters):
        # pylint: disable=singleton-comparison
        selectables = [fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                       SystemPlatform.id,
                       SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias("rules_evaluation"),
                       SystemPlatform.last_upload,
                       SystemPlatform.stale_timestamp,
                       SystemPlatform.stale_warning_timestamp,
                       SystemPlatform.culled_timestamp,
                       Status.id.alias("status_id"),
                       Status.name.alias("status_name"),
                       SystemVulnerabilities.status_text.alias("status_text"),
                       SystemVulnerabilities.rule_hit_details,
                       SystemVulnerabilities.when_mitigated,
                       SystemVulnerabilities.first_reported,
                       SystemVulnerabilities.mitigation_reason,
                       SystemVulnerabilities.advisories,
                       InsightsRule.name.alias("rule_id"),
                       InsightsRule.active.alias("rule_active"),
                       InsightsRule.description_text,
                       InsightsRule.reason_text,
                       InsightsRule.resolution_text,
                       InsightsRule.kbase_node_id,
                       InsightsRule.more_info_text,
                       InventoryHosts.tags,
                       InventoryHosts.updated,
                       InventoryHosts.insights_id,
                       InventoryHosts.groups.alias("inventory_group"),
                       InventoryHosts.system_profile,
                       OS_INFO_QUERY.alias("os"),
                       fn.COALESCE(SystemVulnerabilities.advisory_available, True).alias("advisory_available"),
                       fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation_type_id"),
                       ]

        subq = (SystemVulnerabilities
                .select(*selectables)
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.rh_account_id == rh_account_id)
                                                           & (CveMetadata.id == CveAccountData.cve_id)))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg()))
                .where(system_is_vulnerable(rule_subselect=False)))

        subq = cyndi_join(subq)
        return apply_filters(subq, parsed_args, filters, {})

    @staticmethod
    def _unpatched_full_query(rh_account_id, synopsis, parsed_args, filters):
        # pylint: disable=singleton-comparison
        fixed_subq = AffectedSystemsView._full_query(rh_account_id, synopsis, parsed_args, filters)

        unfixed_subq = (SystemVulnerablePackage
                        .select(fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                                SystemPlatform.id,
                                SystemPlatform.inventory_id,
                                SystemPlatform.display_name,
                                SystemPlatform.last_evaluation,
                                SystemPlatform.advisor_evaluated.alias("rules_evaluation"),
                                SystemPlatform.last_upload,
                                SystemPlatform.stale_timestamp,
                                SystemPlatform.stale_warning_timestamp,
                                SystemPlatform.culled_timestamp,
                                Value(0).alias("status_id"),
                                Value("Not Reviewed").alias("status_name"),
                                Value(None).alias("status_text"),
                                Value(None).alias("rule_hit_details"),
                                Value(datetime.min).alias("when_mitigated"),
                                SystemVulnerablePackage.first_reported,
                                Value(None).alias("mitigation_reason"),
                                Value(None).alias("advisories"),
                                Value(None).alias("rule_id"),
                                Value(False).alias("rule_active"),
                                Value(None).alias("description_text"),
                                Value(None).alias("reason_text"),
                                Value(None).alias("resolution_text"),
                                Value(0).alias("kbase_node_id"),
                                Value(None).alias("more_info_text"),
                                InventoryHosts.tags,
                                InventoryHosts.updated,
                                InventoryHosts.insights_id,
                                InventoryHosts.groups.alias("inventory_group"),
                                InventoryHosts.system_profile,
                                OS_INFO_QUERY.alias("os"),
                                Value(False).alias("advisory_available"),
                                Value(remediation.NONE.value).alias("remediation_type_id"),
                                )
                        .distinct()
                        .join(SystemPlatform, on=(SystemVulnerablePackage.system_id == SystemPlatform.id))
                        .join(VulnerablePackageCVE, on=(SystemVulnerablePackage.vulnerable_package_id == VulnerablePackageCVE.vulnerable_package_id))
                        .join(CveMetadata, on=(VulnerablePackageCVE.cve_id == CveMetadata.id))
                        .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.rh_account_id == rh_account_id) &
                              (CveMetadata.id == CveAccountData.cve_id)))
                        .where(CveMetadata.cve == synopsis)
                        .where(system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg()))
                        .where(SystemVulnerablePackage.rh_account_id == rh_account_id))
        unfixed_subq = cyndi_join(unfixed_subq)
        unfixed_subq = apply_filters(unfixed_subq, parsed_args, filters, {"unfixed": [True]})

        advisory_available = parsed_args["advisory_available"]
        if advisory_available is None or (False in advisory_available and True in advisory_available):
            return (fixed_subq + unfixed_subq)
        elif False in advisory_available:
            return unfixed_subq
        else:
            return fixed_subq

    @staticmethod
    def _id_query(rh_account_id, synopsis, parsed_args, filters):
        # pylint: disable=singleton-comparison
        subq = (SystemVulnerabilities
                .select(SystemPlatform.id,
                        SystemPlatform.inventory_id,
                        InsightsRule.name.alias("rule_id"),
                        SystemVulnerabilities.status_id.alias("status_id"),
                        SystemVulnerabilities.status_text.alias("status_text"),
                        SystemPlatform.display_name.alias("display_name"),
                        SystemVulnerabilities.mitigation_reason,
                        fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation"),
                        InventoryHosts.tags,
                        InventoryHosts.updated,
                        InventoryHosts.insights_id,
                        InventoryHosts.groups.alias("inventory_group"),
                        )
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg()))
                .where(system_is_vulnerable(rule_subselect=False)))

        subq = cyndi_join(subq)
        return apply_filters(subq, parsed_args, filters, {})

    @staticmethod
    def _unpatched_id_query(rh_account_id, synopsis, parsed_args, filters):
        # pylint: disable=singleton-comparison
        fixed_subq = AffectedSystemsView._id_query(rh_account_id, synopsis, parsed_args, filters)

        unfixed_subq = (SystemVulnerablePackage
                        .select(SystemPlatform.id,
                                SystemPlatform.inventory_id,
                                Value(None).alias("rule_id"),
                                Value(0).alias("status_id"),
                                Value(None).alias("status_text"),
                                SystemPlatform.display_name.alias("display_name"),
                                Value(None).alias("mitigation_reason"),
                                Value(remediation.NONE.value).alias("remediation"),
                                InventoryHosts.tags,
                                InventoryHosts.updated,
                                InventoryHosts.insights_id,
                                InventoryHosts.groups.alias("inventory_group"),
                                )
                        .distinct()
                        .join(SystemPlatform, on=(SystemVulnerablePackage.system_id == SystemPlatform.id))
                        .join(VulnerablePackageCVE, on=(SystemVulnerablePackage.vulnerable_package_id == VulnerablePackageCVE.vulnerable_package_id))
                        .join(CveMetadata, on=(VulnerablePackageCVE.cve_id == CveMetadata.id))
                        .where(CveMetadata.cve == synopsis)
                        .where(SystemVulnerablePackage.rh_account_id == rh_account_id)
                        .where(system_is_active(rh_account_id=rh_account_id, edge=edge_feature_arg())))

        unfixed_subq = cyndi_join(unfixed_subq)
        unfixed_subq = apply_filters(unfixed_subq, parsed_args, filters, {"unfixed": [True]})

        advisory_available = parsed_args["advisory_available"]
        if advisory_available is None or (False in advisory_available and True in advisory_available):
            return (fixed_subq + unfixed_subq)
        elif False in advisory_available:
            return unfixed_subq
        else:
            return fixed_subq


class GetCves(GetRequest):
    """GET to /v1/cves/{cve_id}"""

    _endpoint_name = r"/v1/cves/{cve_id}"

    @staticmethod
    def _get_cve_details(synopsis):
        try:
            data = (CveMetadata.select(CveImpact.name.alias("impact"), CveMetadata.cve.alias("synopsis"),
                                       CveMetadata.description, CveMetadata.cvss2_metrics,
                                       CveMetadata.cvss2_score, CveMetadata.cvss3_score,
                                       CveMetadata.cvss3_metrics, CveMetadata.modified_date, CveMetadata.celebrity_name,
                                       CveMetadata.public_date, CveMetadata.redhat_url,
                                       CveMetadata.secondary_url, CveMetadata.id, CveMetadata.advisories_list,
                                       CveMetadata.exploit_data)
                    .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                    .where(CveMetadata.cve == synopsis)).dicts()[0]
            rules_map = get_rules_for_cves([data["id"]], connexion.context["user"], edge=edge_feature_arg())
            retval = {
                "celebrity_name": str_or_none(data["celebrity_name"]),
                "cvss2_metrics": str_or_none(data["cvss2_metrics"]),
                "cvss2_score": str_or_none(data["cvss2_score"]),
                "cvss3_metrics": str_or_none(data["cvss3_metrics"]),
                "cvss3_score": str_or_none(data["cvss3_score"]),
                "description": data["description"],
                "impact": data["impact"],
                "public_date": format_datetime(data["public_date"]),
                "modified_date": format_datetime(data["modified_date"]),
                "redhat_url": data["redhat_url"],
                "rules": rules_map.get(data["id"], []),
                "secondary_url": data["secondary_url"],
                "synopsis": data["synopsis"],
                "known_exploit": data["exploit_data"] is not None and bool(data["advisories_list"]),
                "advisories_list": data.get("advisories_list") or [],
            }
        except IndexError as exc:
            raise ApplicationException("No such CVE ID", 404) from exc
        return retval

    @classmethod
    def _cve_details(cls, synopsis, advisory_available):
        retval = cls._get_cve_details(synopsis)
        rh_account_id = get_account_data(connexion.context["user"]).id
        cve_details = (CveAccountData.select(BusinessRisk.name.alias("risk"),
                                             CveAccountData.business_risk_id.alias("risk_id"),
                                             CveAccountData.business_risk_text.alias("risk_text"),
                                             Status.name.alias("status"),
                                             CveAccountData.status_id.alias("status_id"),
                                             CveAccountData.status_text.alias("status_text"))
                       .join(BusinessRisk, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                       .join(Status, on=(CveAccountData.status_id == Status.id))
                       .join(CveMetadata, on=(CveAccountData.cve_id == CveMetadata.id))
                       .where(CveAccountData.rh_account_id == rh_account_id)
                       .where(CveMetadata.cve == synopsis)).dicts()
        if cve_details.count():
            retval["business_risk"] = cve_details[0]["risk"]
            retval["business_risk_id"] = cve_details[0]["risk_id"]
            retval["business_risk_text"] = cve_details[0]["risk_text"]
            retval["status"] = cve_details[0]["status"]
            retval["status_id"] = cve_details[0]["status_id"]
            retval["status_text"] = cve_details[0]["status_text"]
        else:
            retval["business_risk"] = DEFAULT_BUSINESS_RISK
            retval["business_risk_id"] = 0
            retval["business_risk_text"] = None
            retval["status"] = DEFAULT_STATUS
            retval["status_id"] = 0
            retval["status_text"] = None

        # argument for controling host types in system counts
        edge = edge_feature_arg()

        # affected but not vulnerable systems count
        # pylint: disable=singleton-comparison
        not_vulnerable = (SystemVulnerabilities
                          .select(fn.Count(SystemVulnerabilities.id))
                          .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                          .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                          .join(InsightsRule, on=(SystemVulnerabilities.rule_id == InsightsRule.id))
                          .where((SystemVulnerabilities.rh_account_id == rh_account_id))
                          .where(CveMetadata.cve == synopsis)
                          .where(system_is_active(rh_account_id=rh_account_id, edge=edge))
                          .where(system_is_abnv()))
        not_vulnerable = cyndi_join(not_vulnerable)
        retval["affected_but_not_vulnerable"] = not_vulnerable.scalar()

        # add counts of systems with all statuses
        retval["systems_status_detail"] = {}
        # pylint: disable=singleton-comparison

        status_detail_fixed = (SystemVulnerabilities
                               .select(SystemVulnerabilities.status_id, fn.Count(SystemVulnerabilities.status_id).alias("systems"))
                               .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                               .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                               .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                               .where(CveMetadata.cve == synopsis)
                               .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                               .where(system_is_active(rh_account_id=rh_account_id, edge=edge))
                               .where(system_is_vulnerable())
                               .group_by(SystemVulnerabilities.status_id)
                               .dicts())
        status_detail_fixed = cyndi_join(status_detail_fixed)

        status_detail_unfixed = (SystemVulnerablePackage
                                 .select(Value(0).alias("status_id"), fn.Count(SystemVulnerablePackage.id).alias("systems"))
                                 .join(SystemPlatform, on=(SystemVulnerablePackage.system_id == SystemPlatform.id))
                                 .join(VulnerablePackageCVE, on=(SystemVulnerablePackage.vulnerable_package_id == VulnerablePackageCVE.vulnerable_package_id))
                                 .join(CveMetadata, on=(VulnerablePackageCVE.cve_id == CveMetadata.id))
                                 .where(CveMetadata.cve == synopsis)
                                 .where(SystemVulnerablePackage.rh_account_id == rh_account_id)
                                 .where(system_is_active(rh_account_id=rh_account_id, edge=edge))
                                 .dicts())
        status_detail_unfixed = cyndi_join(status_detail_unfixed)

        if advisory_available is None or (False in advisory_available and True in advisory_available):
            status_detail = (status_detail_fixed + status_detail_unfixed).dicts()
        elif False in advisory_available:
            status_detail = status_detail_unfixed
        else:
            status_detail = status_detail_fixed

        divergent_systems = 0
        for row in status_detail:
            retval["systems_status_detail"].setdefault(row["status_id"], 0)
            retval["systems_status_detail"][row["status_id"]] += row["systems"]
            if row["status_id"] != retval["status_id"]:
                divergent_systems += row["systems"]
        retval["systems_status_divergent"] = divergent_systems
        return retval

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.CSV_FORMAT_ENDPOINTS)
    def handle_get(cls, **kwargs):
        res = {}
        cve_details = cls._cve_details(kwargs["cve_id"], kwargs.get("advisory_available", None))

        res["data"] = {
            "attributes": cve_details,
            "id": kwargs["cve_id"],
            "type": "cve",
        }
        return res


class GetCveSystems(GetRequest):
    """Parent class for {affected,mitigated}_systems endpoints"""

    _DB_View = AffectedSystemsView
    _ids_only = False

    @staticmethod
    def _build_attributes(sys, advisories_list=None):
        """To be implemented by child classes"""
        raise NotImplementedError

    @staticmethod
    def _cve_exists(synopsis):
        try:
            (CveMetadata.select(CveMetadata.cve)
             .where(CveMetadata.cve == synopsis)
             .get())
        except DoesNotExist as exc:
            raise ApplicationException("No such CVE ID", 404) from exc

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.REPORTABLE_ENDPOINTS)
    def handle_get(cls, **kwargs):  # pylint: disable=too-many-branches
        """Gets systems affected by a CVE"""
        synopsis = kwargs["cve_id"]
        cls._cve_exists(synopsis)
        args_desc = [{"arg_name": "status_id", "convert_func": parse_int_list},
                     {"arg_name": "uuid", "convert_func": None},
                     {"arg_name": "rule_presence", "convert_func": unique_bool_list},
                     {"arg_name": "rule_key", "convert_func": None},
                     {"arg_name": "tags", "convert_func": parse_tags},
                     {"arg_name": "sap_system", "convert_func": None},
                     {"arg_name": "show_advisories", "convert_func": None},
                     {"arg_name": "advisory", "convert_func": None},
                     {"arg_name": "sap_sids", "convert_func": None},
                     {"arg_name": "rhel_version", "convert_func": parse_str_list},
                     {"arg_name": "first_reported_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "first_reported_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "rule", "convert_func": None},
                     {"arg_name": "advisory_available", "convert_func": unique_bool_list},
                     {"arg_name": "remediation", "convert_func": parse_int_list},
                     {"arg_name": "ansible", "convert_func": None},
                     {"arg_name": "mssql", "convert_func": None},
                     {"arg_name": "group_ids", "convert_func": transform_ids},
                     {"arg_name": "group_names", "convert_func": transform_names},
                     {"arg_name": "host_type", "convert_func": None},
                     ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)

        account_data = get_account_data(connexion.context["user"])

        asys_view = cls._DB_View(account_data, synopsis, list_arguments, args, connexion.request.path, cls._ids_only)
        systems = list(asys_view)  # execute query

        response = {}
        result = []
        if cls._ids_only:
            result = cls.remove_system_keys(systems)
        else:
            for sys in systems:
                record = cls._build_attributes(sys)
                result.append({"type": "system", "id": sys["inventory_id"], "attributes": record})

        response["meta"] = asys_view.get_metadata()
        response["meta"]["patch_access"] = True  # remove patch_access in response
        response["meta"]["cves_without_errata"] = account_data.cves_without_errata
        response["links"] = asys_view.get_pagination_links()
        response["data"] = cls._format_data(list_arguments["data_format"], result, ids_only=cls._ids_only)
        return response

    @staticmethod
    def remove_system_keys(systems):
        # Removes keys not needed in the end result from systems
        keys = [
            "id",
            "updated",
            "tags",
            "insights_id",
            "inventory_group"
        ]

        for sys in systems:
            for key in keys:
                if key in sys:
                    del sys[key]

        return systems


class GetCvesAffectedSystems(GetCveSystems):
    """GET to /v1/cves/{cve_id}/affected_systems"""

    _endpoint_name = r"/v1/cves/{cve_id}/affected_systems"

    @staticmethod
    def _build_attributes(sys, advisories_list=None):
        """Build attributes for response"""
        record = {}
        record["cve_status_id"] = sys["cve_status_id"]
        record["inventory_id"] = sys["inventory_id"]
        record["insights_id"] = sys["insights_id"]
        record["display_name"] = sys["display_name"]
        record["mitigation_reason"] = sys["mitigation_reason"]
        record["status_id"] = sys["status_id"]
        record["status_name"] = sys["status_name"]
        record["status_text"] = sys["status_text"]
        record["last_evaluation"] = sys["last_evaluation"].isoformat() if sys["last_evaluation"] else ""
        record["rules_evaluation"] = sys["rules_evaluation"].isoformat() if sys["rules_evaluation"] else None
        record["reporter"] = (reporter.VMAAS.value if not sys["when_mitigated"] else 0) | (reporter.RULE.value if sys["rule_active"] else 0)
        record["rule"] = {
            "details": json.loads(sys["rule_hit_details"]) if sys["rule_hit_details"] else {},
            "resolution": {
                "resolution": sys["resolution_text"]
            },
            "rule": {
                "description": sys["description_text"],
                "more_info": sys["more_info_text"],
                "node_id": sys["kbase_node_id"],
                "reason": sys["reason_text"],
                "rule_id": sys["rule_id"],
            }
        } if sys["rule_active"] else None
        record["tags"] = sys["tags"] if sys["tags"] is not None else []
        if UNLEASH.is_enabled("vulnerability.cves_without_errata") or sys["remediation_type_id"] == 2:  # playbook
            record["advisories_list"] = sys["advisories"].split(",") if sys["advisories"] is not None else []
        else:
            record["advisories_list"] = []
        record["updated"] = sys["updated"]
        record["os"] = sys.get("os", "N/A")
        record["first_reported"] = sys["first_reported"].isoformat()
        # Defaults to True and playbook - backwards compatibility for NULL values
        record["advisory_available"] = sys["advisory_available"]
        record["remediation"] = sys["remediation_type_id"]
        record["stale_timestamp"] = sys["stale_timestamp"].isoformat() if sys["stale_timestamp"] else None
        record["stale_warning_timestamp"] = sys["stale_warning_timestamp"].isoformat() if sys["stale_warning_timestamp"] else None
        record["culled_timestamp"] = sys["culled_timestamp"].isoformat() if sys["culled_timestamp"] else None
        record["inventory_group"] = sys.get("inventory_group", [])
        return record


class GetCvesAffectedSystemsIds(GetCvesAffectedSystems):
    """ GET to /v1/cves/{cve_id}/affected_systems/ids """

    _endpoint_name = r"/v1/cves/{cve_id}/affected_systems/ids"
    _ids_only = True


class PatchCveRisk(PatchRequest):
    """ PATCH to /v1/cves/business_risk"""

    _endpoint_name = r"/v1/cves/business_risk"

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.business_risk_id, CveAccountData.business_risk_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.CVE_BR_AND_STATUS_EDIT)
    def handle_patch(cls, **kwargs):
        """Set business risk for a CVE"""
        data = kwargs["data"]
        cve_list = data["cve"]
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if "business_risk_id" in data:
            values["business_risk_id"] = data["business_risk_id"]
        if "business_risk_text" in data:
            try:
                values["business_risk_text"] = data["business_risk_text"].strip() \
                    if data["business_risk_text"].strip() else None
            except AttributeError:
                values["business_risk_text"] = None
        if not values:
            return cls.format_exception(
                "At least one of the 'business_risk_id' or 'business_risk_text' parameters is required.", 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account_id = get_or_create_account()
            for cve in cves:  # pylint: disable=not-an-iterable
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account_id, values.get("business_risk_id", 0),
                                  values.get("business_risk_text", None)))
            if not to_insert:
                return cls.format_exception("At least one given CVE must exist", 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad business_risk_id
            LOGGER.exception("Error during setting business risk (IntegrityError):")
            DB.rollback()
            return cls.format_exception(f"business_risk_id={data['business_risk_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception("Error during setting business risk (ValueError):")
            DB.rollback()
            return cls.format_exception(f"business_risk_text or other key value is invalid ({value_error})", 400)
        return {"updated": updated}


class PatchCveStatus(PatchRequest):
    """ PATCH to /v1/cves/status"""

    _endpoint_name = r"/v1/cves/status"

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.status_id, CveAccountData.status_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.CVE_BR_AND_STATUS_EDIT)
    def handle_patch(cls, **kwargs):
        """Set status for a CVE"""
        data = kwargs["data"]
        cve_list = data["cve"]
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if "status_id" in data:
            values["status_id"] = data["status_id"]
        if "status_text" in data:
            try:
                values["status_text"] = data["status_text"].strip() \
                    if data["status_text"].strip() else None
            except AttributeError:
                values["status_text"] = None
        if not values:
            return cls.format_exception(
                "At least one of the 'status_id' or 'status_text' parameters is required.", 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account_id = get_or_create_account()
            for cve in cves:  # pylint: disable=not-an-iterable
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account_id, values.get("status_id", 0), values.get("status_text", None)))
            if not to_insert:
                return cls.format_exception("At least one given CVE must exist", 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
            RHAccount.update(last_status_change=datetime.now(timezone.utc)).where(RHAccount.id == rh_account_id).execute()
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad status
            LOGGER.exception("Error during setting status (IntegrityError):")
            DB.rollback()
            return cls.format_exception(f"status_id={data['status_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception("Error during setting status (ValueError):")
            DB.rollback()
            return cls.format_exception(f"status_text or other key value is invalid ({value_error})", 400)
        return {"updated": updated}
