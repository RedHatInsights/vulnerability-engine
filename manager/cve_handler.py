"""
Module for /cves API endpoint
"""

import connexion
from peewee import DoesNotExist, IntegrityError
from psycopg2 import IntegrityError as psycopg2IntegrityError

from common.logging import get_logger
from common.utils import str_or_none, format_datetime
from common.peewee_model import BusinessRisk, CveAccountData, CveMetadata, DB, RHAccount, \
    Status, SystemPlatform, SystemVulnerabilities, CveImpact
from .base import ApplicationException, DEFAULT_BUSINESS_RISK, DEFAULT_STATUS, GetRequest, parse_int_list, PatchRequest
from .list_view import ListView

LOGGER = get_logger(__name__)


class AffectedSystemsView(ListView):
    """Database select for /cves API endpoint"""

    def __init__(self, synopsis, list_args, query_args, filter_args, parsed_args, uri):
        # pylint: disable=singleton-comparison
        query = (
            SystemVulnerabilities
            .select(SystemPlatform.inventory_id,
                    SystemPlatform.last_evaluation,
                    Status.id.alias('status_id'),
                    Status.name.alias('status_name'),
                    SystemVulnerabilities.status_text.alias('status_text'))
            .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
            .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
            .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
            .join(RHAccount, on=(SystemPlatform.rh_account_id == RHAccount.id))
            .where(CveMetadata.cve == synopsis)
            .where(RHAccount.name == query_args['rh_account_number'])
            .where(SystemVulnerabilities.when_mitigated.is_null(True))
            .where(SystemPlatform.opt_out == False)  # noqa: E712
        )

        if 'status_id' in filter_args and filter_args['status_id']:
            query = query.where(Status.id << filter_args['status_id'])

        query = query.dicts()

        sortable_columns = {
            'id': SystemPlatform.id,
            'inventory_id': SystemPlatform.inventory_id,
            'last_evaluation': SystemPlatform.last_evaluation,
            'status_id': Status.id,
            'status': Status.id
        }
        default_sort_columns = ['id']
        filterable_columns = {
            'inventory_id': SystemPlatform.inventory_id
        }
        super(AffectedSystemsView, self).__init__(query, sortable_columns, default_sort_columns,
                                                  filterable_columns, list_args, parsed_args, uri)


class GetCves(GetRequest):
    """GET to /v1/cves/{cve_id}"""

    @staticmethod
    def _get_cve_details(synopsis):
        try:
            data = (CveMetadata.select(CveImpact.name.alias('impact'), CveMetadata.cve.alias('synopsis'),
                                       CveMetadata.description, CveMetadata.cvss2_metrics,
                                       CveMetadata.cvss2_score, CveMetadata.cvss3_score,
                                       CveMetadata.cvss3_metrics, CveMetadata.modified_date,
                                       CveMetadata.public_date, CveMetadata.redhat_url,
                                       CveMetadata.secondary_url)
                    .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                    .where(CveMetadata.cve == synopsis)).dicts()[0]
            return {
                "cvss2_metrics": str_or_none(data['cvss2_metrics']),
                "cvss2_score": str_or_none(data['cvss2_score']),
                "cvss3_metrics": str_or_none(data['cvss3_metrics']),
                "cvss3_score": str_or_none(data['cvss3_score']),
                "description": data['description'],
                "impact": data['impact'],
                "public_date": format_datetime(data['public_date']),
                "modified_date": format_datetime(data['modified_date']),
                "redhat_url": data['redhat_url'],
                "secondary_url": data['secondary_url'],
                "synopsis": data['synopsis'],
            }
        except IndexError:
            raise ApplicationException('No such CVE ID', 404)

    @classmethod
    def _cve_details(cls, synopsis):
        retval = cls._get_cve_details(synopsis)
        cve_details = (CveAccountData.select(BusinessRisk.name.alias('risk'),
                                             CveAccountData.business_risk_id.alias('risk_id'),
                                             CveAccountData.business_risk_text.alias('risk_text'),
                                             Status.name.alias("status"),
                                             CveAccountData.status_id.alias("status_id"),
                                             CveAccountData.status_text.alias("status_text"))
                       .join(BusinessRisk, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                       .join(Status, on=(CveAccountData.status_id == Status.id))
                       .join(CveMetadata, on=(CveAccountData.cve_id == CveMetadata.id))
                       .where(CveAccountData.rh_account_id == (RHAccount.select(RHAccount.id)
                                                               .where(RHAccount.name == connexion.context['user'])))
                       .where(CveMetadata.cve == synopsis)).dicts()
        if cve_details.count():
            retval['business_risk'] = cve_details[0]['risk']
            retval['business_risk_id'] = cve_details[0]['risk_id']
            retval['business_risk_text'] = cve_details[0]['risk_text']
            retval['status'] = cve_details[0]['status']
            retval['status_id'] = cve_details[0]['status_id']
            retval['status_text'] = cve_details[0]['status_text']
        else:
            retval['business_risk'] = DEFAULT_BUSINESS_RISK
            retval['business_risk_id'] = 0
            retval['business_risk_text'] = None
            retval['status'] = DEFAULT_STATUS
            retval['status_id'] = 0
            retval['status_text'] = None
        return retval

    @classmethod
    def handle_get(cls, **kwargs):
        res = {}
        res['data'] = {'attributes': cls._cve_details(kwargs['cve_id']), 'id': kwargs['cve_id'], 'type': 'cve'}
        return res


class GetCvesAffectedSystems(GetRequest):
    """GET to /v1/cves/{cve_id}/affected_systems"""

    _endpoint_name = r'/v1/cves/{cve_id}/affected_systems'

    @staticmethod
    def _cve_exists(synopsis):
        try:
            (CveMetadata.select(CveMetadata.cve)
             .where(CveMetadata.cve == synopsis)
             .get())
        except DoesNotExist:
            raise ApplicationException('No such CVE ID', 404)

    @classmethod
    def handle_get(cls, **kwargs):
        """Gets systems affected by a CVE"""
        synopsis = kwargs['cve_id']
        cls._cve_exists(synopsis)
        args_desc = [{'arg_name': 'status_id', 'convert_func': parse_int_list}]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)
        asys_view = AffectedSystemsView(synopsis,
                                        list_arguments, {"rh_account_number": connexion.context['user']},
                                        args, args, connexion.request.path)

        response = {}
        result = []
        for sys in asys_view:
            record = {}
            # TODO:
            # result prob can be just {'type':'system', 'id':<inventory_id>}
            record['inventory_id'] = sys['inventory_id']
            record['status_id'] = sys['status_id']
            record['status_name'] = sys['status_name']
            record['status_text'] = sys['status_text']
            record['last_evaluation'] = sys['last_evaluation'].isoformat() if sys['last_evaluation'] else ''
            result.append({'type': 'system', 'id': sys['inventory_id'], 'attributes': record})
        response['meta'] = asys_view.get_metadata()
        response['links'] = asys_view.get_pagination_links()
        response['data'] = cls._format_data(list_arguments["data_format"], result)
        return response


class PatchCveRisk(PatchRequest):
    """ PATCH to /v1/cves/business_risk"""

    _endpoint_name = r'/v1/cves/business_risk'

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.business_risk, CveAccountData.business_risk_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    def handle_patch(cls, **kwargs):
        """Set business risk for a CVE"""
        data = kwargs['data']
        cve_list = data['cve']
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if 'business_risk_id' in data:
            values['business_risk_id'] = data['business_risk_id']
        if 'business_risk_text' in data:
            values['business_risk_text'] = data['business_risk_text'].strip() \
                                           if data['business_risk_text'].strip() else None
        if not values:
            return cls.format_exception(
                'At least one of the "business_risk_id" or "business_risk_text" parameters is required.', 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account = RHAccount.select(RHAccount.id).where(RHAccount.name == connexion.context['user'])
            for cve in cves:
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account[0].id, values.get('business_risk_id', 0),
                                  values.get('business_risk_text', None)))
            if not to_insert:
                return cls.format_exception('At least one given CVE must exist', 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
        except (IntegrityError, psycopg2IntegrityError):
            # usually means bad business_risk_id
            LOGGER.exception('Error during setting business risk (IntegrityError):')
            DB.rollback()
            return cls.format_exception(f'business_risk_id=%s is invalid' % data['business_risk_id'], 400)
        except ValueError as value_error:
            LOGGER.exception('Error during setting business risk (ValueError):')
            DB.rollback()
            return cls.format_exception(str(value_error), 500)
        return {'updated': updated}


class PatchCveStatus(PatchRequest):
    """ PATCH to /v1/cves/status"""

    _endpoint_name = r'/v1/cves/status'

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.status, CveAccountData.status_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    def handle_patch(cls, **kwargs):
        """Set status for a CVE"""
        data = kwargs['data']
        cve_list = data['cve']
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if 'status_id' in data:
            values['status_id'] = data['status_id']
        if 'status_text' in data:
            values['status_text'] = data['status_text'].strip() if data['status_text'].strip() else None
        if not values:
            return cls.format_exception(
                'At least one of the "status_id" or "status_text" parameters is required.', 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account = RHAccount.select(RHAccount.id).where(RHAccount.name == connexion.context['user'])
            for cve in cves:
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account[0].id, values.get('status_id', 0),
                                  values.get('status_text', None)))
            if not to_insert:
                return cls.format_exception('At least one given CVE must exist', 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
        except (IntegrityError, psycopg2IntegrityError):
            # usually means bad status
            LOGGER.exception('Error during setting status (IntegrityError):')
            DB.rollback()
            return cls.format_exception(f'status_id=%s is invalid' % data['status_id'], 400)
        except ValueError as value_error:
            LOGGER.exception('Error during setting status (ValueError):')
            DB.rollback()
            return cls.format_exception(str(value_error), 500)
        return {'updated': updated}
