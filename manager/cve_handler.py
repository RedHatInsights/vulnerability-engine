"""
Module for /cves API endpoint
"""
import json
from datetime import datetime
from datetime import timezone

import connexion
import dateutil.parser
from peewee import DataError
from peewee import DoesNotExist
from peewee import fn
from peewee import IntegrityError
from peewee import JOIN
from peewee import SQL
from psycopg2 import IntegrityError as psycopg2IntegrityError

from .base import ApplicationException
from .base import cyndi_join
from .base import DEFAULT_BUSINESS_RISK
from .base import DEFAULT_STATUS
from .base import get_account_data
from .base import get_or_create_account
from .base import get_rules_for_cves
from .base import GetRequest
from .base import OS_INFO_QUERY
from .base import OS_INFO_SORT
from .base import parse_int_list
from .base import parse_str_list
from .base import parse_tags
from .base import PatchRequest
from .base import reporter
from .base import unique_bool_list
from .filters import apply_filters
from .filters import filter_types
from .list_view import ListView
from .rbac_manager import RbacFilterRoutePermissions
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions
from common.config import Config
from common.constants import remediation
from common.logging import get_logger
from common.peewee_conditions import system_is_abnv
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import BusinessRisk
from common.peewee_model import CveAccountData
from common.peewee_model import CveImpact
from common.peewee_model import CveMetadata
from common.peewee_model import DB
from common.peewee_model import InsightsRule
from common.peewee_model import InventoryHosts
from common.peewee_model import RHAccount
from common.peewee_model import Status
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities
from common.utils import format_datetime
from common.utils import str_or_none

LOGGER = get_logger(__name__)
CFG = Config()


class SystemCvesView(ListView):
    """Database select for /cves/{cve_id}/affected_systems API endpoints"""

    def __init__(self, rh_account_id, synopsis, cves_without_errata, list_args, parsed_args, uri, ids_only=False):
        query = self._full_query(rh_account_id, synopsis) if not ids_only else self._id_query(rh_account_id, synopsis)
        query = cyndi_join(query)
        filters = [filter_types.SYSTEM_CVE_RULE,
                   filter_types.SYSTEM_CVE_RULE_KEY,
                   filter_types.SYSTEM_CVE_STATUS,
                   filter_types.SYSTEM_UUID,
                   filter_types.SYSTEM_CVE_RULE_PRESENCE,
                   filter_types.SYSTEM_VULNERABILITES_BY_ADVISORY,
                   filter_types.SYSTEM_CVE_FIRST_REPORTED,
                   filter_types.SYSTEM_TAGS,
                   filter_types.SYSTEM_SAP,
                   filter_types.SYSTEM_SAP_SIDS,
                   filter_types.SYSTEM_RHEL_VERSION,
                   filter_types.SYSTEM_CVE_ADVISORY_AVAILABLE,
                   filter_types.SYSTEM_CVE_REMEDIATION,
                   filter_types.SYSTEM_AAP,
                   filter_types.SYSTEM_MSSQL,
                   ]

        query = apply_filters(query, parsed_args, filters, {})

        if not cves_without_errata:
            query = query.where(CveMetadata.advisories_list != SQL("'[]'"))
        query = query.dicts()

        sortable_columns = {
            "display_name": SystemPlatform.display_name,
            "id": SystemPlatform.id,
            "inventory_id": SystemPlatform.inventory_id,
            "last_evaluation": SystemPlatform.last_evaluation,
            "last_upload": SystemPlatform.last_upload,
            "rules_evaluation": SystemPlatform.advisor_evaluated,
            "status_id": Status.id,
            "status": Status.id,
            "updated": InventoryHosts.updated,
            "first_reported": SystemVulnerabilities.first_reported,
            "os": OS_INFO_SORT,
            "advisory_available": SQL("advisory_available"),
            "remediation": SQL("remediation_type_id"),
            "advisories_list": SystemVulnerabilities.advisories,
        }
        default_sort_columns = {
            "default": ["-updated", "id"],
        }
        filterable_columns = {
            "display_name": SystemPlatform.display_name
        }
        filter_expressions = {}
        super().__init__(query, sortable_columns, default_sort_columns,
                         filterable_columns, filter_expressions, list_args, parsed_args, uri)

    @staticmethod
    def _full_query(rh_account_id, synopsis):
        """To be implemented in child classes"""
        raise NotImplementedError

    @staticmethod
    def _id_query(rh_account_id, synopsis):
        """To be implemented in child classes"""
        raise NotImplementedError


class AffectedSystemsView(SystemCvesView):
    """Database select queries for /cves/{cve_id}/affected_systems API endpoint"""

    @staticmethod
    def _full_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        selectables = [fn.COALESCE(CveAccountData.status_id, 0).alias("cve_status_id"),
                       SystemPlatform.inventory_id,
                       SystemPlatform.display_name,
                       SystemPlatform.last_evaluation,
                       SystemPlatform.advisor_evaluated.alias("rules_evaluation"),
                       SystemPlatform.last_upload,
                       SystemPlatform.stale_timestamp,
                       SystemPlatform.stale_warning_timestamp,
                       SystemPlatform.culled_timestamp,
                       Status.id.alias("status_id"),
                       Status.name.alias("status_name"),
                       SystemVulnerabilities.status_text.alias("status_text"),
                       SystemVulnerabilities.rule_hit_details,
                       SystemVulnerabilities.when_mitigated,
                       SystemVulnerabilities.first_reported,
                       SystemVulnerabilities.mitigation_reason,
                       SystemVulnerabilities.advisories,
                       InsightsRule.name.alias("rule_id"),
                       InsightsRule.active.alias("rule_active"),
                       InsightsRule.description_text,
                       InsightsRule.reason_text,
                       InsightsRule.resolution_text,
                       InsightsRule.kbase_node_id,
                       InsightsRule.more_info_text,
                       InventoryHosts.tags,
                       InventoryHosts.updated,
                       InventoryHosts.insights_id,
                       OS_INFO_QUERY.alias("os"),
                       fn.COALESCE(SystemVulnerabilities.advisory_available, True).alias("advisory_available"),
                       fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation_type_id"),
                       ]

        return (SystemVulnerabilities
                .select(*selectables)
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(Status, on=(SystemVulnerabilities.status_id == Status.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(CveAccountData, JOIN.LEFT_OUTER, on=((CveAccountData.rh_account_id == rh_account_id)
                                                           & (CveMetadata.id == CveAccountData.cve_id)))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(system_is_active(rh_account_id=rh_account_id))
                .where(system_is_vulnerable(rule_subselect=False)))

    @staticmethod
    def _id_query(rh_account_id, synopsis):
        # pylint: disable=singleton-comparison
        return (SystemVulnerabilities
                .select(SystemPlatform.inventory_id,
                        InsightsRule.name.alias("rule_id"),
                        SystemVulnerabilities.status_id.alias("status_id"),
                        SystemVulnerabilities.status_text.alias("status_text"),
                        SystemPlatform.display_name.alias("display_name"),
                        SystemVulnerabilities.mitigation_reason,
                        fn.COALESCE(SystemVulnerabilities.remediation_type_id, remediation.PLAYBOOK.value).alias("remediation"),
                        )
                .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                .where(CveMetadata.cve == synopsis)
                .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                .where(system_is_active(rh_account_id=rh_account_id))
                .where(system_is_vulnerable(rule_subselect=False)))


class GetCves(GetRequest):
    """GET to /v1/cves/{cve_id}"""

    _endpoint_name = r"/v1/cves/{cve_id}"

    @staticmethod
    def _get_cve_details(synopsis):
        try:
            data = (CveMetadata.select(CveImpact.name.alias("impact"), CveMetadata.cve.alias("synopsis"),
                                       CveMetadata.description, CveMetadata.cvss2_metrics,
                                       CveMetadata.cvss2_score, CveMetadata.cvss3_score,
                                       CveMetadata.cvss3_metrics, CveMetadata.modified_date, CveMetadata.celebrity_name,
                                       CveMetadata.public_date, CveMetadata.redhat_url,
                                       CveMetadata.secondary_url, CveMetadata.id, CveMetadata.advisories_list,
                                       CveMetadata.exploit_data)
                    .join(CveImpact, on=(CveMetadata.impact_id == CveImpact.id))
                    .where(CveMetadata.cve == synopsis)).dicts()[0]
            rules_map = get_rules_for_cves([data["id"]], connexion.context["user"])
            retval = {
                "celebrity_name": str_or_none(data["celebrity_name"]),
                "cvss2_metrics": str_or_none(data["cvss2_metrics"]),
                "cvss2_score": str_or_none(data["cvss2_score"]),
                "cvss3_metrics": str_or_none(data["cvss3_metrics"]),
                "cvss3_score": str_or_none(data["cvss3_score"]),
                "description": data["description"],
                "impact": data["impact"],
                "public_date": format_datetime(data["public_date"]),
                "modified_date": format_datetime(data["modified_date"]),
                "redhat_url": data["redhat_url"],
                "rules": rules_map.get(data["id"], []),
                "secondary_url": data["secondary_url"],
                "synopsis": data["synopsis"],
                "known_exploit": data["exploit_data"] is not None and bool(data["advisories_list"]),
                "advisories_list": data.get("advisories_list") or [],
            }
        except IndexError as exc:
            raise ApplicationException("No such CVE ID", 404) from exc
        return retval

    @classmethod
    def _cve_details(cls, synopsis):
        retval = cls._get_cve_details(synopsis)
        rh_account_id, *_ = get_account_data(connexion.context["user"])
        cve_details = (CveAccountData.select(BusinessRisk.name.alias("risk"),
                                             CveAccountData.business_risk_id.alias("risk_id"),
                                             CveAccountData.business_risk_text.alias("risk_text"),
                                             Status.name.alias("status"),
                                             CveAccountData.status_id.alias("status_id"),
                                             CveAccountData.status_text.alias("status_text"))
                       .join(BusinessRisk, on=(CveAccountData.business_risk_id == BusinessRisk.id))
                       .join(Status, on=(CveAccountData.status_id == Status.id))
                       .join(CveMetadata, on=(CveAccountData.cve_id == CveMetadata.id))
                       .where(CveAccountData.rh_account_id == rh_account_id)
                       .where(CveMetadata.cve == synopsis)).dicts()
        if cve_details.count():
            retval["business_risk"] = cve_details[0]["risk"]
            retval["business_risk_id"] = cve_details[0]["risk_id"]
            retval["business_risk_text"] = cve_details[0]["risk_text"]
            retval["status"] = cve_details[0]["status"]
            retval["status_id"] = cve_details[0]["status_id"]
            retval["status_text"] = cve_details[0]["status_text"]
        else:
            retval["business_risk"] = DEFAULT_BUSINESS_RISK
            retval["business_risk_id"] = 0
            retval["business_risk_text"] = None
            retval["status"] = DEFAULT_STATUS
            retval["status_id"] = 0
            retval["status_text"] = None

        # affected but not vulnerable systems count
        # pylint: disable=singleton-comparison
        not_vulnerable = (SystemVulnerabilities
                          .select(fn.Count(SystemVulnerabilities.id))
                          .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                          .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                          .join(InsightsRule, on=(SystemVulnerabilities.rule_id == InsightsRule.id))
                          .where((SystemVulnerabilities.rh_account_id == rh_account_id))
                          .where(CveMetadata.cve == synopsis)
                          .where(system_is_active(rh_account_id=rh_account_id))
                          .where(system_is_abnv()))
        not_vulnerable = cyndi_join(not_vulnerable)
        retval["affected_but_not_vulnerable"] = not_vulnerable.scalar()

        # add counts of systems with all statuses
        retval["systems_status_detail"] = {}
        # pylint: disable=singleton-comparison
        status_detail = (SystemVulnerabilities
                         .select(SystemVulnerabilities.status_id, fn.Count(SystemVulnerabilities.status_id).alias("systems"))
                         .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                         .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                         .join(InsightsRule, JOIN.LEFT_OUTER, on=(InsightsRule.id == SystemVulnerabilities.rule_id))
                         .where(CveMetadata.cve == synopsis)
                         .where(SystemVulnerabilities.rh_account_id == rh_account_id)
                         .where(system_is_active(rh_account_id=rh_account_id))
                         .where(system_is_vulnerable())
                         .group_by(SystemVulnerabilities.status_id)
                         .dicts())

        divergent_systems = 0
        status_detail = cyndi_join(status_detail)
        for row in status_detail:
            retval["systems_status_detail"][row["status_id"]] = row["systems"]
            if row["status_id"] != retval["status_id"]:
                divergent_systems += row["systems"]
        retval["systems_status_divergent"] = divergent_systems
        return retval

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.CSV_FORMAT_ENDPOINTS)
    def handle_get(cls, **kwargs):
        res = {}
        cve_details = cls._cve_details(kwargs["cve_id"])

        res["data"] = {
            "attributes": cve_details,
            "id": kwargs["cve_id"],
            "type": "cve",
        }
        return res


class GetCveSystems(GetRequest):
    """Parent class for {affected,mitigated}_systems endpoints"""

    _DB_View = AffectedSystemsView
    _ids_only = False

    @staticmethod
    def _build_attributes(sys, advisories_list=None):
        """To be implemented by child classes"""
        raise NotImplementedError

    @staticmethod
    def _cve_exists(synopsis):
        try:
            (CveMetadata.select(CveMetadata.cve)
             .where(CveMetadata.cve == synopsis)
             .get())
        except DoesNotExist as exc:
            raise ApplicationException("No such CVE ID", 404) from exc

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    @RBAC.need_permissions_filter_value(RbacFilterRoutePermissions.REPORTABLE_ENDPOINTS)
    def handle_get(cls, **kwargs):  # pylint: disable=too-many-branches
        """Gets systems affected by a CVE"""
        synopsis = kwargs["cve_id"]
        cls._cve_exists(synopsis)
        args_desc = [{"arg_name": "status_id", "convert_func": parse_int_list},
                     {"arg_name": "uuid", "convert_func": None},
                     {"arg_name": "rule_presence", "convert_func": unique_bool_list},
                     {"arg_name": "rule_key", "convert_func": None},
                     {"arg_name": "tags", "convert_func": parse_tags},
                     {"arg_name": "sap_system", "convert_func": None},
                     {"arg_name": "show_advisories", "convert_func": None},
                     {"arg_name": "advisory", "convert_func": None},
                     {"arg_name": "sap_sids", "convert_func": None},
                     {"arg_name": "rhel_version", "convert_func": parse_str_list},
                     {"arg_name": "first_reported_from", "convert_func": dateutil.parser.parse},
                     {"arg_name": "first_reported_to", "convert_func": dateutil.parser.parse},
                     {"arg_name": "rule", "convert_func": None},
                     {"arg_name": "advisory_available", "convert_func": unique_bool_list},
                     {"arg_name": "remediation", "convert_func": parse_int_list},
                     {"arg_name": "ansible", "convert_func": None},
                     {"arg_name": "mssql", "convert_func": None},
                     ]
        args = cls._parse_arguments(kwargs, args_desc)
        list_arguments = cls._parse_list_arguments(kwargs)

        rh_account_id, _, _, cves_without_errata = get_account_data(connexion.context["user"])

        asys_view = cls._DB_View(rh_account_id, synopsis, cves_without_errata, list_arguments, args, connexion.request.path, cls._ids_only)
        systems = list(asys_view)  # execute query

        response = {}
        result = []
        if cls._ids_only:
            result = systems
        else:
            for sys in systems:
                record = cls._build_attributes(sys)
                result.append({"type": "system", "id": sys["inventory_id"], "attributes": record})

        response["meta"] = asys_view.get_metadata()
        response["meta"]["patch_access"] = True  # remove patch_access in response
        response["meta"]["cves_without_errata"] = cves_without_errata
        response["links"] = asys_view.get_pagination_links()
        response["data"] = cls._format_data(list_arguments["data_format"], result, ids_only=cls._ids_only)
        return response


class GetCvesAffectedSystems(GetCveSystems):
    """GET to /v1/cves/{cve_id}/affected_systems"""

    _endpoint_name = r"/v1/cves/{cve_id}/affected_systems"

    @staticmethod
    def _build_attributes(sys, advisories_list=None):
        """Build attributes for response"""
        record = {}
        record["cve_status_id"] = sys["cve_status_id"]
        record["inventory_id"] = sys["inventory_id"]
        record["insights_id"] = sys["insights_id"]
        record["display_name"] = sys["display_name"]
        record["mitigation_reason"] = sys["mitigation_reason"]
        record["status_id"] = sys["status_id"]
        record["status_name"] = sys["status_name"]
        record["status_text"] = sys["status_text"]
        record["last_evaluation"] = sys["last_evaluation"].isoformat() if sys["last_evaluation"] else ""
        record["rules_evaluation"] = sys["rules_evaluation"].isoformat() if sys["rules_evaluation"] else None
        record["reporter"] = (reporter.VMAAS.value if not sys["when_mitigated"] else 0) | (reporter.RULE.value if sys["rule_active"] else 0)
        record["rule"] = {
            "details": json.loads(sys["rule_hit_details"]) if sys["rule_hit_details"] else {},
            "resolution": {
                "resolution": sys["resolution_text"]
            },
            "rule": {
                "description": sys["description_text"],
                "more_info": sys["more_info_text"],
                "node_id": sys["kbase_node_id"],
                "reason": sys["reason_text"],
                "rule_id": sys["rule_id"],
            }
        } if sys["rule_active"] else None
        record["tags"] = sys["tags"] if sys["tags"] is not None else []
        if CFG.cves_without_errata or sys["remediation_type_id"] == 2:  # playbook
            record["advisories_list"] = sys["advisories"].split(",") if sys["advisories"] is not None else []
        else:
            record["advisories_list"] = []
        record["updated"] = sys["updated"]
        record["os"] = sys.get("os", "N/A")
        record["first_reported"] = sys["first_reported"].isoformat()
        # Defaults to True and playbook - backwards compatibility for NULL values
        record["advisory_available"] = sys["advisory_available"]
        record["remediation"] = sys["remediation_type_id"]
        record["stale_timestamp"] = sys["stale_timestamp"].isoformat() if sys["stale_timestamp"] else None
        record["stale_warning_timestamp"] = sys["stale_warning_timestamp"].isoformat() if sys["stale_warning_timestamp"] else None
        record["culled_timestamp"] = sys["culled_timestamp"].isoformat() if sys["culled_timestamp"] else None
        return record


class GetCvesAffectedSystemsIds(GetCvesAffectedSystems):
    """ GET to /v1/cves/{cve_id}/affected_systems/ids """

    _endpoint_name = r"/v1/cves/{cve_id}/affected_systems/ids"
    _ids_only = True


class PatchCveRisk(PatchRequest):
    """ PATCH to /v1/cves/business_risk"""

    _endpoint_name = r"/v1/cves/business_risk"

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.business_risk_id, CveAccountData.business_risk_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.CVE_BR_AND_STATUS_EDIT)
    def handle_patch(cls, **kwargs):
        """Set business risk for a CVE"""
        data = kwargs["data"]
        cve_list = data["cve"]
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if "business_risk_id" in data:
            values["business_risk_id"] = data["business_risk_id"]
        if "business_risk_text" in data:
            try:
                values["business_risk_text"] = data["business_risk_text"].strip() \
                    if data["business_risk_text"].strip() else None
            except AttributeError:
                values["business_risk_text"] = None
        if not values:
            return cls.format_exception(
                "At least one of the 'business_risk_id' or 'business_risk_text' parameters is required.", 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account_id = get_or_create_account()
            for cve in cves:  # pylint: disable=not-an-iterable
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account_id, values.get("business_risk_id", 0),
                                  values.get("business_risk_text", None)))
            if not to_insert:
                return cls.format_exception("At least one given CVE must exist", 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad business_risk_id
            LOGGER.exception("Error during setting business risk (IntegrityError):")
            DB.rollback()
            return cls.format_exception(f"business_risk_id={data['business_risk_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception("Error during setting business risk (ValueError):")
            DB.rollback()
            return cls.format_exception(f"business_risk_text or other key value is invalid ({value_error})", 400)
        return {"updated": updated}


class PatchCveStatus(PatchRequest):
    """ PATCH to /v1/cves/status"""

    _endpoint_name = r"/v1/cves/status"

    # static parameters of the query, will be same for each API call
    _fields = [CveAccountData.cve_id, CveAccountData.rh_account_id,
               CveAccountData.status_id, CveAccountData.status_text]
    _conflict_target = [CveAccountData.cve_id, CveAccountData.rh_account_id]

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.CVE_BR_AND_STATUS_EDIT)
    def handle_patch(cls, **kwargs):
        """Set status for a CVE"""
        data = kwargs["data"]
        cve_list = data["cve"]
        if isinstance(cve_list, str):
            cve_list = [cve_list]

        values = {}
        updated = []
        if "status_id" in data:
            values["status_id"] = data["status_id"]
        if "status_text" in data:
            try:
                values["status_text"] = data["status_text"].strip() \
                    if data["status_text"].strip() else None
            except AttributeError:
                values["status_text"] = None
        if not values:
            return cls.format_exception(
                "At least one of the 'status_id' or 'status_text' parameters is required.", 400)
        try:
            to_insert = []
            cves = CveMetadata.select(CveMetadata.id, CveMetadata.cve).where(CveMetadata.cve << cve_list)
            rh_account_id = get_or_create_account()
            for cve in cves:  # pylint: disable=not-an-iterable
                updated.append(cve.cve)
                to_insert.append((cve.id, rh_account_id, values.get("status_id", 0), values.get("status_text", None)))
            if not to_insert:
                return cls.format_exception("At least one given CVE must exist", 404)
            (CveAccountData.insert_many(to_insert, fields=cls._fields)
             .on_conflict(conflict_target=cls._conflict_target, preserve=[], update=values).execute())
            RHAccount.update(last_status_change=datetime.now(timezone.utc)).where(RHAccount.id == rh_account_id).execute()
        except (IntegrityError, psycopg2IntegrityError, DataError):
            # usually means bad status
            LOGGER.exception("Error during setting status (IntegrityError):")
            DB.rollback()
            return cls.format_exception(f"status_id={data['status_id']} is invalid", 400)
        except ValueError as value_error:
            LOGGER.exception("Error during setting status (ValueError):")
            DB.rollback()
            return cls.format_exception(f"status_text or other key value is invalid ({value_error})", 400)
        return {"updated": updated}
