"""
Common and utility functions/classes for vulnerability-manager
"""

import base64
import csv
from io import StringIO
import json
import logging
from http.client import responses
from os import environ

import requests

import tornado
from tornado.web import RequestHandler

VMAAS_HOST = environ.get('VMAAS_HOST', 'http://vmaas-webapp-1.vmaas-ci.svc:8080') # pylint: disable=invalid-name
DEFAULT_ROUTE = "%s/%s/%s" % (environ.get('PATH_PREFIX', "/r/insights/platform"),
                              environ.get('APP_NAME', "vulnerability"),
                              environ.get('API_VERSION', "v1"))
IDENTITY_HEADER = "x-rh-identity"
DEFAULT_PAGE_SIZE = 25

logging.basicConfig(level=logging.INFO)

logging.info("Access URL: %s", DEFAULT_ROUTE)


class InvalidArgumentException(Exception):
    """Illegal arguments for pagination/filtering/sorting"""

class ConnectionFinished(Exception):
    """Can be raised by raise methods of BaseHandler in case of error"""


class BaseHandler(RequestHandler):
    """Base class for all used handlers"""

    def __init__(self, application, request, **kwargs):
        self.my_user_locale = None
        super(BaseHandler, self).__init__(application, request, **kwargs)

    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.set_header("Access-Control-Allow-Headers",
                        "Content-Type, Access-Control-Allow-Headers, \
                        Authorization, X-Requested-With")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        self.set_header("Content-Type", "application/vnd.api+json")

    def options(self): # pylint: disable=arguments-differ
        self.set_status(204)
        self.finish()

    def get_user_locale(self):
        return self.my_user_locale

    def data_received(self, chunk):
        pass

    def _parse_arguments(self, argv):
        """
        Utility method for getting parameters from request which come as string
        and their conversion to a object we'd like to have.
        Expects array of {'arg_name' : some_str, 'convert_func' : e.g. float, int}
        Returns dict of values if succeeds, throws exception in case of fail
        """
        retval = {}
        errors = []
        for arg in argv:
            retval[arg['arg_name']] = self.get_argument(arg['arg_name'], None)
            if retval[arg['arg_name']]:
                try:
                    retval[arg['arg_name']] = arg['convert_func'](retval[arg['arg_name']])
                except ValueError:
                    errors.append({'status' : '400',
                                   'detail' : 'Error in argument %s: %s' % (arg['arg_name'], retval[arg['arg_name']])})
        if errors:
            self.raiseMany(400, errors, True)
        return retval

    def _parse_list_arguments(self):
        try:
            page = int(self.get_argument("page", 1))
            if page <= 0:
                raise InvalidArgumentException("Requested page out of range: %s" % page)
        except ValueError:
            raise InvalidArgumentException("Invalid page number: %s" % self.get_argument("page"))
        try:
            page_size = int(self.get_argument("page_size", DEFAULT_PAGE_SIZE))
            if page_size <= 0:
                raise InvalidArgumentException("Invalid page size: %s" % page_size)
        except ValueError:
            raise InvalidArgumentException("Invalid page size: %s" % self.get_argument("page_size"))
        data_format = self.get_argument("data_format", "json")
        if data_format not in ["json", "csv"]:
            raise InvalidArgumentException("Invalid data format: %s" % self.get_argument("data_format"))
        return {
            "filter": self.get_argument("filter", ""),
            "sort": self.get_argument("sort", ""),
            "page": page,
            "page_size": page_size,
            "data_format": data_format
        }

    @staticmethod
    def _format_data(output_data_format, data_list):
        if output_data_format == "csv":
            output = StringIO()
            if data_list:
                # create list of columns - type, id and all keys from attributes
                fields = ["type", "id"]
                fields.extend(data_list[0]["attributes"].keys())
                writer = csv.DictWriter(output, fields)
                writer.writeheader()
                for item in data_list:
                    # create flat dictionary (type, id + values from attributes) and write it
                    writer.writerow({field: item.get(field) or item["attributes"].get(field) for field in fields})
            return output.getvalue()
        return data_list

    def raiseError(self, code, text=None, do_raise=False): # pylint: disable=invalid-name
        """Sends an error in the response and closes the connection"""
        text = text if text else responses[code]
        self.set_status(code)
        res = {"errors": [{"status": str(code), "detail": text}]}
        self.finish(res)
        if do_raise:
            raise ConnectionFinished

    def raiseMany(self, code, errors, do_raise=False): # pylint: disable=invalid-name
        """Sends multiple errors and closes the connection"""
        self.set_status(code)
        self.finish({'errors' : errors})
        if do_raise:
            raise ConnectionFinished


class AuthenticatedHandler(BaseHandler):
    """Base handler class for all handlers which also implements authentication"""

    def __init__(self, application, request, **kwargs):
        self.rh_account_number = None
        super(AuthenticatedHandler, self).__init__(application, request, **kwargs)

    def prepare(self):
        logging.debug("Received request")
        if 'x-rh-identity' not in self.request.headers:
            self.raiseError(403)
            return

        encoded_value = self.request.headers[IDENTITY_HEADER]
        decoded_value = base64.b64decode(encoded_value).decode("utf-8")
        logging.debug('identity decoded: %s', decoded_value)
        identity = json.loads(decoded_value)
        if 'identity' in identity:
            id_details = identity['identity']
        else:
            self.raiseError(403)
            return

        if 'account_number' in id_details:
            self.rh_account_number = id_details['account_number']
            logging.debug('identity rh_account_number: %s', self.rh_account_number)
        else:
            self.raiseError(403)
            return

        if id_details.get('type', 'unknown').lower() == 'user':
            user_details = id_details.get('user', {})
        else:
            self.raiseError(403)
            return

        if 'username' in user_details:
            self.current_user = user_details['username']
            logging.debug('identity username: %s', self.current_user)
        else:
            self.raiseError(403)
            return

        if 'locale' in user_details:
            logging.debug('identity locale: %s', user_details['locale'])
            self.my_user_locale = tornado.locale.get(user_details['locale'])

    def vmaas_call(self, endpoint, data):
        """Calls vmaas and retrieves data from it"""
        headers = {'Content-type': 'application/json',
                   'Accept': 'application/json'}
        try:
            response = requests.post(VMAAS_HOST + endpoint,
                                     data=json.dumps(data), headers=headers)
        except requests.exceptions.ConnectionError:
            logging.info('Could not connect to %s', (VMAAS_HOST,))
            self.raiseError(500, 'Could not connect to %s' % (VMAAS_HOST,), True)
            return None
        if response.status_code == 200:
            return response.json()
        logging.info('Received %s from vmaas on %s endpoint', response.status_code, endpoint)
        self.raiseError(500, 'Received %s from vmaas on %s endpoint' % (response.status_code, endpoint), True)
        return None


class NotFoundHandler(AuthenticatedHandler):
    """Raised when handler is not found"""
    def prepare(self):
        self.raiseError(404)


def parse_url(uri, base_handler):
    """Parses handler route"""
    uri = uri.split('?')[0]
    prefix = DEFAULT_ROUTE + base_handler
    if not prefix.endswith("/"):
        prefix = prefix + "/"
    if uri.endswith("/"):
        uri = uri[:-1]
    request_url = uri[len(prefix):]

    return request_url.split("/")

def none2empty(value):
    """Returns an empty string instead of 'None'"""
    return value if value else ''
