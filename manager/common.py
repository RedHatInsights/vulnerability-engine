
import base64
import json
import logging
from http.client import responses
from os import environ

import requests

import tornado
from tornado.web import RequestHandler

VMAAS_URL = "https://webapp-vmaas-stable.1b13.insights.openshiftapps.com"
DEFAULT_ROUTE = "%s/%s/%s" % (environ.get('PATH_PREFIX', "/r/insights/platform"),
                              environ.get('APP_NAME', "vulnerability"),
                              environ.get('API_VERSION', "v1"))
IDENTITY_HEADER = "x-rh-identity"
DEFAULT_PAGE_SIZE = 25

logging.basicConfig(level=logging.INFO)

logging.info("Access URL: %s" % DEFAULT_ROUTE)


class InvalidArgumentException(Exception):
    pass

class ConnectionFinished(Exception):
    pass


class BaseHandler(RequestHandler):

    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.set_header("Access-Control-Allow-Headers",
                        "Content-Type, Access-Control-Allow-Headers, \
                        Authorization, X-Requested-With")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')

    def options(self):
        self.set_status(204)
        self.finish()

    def get_user_locale(self):
        return self.my_user_locale

    def _parse_arguments(self, argv):
        """
        Utility method for getting parameters from request which come as string
        and their conversion to a object we'd like to have.
        Expects array of {'arg_name' : some_str, 'convert_func' : e.g. float, int}
        Returns dict of values if succeeds, throws exception in case of fail
        """
        retval = {}
        errors = []
        for arg in argv:
            retval[arg['arg_name']] = self.get_argument(arg['arg_name'], None)
            if retval[arg['arg_name']]:
                try:
                    retval[arg['arg_name']] = arg['convert_func'](retval[arg['arg_name']])
                except ValueError:
                    errors.append({'status' : '400',
                            'detail' : 'Error in argument %s: %s' % (arg['arg_name'], retval[arg['arg_name']])})
        if errors:
            self.raiseMany(400, errors, True)
        return retval

    def _parse_list_arguments(self):
        try:
            page = int(self.get_argument("page", 1))
            if page <= 0:
                raise InvalidArgumentException("Invalid page number: %s" % page)
        except ValueError:
            raise InvalidArgumentException("Invalid page number: %s" % self.get_argument("page"))
        try:
            page_size = int(self.get_argument("page_size", DEFAULT_PAGE_SIZE))
            if page_size <= 0:
                raise InvalidArgumentException("Invalid page size: %s" % page_size)
        except ValueError:
            raise InvalidArgumentException("Invalid page size: %s" % self.get_argument("page_size"))
        return {
            "filter": self.get_argument("filter", ""),
            "sort": self.get_argument("sort", ""),
            "page": page,
            "page_size": page_size
        }

    def raiseError(self, code, text=None, do_raise=False):
        text = text if text else responses[code]
        self.set_status(code)
        res = {"errors": [{"status": str(code), "detail": text}]}
        self.finish(res)
        if do_raise:
            raise ConnectionFinished

    def raiseMany(self, code, errors, do_raise=False):
        self.set_status(code)
        self.finish({'errors' : errors})
        if do_raise:
            raise ConnectionFinished


class AuthenticatedHandler(BaseHandler):
    def prepare(self):
        logging.debug("Received request")
        if 'x-rh-identity' not in self.request.headers:
            self.raiseError(403)
            return

        encoded_value = self.request.headers[IDENTITY_HEADER]
        decoded_value = base64.b64decode(encoded_value).decode("utf-8")
        logging.debug('identity decoded: %s' % decoded_value)
        identity = json.loads(decoded_value)
        if 'identity' in identity:
            id_details = identity['identity']
        else:
            self.raiseError(403)
            return

        if 'account_number' in id_details:
            self.rh_account_number = id_details['account_number']
            logging.debug('identity rh_account_number: %s' %
                          self.rh_account_number)
        else:
            self.raiseError(403)
            return

        if 'username' in id_details:
            self.current_user = id_details['username']
            logging.debug('identity username: %s' % self.current_user)
        else:
            self.raiseError(403)
            return

        if 'locale' in id_details:
            logging.debug('identity locale: %s' % id_details['locale'])
            self.my_user_locale = tornado.locale.get(id_details['locale'])

    def vmaas_call(self, endpoint, data):
        headers = {'Content-type': 'application/json',
                   'Accept': 'application/json'}
        try:
            response = requests.post(VMAAS_URL + endpoint,
                                     data=json.dumps(data), headers=headers)
        except requests.exceptions.ConnectionError:
            logging.info('Could not connect to %s' % (VMAAS_URL,))
            self.raiseError(500, 'Could not connect to %s' % (VMAAS_URL,), True)
            return
        if response.status_code == 200:
            return response.json()
        logging.info('Received %s from vmaas on %s endpoint' % (response.status_code, endpoint))
        self.raiseError(500, 'Received %s from vmaas on %s endpoint' % (response.status_code, endpoint), True)


class NotFoundHandler(AuthenticatedHandler):
    def prepare(self):
        self.raiseError(404)


def parse_url(uri, base_handler):
    uri = uri.split('?')[0]
    prefix = DEFAULT_ROUTE + base_handler
    if not prefix.endswith("/"):
        prefix = prefix + "/"
    if uri.endswith("/"):
        uri = uri[:-1]
    request_url = uri[len(prefix):]

    return request_url.split("/")

def none2empty(value):
    return value if value else ''
