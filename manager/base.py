"""
Common and utility functions/classes for vulnerability-manager
"""

import base64
import csv
from io import StringIO
import json
from http.client import responses
from os import environ

import requests

from prometheus_client import Counter, generate_latest
import tornado
from tornado.web import RequestHandler

from common.logging import get_logger
from common.peewee_model import DB

LOGGER = get_logger(__name__)

VMAAS_HOST = environ.get('VMAAS_HOST', 'http://vmaas-webapp-1.vmaas-ci.svc:8080') # pylint: disable=invalid-name
DEFAULT_ROUTE = "%s/%s" % (environ.get('PATH_PREFIX', "/r/insights/platform"),
                           environ.get('APP_NAME', "vulnerability"))
IDENTITY_HEADER = "x-rh-identity"
DEFAULT_PAGE_SIZE = 25

LOGGER.info("Access URL: %s", DEFAULT_ROUTE)

# Prometheus support
# Counter for all-the-get-calls, dealt with in BaseHandler
REQUEST_COUNTS = Counter('ve_manager_invocations', 'Number of calls per handler', ['method', 'endpoint'])

class InvalidArgumentException(Exception):
    """Illegal arguments for pagination/filtering/sorting"""

class ConnectionFinished(Exception):
    """Can be raised by raise methods of BaseHandler in case of error"""


class BaseHandler(RequestHandler):
    """Base class for all used handlers"""

    def __init__(self, application, request, **kwargs):
        self.my_user_locale = None
        super(BaseHandler, self).__init__(application, request, **kwargs)

    def prepare(self):
        DB.connect()
        return super(BaseHandler, self).prepare()

    def on_finish(self):
        if not DB.is_closed():
            DB.close()
        return super(BaseHandler, self).on_finish()

    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.set_header("Access-Control-Allow-Headers",
                        "Content-Type, Access-Control-Allow-Headers, \
                        Authorization, X-Requested-With")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')
        self.set_header("Content-Type", "application/vnd.api+json")

    def options(self): # pylint: disable=arguments-differ
        self.set_status(204)
        self.finish()

    def get(self): # pylint: disable=arguments-differ
        REQUEST_COUNTS.labels('get', self.__class__.__name__).inc()
        try:
            self.handle_get()
        except ConnectionFinished:
            pass
        except InvalidArgumentException as exc:
            self.raiseError(400, str(exc))
        except Exception as exc: #pylint: disable=broad-except
            self.raiseError(500, str(exc))
            raise

    def post(self): # pylint: disable=arguments-differ
        REQUEST_COUNTS.labels('post', self.__class__.__name__).inc()
        try:
            self.handle_post()
            self.flush()
        except ConnectionFinished:
            pass
        except InvalidArgumentException as exc:
            self.raiseError(400, str(exc))
        except Exception as exc: #pylint: disable=broad-except
            self.raiseError(500, str(exc))
            raise

    def handle_get(self):
        """Function which replaces get() in subclasses so we can put all error handling into one place"""
        raise NotImplementedError

    def handle_post(self):
        """Function which replaces post() in subclasses so we can put all error handling into one place"""
        raise NotImplementedError

    def get_user_locale(self):
        return self.my_user_locale

    def data_received(self, chunk):
        pass

    def _parse_arguments(self, argv):
        """
        Utility method for getting parameters from request which come as string
        and their conversion to a object we'd like to have.
        Expects array of {'arg_name' : some_str, 'convert_func' : e.g. float, int}
        Returns dict of values if succeeds, throws exception in case of fail
        """
        retval = {}
        errors = []
        for arg in argv:
            retval[arg['arg_name']] = self.get_argument(arg['arg_name'], None)
            if retval[arg['arg_name']]:
                try:
                    retval[arg['arg_name']] = arg['convert_func'](retval[arg['arg_name']])
                except ValueError:
                    errors.append({'status' : '400',
                                   'detail' : 'Error in argument %s: %s' % (arg['arg_name'], retval[arg['arg_name']])})
        if errors:
            self.raiseMany(400, errors, True)
        return retval

    def _parse_list_arguments(self):
        try:
            page = int(self.get_argument("page", 1))
            if page <= 0:
                raise InvalidArgumentException("Requested page out of range: %s" % page)
        except ValueError:
            raise InvalidArgumentException("Invalid page number: %s" % self.get_argument("page"))
        try:
            page_size = int(self.get_argument("page_size", DEFAULT_PAGE_SIZE))
            if page_size <= 0:
                raise InvalidArgumentException("Invalid page size: %s" % page_size)
        except ValueError:
            raise InvalidArgumentException("Invalid page size: %s" % self.get_argument("page_size"))
        data_format = self.get_argument("data_format", "json")
        if data_format not in ["json", "csv"]:
            raise InvalidArgumentException("Invalid data format: %s" % self.get_argument("data_format"))
        return {
            "filter": self.get_argument("filter", ""),
            "sort": self.get_argument("sort", ""),
            "page": page,
            "page_size": page_size,
            "data_format": data_format
        }

    @staticmethod
    def _format_data(output_data_format, data_list):
        if output_data_format == "csv":
            output = StringIO()
            if data_list:
                # create list of columns - type, id and all keys from attributes
                fields = ["type", "id"]
                fields.extend(data_list[0]["attributes"].keys())
                writer = csv.DictWriter(output, fields)
                writer.writeheader()
                for item in data_list:
                    # create flat dictionary (type, id + values from attributes) and write it
                    writer.writerow({field: item.get(field) or item["attributes"].get(field) for field in fields})
            return output.getvalue()
        return data_list

    def get_post_data(self):
        """extract input JSON from POST request"""
        json_data = ''

        # check if JSON is passed as a file or as a body of POST request
        if self.request.files:
            json_data = self.request.files['file'][0]['body']  # pick up only first file (index 0)
        elif self.request.body:
            json_data = self.request.body

        try:
            data = json.loads(json_data)
        except ValueError:
            data = None
        return data

    def raiseError(self, code, text=None, do_raise=False): # pylint: disable=invalid-name
        """Sends an error in the response and closes the connection"""
        text = text if text else responses[code]
        self.set_status(code)
        res = {"errors": [{"status": str(code), "detail": text}]}
        self.finish(res)
        if do_raise:
            raise ConnectionFinished

    def raiseMany(self, code, errors, do_raise=False): # pylint: disable=invalid-name
        """Sends multiple errors and closes the connection"""
        self.set_status(code)
        self.finish({'errors' : errors})
        if do_raise:
            raise ConnectionFinished


class AuthenticatedHandler(BaseHandler):
    """Base handler class for all handlers which also implements authentication"""

    def __init__(self, application, request, **kwargs):
        self.rh_account_number = None
        super(AuthenticatedHandler, self).__init__(application, request, **kwargs)

    def handle_get(self):
        """Function which replaces get() in subclasses so we can put all error handling into one place"""
        raise NotImplementedError

    def handle_post(self):
        """Function which replaces post() in subclasses so we can put all error handling into one place"""
        raise NotImplementedError

    def prepare(self):
        LOGGER.debug("Received request")
        if 'x-rh-identity' not in self.request.headers:
            self.raiseError(403)
            return None

        encoded_value = self.request.headers[IDENTITY_HEADER]
        decoded_value = base64.b64decode(encoded_value).decode("utf-8")
        LOGGER.debug('identity decoded: %s', decoded_value)
        identity = json.loads(decoded_value)
        if 'identity' in identity:
            id_details = identity['identity']
        else:
            self.raiseError(403)
            return None

        if 'account_number' in id_details:
            self.rh_account_number = id_details['account_number']
            LOGGER.debug('identity rh_account_number: %s', self.rh_account_number)
        else:
            self.raiseError(403)
            return None

        if id_details.get('type', 'unknown').lower() == 'user':
            user_details = id_details.get('user', {})
        else:
            self.raiseError(403)
            return None

        if 'username' in user_details:
            self.current_user = user_details['username']
            LOGGER.debug('identity username: %s', self.current_user)
        else:
            self.raiseError(403)
            return None

        if 'locale' in user_details:
            LOGGER.debug('identity locale: %s', user_details['locale'])
            self.my_user_locale = tornado.locale.get(user_details['locale'])

        return super(AuthenticatedHandler, self).prepare()

    def vmaas_call(self, endpoint, data):
        """Calls vmaas and retrieves data from it"""
        headers = {'Content-type': 'application/json',
                   'Accept': 'application/json'}
        try:
            response = requests.post(VMAAS_HOST + endpoint,
                                     data=json.dumps(data), headers=headers)
        except requests.exceptions.ConnectionError:
            LOGGER.error('Could not connect to %s', (VMAAS_HOST,))
            self.raiseError(500, 'Could not connect to %s' % (VMAAS_HOST,), True)
            return None
        if response.status_code == 200:
            return response.json()
        LOGGER.error('Received %s from vmaas on %s endpoint', response.status_code, endpoint)
        self.raiseError(response.status_code, 'Received %s from vmaas on %s endpoint' %
                        (response.status_code, VMAAS_HOST + endpoint), True)
        return None


class NotFoundHandler(AuthenticatedHandler):
    """Raised when handler is not found"""
    def prepare(self):
        self.raiseError(404)

    def handle_get(self):
        """No need to do anything here"""

    def handle_post(self):
        """No need to do anything here"""

class MetricsHandler(BaseHandler):
    """Handle requests to /metrics endpoint for prometheus"""

    def handle_get(self):
        """Get prometheus metrics"""
        self.write(generate_latest())

    def handle_post(self):
        """Function which replaces post() in subclasses so we can put all error handling into one place"""
        raise NotImplementedError

def parse_url(uri, base_handler):
    """Parses handler route"""
    uri = uri.split('?')[0]
    prefix = DEFAULT_ROUTE + base_handler
    if not prefix.endswith("/"):
        prefix = prefix + "/"
    if uri.endswith("/"):
        uri = uri[:-1]
    request_url = uri[len(prefix):]

    return request_url.split("/")

def none2empty(value):
    """Returns an empty string instead of 'None'"""
    return value if value else ''
