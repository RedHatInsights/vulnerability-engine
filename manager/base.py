"""
Common and utility functions/classes for vulnerability-manager
"""
import csv
from enum import Enum
from io import StringIO
import json
from math import floor
import os
from distutils.util import strtobool  # pylint: disable=import-error, no-name-in-module
import traceback

import connexion
from flask import Response
from peewee import fn, DataError
from prometheus_client import Counter
import requests

from common.identity import get_identity, is_entitled_insights
from common.logging import get_logger
from common.peewee_model import CveMetadata, CveRuleMapping, InsightsRule, RHAccount, SystemPlatform
from common.utils import send_slack_notification

LOGGER = get_logger(__name__)

DEFAULT_ROUTE = "%s/%s" % (os.getenv('PATH_PREFIX', "/api"),
                           os.getenv('APP_NAME', "vulnerability"))
IDENTITY_HEADER = "x-rh-identity"
DEFAULT_PAGE_SIZE = 20
READ_ONLY_MODE = strtobool(os.environ.get('READ_ONLY_MODE', 'FALSE'))
DEFAULT_BUSINESS_RISK = 'Not Defined'
DEFAULT_STATUS = "Not Reviewed"
CVE_SYNOPSIS_SORT = [fn.SUBSTRING(CveMetadata.cve, r'-(\d+)-').cast('integer'),
                     fn.SUBSTRING(CveMetadata.cve, r'-(\d+)$').cast('integer')]
RBAC_URL = os.environ.get('RBAC_URL')
if RBAC_URL:
    RBAC_URL = '{}/api/rbac/v1/access/?application=vulnerability&limit=1000'.format(RBAC_URL)

UI_REFERER = "cloud.redhat.com"
API_SOURCE = "API"
UI_SOURCE = "UI"

LOGGER.info("Access URL: %s", DEFAULT_ROUTE)

# Prometheus support
# Counter for all-the-get-calls, dealt with in BaseHandler
REQUEST_COUNTS = Counter('ve_manager_invocations', 'Number of calls per handler', ['method', 'endpoint', 'source'])
ACCOUNT_REQUESTS = Counter('ve_manager_account_invocations', 'Number of calls per account', ['account'])


class reporter(Enum):  # pylint: disable=invalid-name
    """Sources of reported CVE"""
    NONE = 0
    VMAAS = 1
    RULE = 2
    BOTH = 3


class InvalidArgumentException(Exception):
    """Illegal arguments for pagination/filtering/sorting"""


class ApplicationException(Exception):
    """General exception in the application"""

    def __init__(self, message, status_code):
        self.message = message
        self.status_code = status_code
        super().__init__()

    def format_exception(self):
        """Formats error message to desired format"""
        if isinstance(self.message, dict):
            return self.message, self.status_code
        return Request.format_exception(self.message, self.status_code)


class MissingEntitlementException(Exception):
    """entitlement is missing"""


class InternalOnlyException(Exception):
    """function is available only for internal users"""


class ReadOnlyModeException(Exception):
    """manager is running in read-only mode"""


class RbacException(Exception):
    """user is not allowed by RBAC"""

    def __init__(self, message):
        self.message = message
        super().__init__(self)


def basic_auth(username, password, required_scopes=None):  # pylint: disable=unused-argument
    """
    Basic auth is done on 3scale level.
    """
    raise MissingEntitlementException


def auth_common(identity, x_rh_identity):  # pylint: disable=unused-argument
    """
    Check account number and entitlements
    """
    if 'identity' not in identity:
        return None
    id_details = identity['identity']

    if 'account_number' not in id_details:
        return None
    rh_account_number = id_details['account_number']

    if not is_entitled_insights(identity):
        raise MissingEntitlementException

    if RBAC_URL:
        try:
            response = requests.get(RBAC_URL, headers={'x-rh-identity': x_rh_identity})
        except requests.exceptions.RequestException:
            LOGGER.exception("Error calling RBAC: ")
            raise RbacException('user access service is not available at the moment')
        if response.status_code != 200 or 'vulnerability:*:*' not in [x['permission'] for x in response.json()['data']]:
            raise RbacException('user is not allowed by user management')

    ACCOUNT_REQUESTS.labels(rh_account_number).inc()
    return {'uid': rh_account_number}


def auth(x_rh_identity, required_scopes=None):  # pylint: disable=unused-argument
    """
    Parses account number from the x-rh-identity header
    """
    identity = get_identity(x_rh_identity)
    return auth_common(identity, x_rh_identity) if identity is not None else None


def auth_internal(x_rh_identity, required_scopes=None):  # pylint: disable=unused-argument
    """
    Parses account number from the x-rh-identity header and ensures account is internal
    """
    identity = get_identity(x_rh_identity)
    if identity is not None:
        if 'identity' not in identity or 'user' not in identity['identity'] or \
                not identity['identity']['user'].get('is_internal', False):
            raise InternalOnlyException
    return auth_common(identity, x_rh_identity) if identity is not None else None


def forbidden_missing_entitlement(exception):  # pylint: disable=unused-argument
    """Override default connexion 401 coming from auth() with 403"""
    return Response(response=json.dumps({'errors': [{'detail': 'insights entitlement is missing',
                                                     'status': '403'}]}),
                    status=403, mimetype='application/vnd.api+json')


def forbidden_internal_only(exception):  # pylint: disable=unused-argument
    """Override default connexion 401 coming from auth() with 403"""
    return Response(response=json.dumps({'errors': [{'detail': 'api is available for internal users only',
                                                     'status': '403'}]}),
                    status=403, mimetype='application/vnd.api+json')


def forbidden_rbac(exception):  # pylint: disable=unused-argument
    """Override default connexion 401 coming from auth() with 403"""
    return Response(response=json.dumps({'errors': [{'detail': exception.message,
                                                     'status': '403'}]}),
                    status=403, mimetype='application/vnd.api+json')


class Request:
    """general class for processing requests"""

    _endpoint_name = None

    @staticmethod
    def _check_int_arg(kwargs, key, dflt, zero_allowed=False):
        val = kwargs.get(key, dflt)
        if val < 0 or (val == 0 and not zero_allowed):
            raise ApplicationException("Requested %s out of range: %s" % (key, val), 400)
        return val

    @staticmethod
    def _check_read_only_mode():
        if READ_ONLY_MODE:
            raise ReadOnlyModeException("Service is running in read-only mode. Please try again later.")

    @staticmethod
    def _format_data(output_data_format, data_list):
        if output_data_format == "csv":
            output = StringIO()
            if data_list:
                # create list of columns - type, id and all keys from attributes
                fields = ["type", "id"]
                fields.extend(data_list[0]["attributes"].keys())
                writer = csv.DictWriter(output, fields)
                writer.writeheader()
                for item in data_list:
                    # create flat dictionary (type, id + values from attributes) and write it
                    writer.writerow({field: item.get(field) or item["attributes"].get(field) for field in fields})
            return output.getvalue()
        return data_list

    @classmethod
    def _parse_list_arguments(cls, kwargs):
        # We may get limit/offset, or page/page_size, or both
        # limit/offset 'wins', if it's set
        # page/page_size defaults to 0/DEFAULT_PAGE_SIZE and limit/offset to DEFAULT_PAGE_SIZE if *neither* are set
        # regardless, make sure limit/offset and page/page_size a) both exist, and b) are consistent, before we leave
        offset_set = kwargs.get('offset', '') or kwargs.get('limit', '')
        page_set = kwargs.get('page', '') or kwargs.get('page_size', '')

        if offset_set:
            limit = cls._check_int_arg(kwargs, "limit", DEFAULT_PAGE_SIZE)
            offset = cls._check_int_arg(kwargs, "offset", 0, True)
            page = floor(offset / limit) + 1
            page_size = limit
        elif page_set:
            page = cls._check_int_arg(kwargs, "page", 1)
            page_size = cls._check_int_arg(kwargs, "page_size", DEFAULT_PAGE_SIZE)
            limit = page_size
            offset = (page - 1) * page_size
        else:
            page = 1
            offset = 0
            page_size = DEFAULT_PAGE_SIZE
            limit = DEFAULT_PAGE_SIZE

        data_format = kwargs.get("data_format", "json")
        if data_format not in ["json", "csv"]:
            raise InvalidArgumentException("Invalid data format: %s" % kwargs.get("data_format", None))

        return {
            "filter": remove_str_nulls(kwargs.get("filter", None)),
            "sort": remove_str_nulls(kwargs.get("sort", None)),
            "page": page,
            "page_size": page_size,
            "limit": limit,
            "offset": offset,
            "data_format": data_format
        }

    @staticmethod
    def format_exception(text, status_code):
        """Formats error message to desired format"""
        return {"errors": [{"status": str(status_code), "detail": text}]}, status_code

    @staticmethod
    def _parse_arguments(kwargs, argv):
        """
        Utility method for getting parameters from request which come as string
        and their conversion to a object we'd like to have.
        Expects array of {'arg_name' : some_str, 'convert_func' : e.g. float, int}
        Returns dict of values if succeeds, throws exception in case of fail
        """
        retval = {}
        errors = []
        for arg in argv:
            retval[arg['arg_name']] = kwargs.get(arg['arg_name'], None)
            if retval[arg['arg_name']] is not None:
                try:
                    if arg['convert_func'] is not None:
                        retval[arg['arg_name']] = arg['convert_func'](retval[arg['arg_name']])
                except ValueError:
                    errors.append({'status': '400',
                                   'detail': 'Error in argument %s: "%s"' % (arg['arg_name'], retval[arg['arg_name']])})
        if errors:
            raise ApplicationException({'errors': errors}, 400)
        return retval

    @classmethod
    def handle_errors(cls, fun, **kwargs):
        """ Execute provided function, while handling all common errors, and returning a formatted response """
        try:
            return fun(**kwargs)
        except ApplicationException as exc:
            return exc.format_exception()
        # TODO: Can this disclose any information ? Should we provide generic response message ?
        except DataError as exc:
            return cls.format_exception(str(exc), 400)
        except InvalidArgumentException as exc:
            return cls.format_exception(str(exc), 400)
        except ReadOnlyModeException as exc:
            return cls.format_exception(str(exc), 503)
        except Exception:  # pylint: disable=broad-except
            send_slack_notification('ISE in manager\nEndpoint: {}\nAccount: {}\nkwargs: {}\n{}'
                                    .format(cls._endpoint_name, connexion.context['user'], kwargs, traceback.format_exc()))
            LOGGER.exception('Unhandled exception: ')
            return cls.format_exception('Internal server error', 500)


class GetRequest(Request):
    """general class for processing GET requests"""

    @classmethod
    def get(cls, **kwargs):
        """Answer GET request"""
        referer = UI_SOURCE if UI_REFERER in connexion.request.headers.get("referer", "") else API_SOURCE
        REQUEST_COUNTS.labels('get', cls._endpoint_name, referer).inc()

        return cls.handle_errors(cls.handle_get, **kwargs)

    @classmethod
    def handle_get(cls, **kwargs):  # pragma: no cover
        """To be implemented in child classes"""
        raise NotImplementedError


class ReadWriteRequest(Request):
    """ Base class for request implementations which require database to be opened in write mode"""

    @classmethod
    def handle_errors(cls, fun, **kwargs):
        """ Handle common errors, and check whether read_only mode is enabled or disabled"""

        def readonly_fun(**kwargs):
            cls._check_read_only_mode()
            return fun(**kwargs)

        return Request.handle_errors(readonly_fun, **kwargs)


class PatchRequest(ReadWriteRequest):
    """general class for processing PATCH requests"""

    @classmethod
    def patch(cls, **kwargs):
        """Answer PATCH request"""
        referer = UI_SOURCE if UI_REFERER in connexion.request.headers.get("referer", "") else API_SOURCE
        REQUEST_COUNTS.labels('patch', cls._endpoint_name, referer).inc()

        return cls.handle_errors(cls.handle_patch, **kwargs)

    @classmethod
    def handle_patch(cls, **kwargs):  # pragma: no cover
        """To be implemented in child classes"""
        raise NotImplementedError


class PostRequest(ReadWriteRequest):
    """general class for processing POST requests"""

    @classmethod
    def post(cls, **kwargs):
        """Answer POST request"""
        referer = UI_SOURCE if UI_REFERER in connexion.request.headers.get("referer", "") else API_SOURCE
        REQUEST_COUNTS.labels('post', cls._endpoint_name, referer).inc()

        return cls.handle_errors(cls.handle_post, **kwargs)

    @classmethod
    def handle_post(cls, **kwargs):  # pragma: no cover
        """To be implemented in child classes"""
        raise NotImplementedError


class PutRequest(ReadWriteRequest):
    """general class for processing PUT requests"""

    @classmethod
    def put(cls, **kwargs):
        """Answer PUT request"""
        referer = UI_SOURCE if UI_REFERER in connexion.request.headers.get("referer", "") else API_SOURCE
        REQUEST_COUNTS.labels('put', cls._endpoint_name, referer).inc()

        return cls.handle_errors(cls.handle_put, **kwargs)

    @classmethod
    def handle_put(cls, **kwargs):  # pragma: no cover
        """To be implemented in child classes"""
        raise NotImplementedError


class DeleteRequest(ReadWriteRequest):
    """general class for processing DELETE requests"""

    @classmethod
    def delete(cls, **kwargs):
        """Answer DELETE request"""
        referer = UI_SOURCE if UI_REFERER in connexion.request.headers.get("referer", "") else API_SOURCE
        REQUEST_COUNTS.labels('delete', cls._endpoint_name, referer).inc()

        return cls.handle_errors(cls.handle_delete, **kwargs)

    @classmethod
    def handle_delete(cls, **kwargs):  # pragma: no cover
        """To be implemented in child classes"""
        raise NotImplementedError


def parse_int_list(input_str):
    """Function to parse string with ints to list, e.g. '1,2,3' -> [1,2,3]"""
    return [int(part) for part in input_str.split(",")]


def parse_str_list(input_str):
    """
    Function to parse string with rules to list, e.g.
    'rule1|ERR_KEY,rule2|ERR_KEY2' -> [rule1|ERR_KEY, rule2|ERR_KEY2]
    """
    return input_str.split(",")


def bool_or_rules_list(arg: str):
    """Converts string to bool or parsed security rules list"""
    try:
        return bool(strtobool(arg))
    except ValueError:
        return parse_str_list(arg)


def remove_str_nulls(val):
    """Remove \\00 characters from string, DB driver does not like them in expressions"""
    if isinstance(val, str):
        return val.replace('\x00', '').strip()
    return val


def parse_str_or_list(str_list):
    """Parses a list of strings or single one, while removing invalid values"""
    retval = None
    if isinstance(str_list, str):
        retval = [remove_str_nulls(str_list)]
    if isinstance(str_list, list):
        retval = [s for s in [remove_str_nulls(item) for item in str_list] if s]
    if not retval or not any(retval):
        raise ValueError('Expected str or str list')
    return retval


def get_or_create_account():
    """In some cases rh_account might not have already been created by listener, create it for usage in manager"""
    rh_account = RHAccount.select(RHAccount.id).where(RHAccount.name == connexion.context['user'])
    if rh_account.count() == 0:
        rh_account = RHAccount.insert(name=connexion.context['user']).on_conflict(
            conflict_target=[RHAccount.name], update={RHAccount.name: connexion.context['user']}).returning(RHAccount)
    return rh_account


def round_to_100_percent(number_set, digit_after_decimal=0):
    """
        This function take a list of number and return a list of percentage, which represents the portion of each number in sum of all numbers
        Moreover, those percentages are adding up to 100%!!!
    """
    divisor = float(sum(number_set))
    if not any(number_set):
        divisor = 100
    unround_numbers = [x / divisor * 100 * 10 ** digit_after_decimal for x in number_set]
    decimal_part_with_index = sorted([(index, unround_numbers[index] % 1) for index in range(len(unround_numbers))], key=lambda y: y[1], reverse=True)
    remainder = 100 * 10 ** digit_after_decimal - sum([int(x) for x in unround_numbers])
    index = 0
    while remainder > 0:
        unround_numbers[decimal_part_with_index[index][0]] += 1
        remainder -= 1
        index = (index + 1) % len(number_set)
    return [int(x) / float(10 ** digit_after_decimal) for x in unround_numbers]


def get_rules_for_cves(cves: list) -> dict:
    """Return associated rules for a CVE"""
    # pylint: disable=singleton-comparison
    rules_map = {}
    rule_cve_mapping = {}
    mapping = (CveRuleMapping.select(CveRuleMapping.cve_id, InsightsRule.name, InsightsRule.description_text, InsightsRule.summary_text,
                                     InsightsRule.generic_text, InsightsRule.reboot_required, InsightsRule.playbook_count, InsightsRule.change_risk,
                                     InsightsRule.kbase_node_id, InsightsRule.active, CveMetadata.cve)
               .join(InsightsRule, on=(CveRuleMapping.rule_id == InsightsRule.id))
               .join(CveMetadata, on=(CveRuleMapping.cve_id == CveMetadata.id))
               .where(InsightsRule.active == True)  # noqa: E712
               .where(CveRuleMapping.rule_id.in_(CveRuleMapping.select(CveRuleMapping.rule_id).where(CveRuleMapping.cve_id.in_(cves)))).dicts())
    for row in mapping:
        rule_cve_mapping.setdefault(row['name'], []).append(row['cve'])
    for row in mapping:
        rule_detail = {
            'rule_id': row['name'],
            'description': row['description_text'],
            'summary': row['summary_text'],
            'generic': row['generic_text'],
            'reboot_required': row['reboot_required'],
            'playbook_count': row['playbook_count'],
            'change_risk': row['change_risk'],
            'kbase_node_id': row['kbase_node_id'],
            'associated_cves': rule_cve_mapping[row['name']],
        }
        rules_map.setdefault(row['cve_id'], []).append(rule_detail)
    return rules_map


def get_system_count(rh_account):
    """Get count of nonstale, nonoptouted, evaluated user systems"""
    # pylint: disable=singleton-comparison
    return SystemPlatform.select(fn.COUNT(SystemPlatform.id).alias('count')) \
                         .where((SystemPlatform.rh_account_id == rh_account)
                                & ((SystemPlatform.last_evaluation.is_null(False)) | (SystemPlatform.advisor_evaluated.is_null(False)))
                                & ((SystemPlatform.opt_out == False) & (SystemPlatform.stale == False) & (SystemPlatform.when_deleted.is_null(True)))) \
                         .first().count  # noqa: E712
