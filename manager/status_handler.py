"""
Module for /status API endpoint
"""

import connexion
from peewee import IntegrityError, fn, ValuesList, DataError
from psycopg2 import IntegrityError as psycopg2IntegrityError

from common.logging import get_logger
from common.peewee_model import CveMetadata, DB, SystemPlatform, SystemVulnerabilities, \
    Status, RHAccount, CveAccountData
from .base import GetRequest, PatchRequest

LOGGER = get_logger(__name__)


class GetStatus(GetRequest):
    """GET to /v1/status"""

    _endpoint_name = r'/v1/status'

    @classmethod
    def handle_get(cls, **kwargs):  # pylint: disable=unused-argument
        """Return the data from the Status table as JSON"""
        query = (Status.select().order_by(Status.id.asc()).dicts())
        status_list = []
        for status in query:
            status_list.append(status)
        LOGGER.debug(status_list)
        return {'data': status_list, 'meta': {'total_items': len(status_list)}}, 200


class PatchStatus(PatchRequest):
    """PATCH to /v1/status"""

    _endpoint_name = r'/v1/status'

    @staticmethod
    def _prepare_data(data):
        if 'inventory_id' in data:
            in_inventory_id_list = data['inventory_id']
            if isinstance(in_inventory_id_list, str):
                in_inventory_id_list = [in_inventory_id_list]
        else:
            # change status for all systems for given CVE(s)
            in_inventory_id_list = None

        in_cve_list = data['cve']
        if isinstance(in_cve_list, str):
            in_cve_list = [in_cve_list]

        status_to_cves_map = {}
        status_text_to_cves_map = {}
        if 'status_id' in data:
            # single status for all CVEs
            status_to_cves_map[data['status_id']] = in_cve_list
        if 'status_text' in data:
            # single status for all CVEs
            try:
                key = data['status_text'].strip() if data['status_text'].strip() else None
            except AttributeError:
                key = None
            status_text_to_cves_map[key] = in_cve_list
        # if neither of status_id or status_text is set => inherit from CVE-level
        if not status_to_cves_map and not status_text_to_cves_map:
            # use CVE-level status if status not specified
            cve_details = (CveAccountData.select(CveMetadata.cve, CveAccountData.status, CveAccountData.status_text)
                           .join(CveMetadata, on=(CveAccountData.cve_id == CveMetadata.id))
                           .join(RHAccount, on=(CveAccountData.rh_account_id == RHAccount.id))
                           .where((RHAccount.name == connexion.context['user']) &
                                  (CveMetadata.cve << in_cve_list))
                           .dicts())

            found_cves = set()
            for cve in cve_details:
                status_to_cves_map.setdefault(cve["status"], []).append(cve["cve"])
                status_text_to_cves_map.setdefault(cve["status_text"], []).append(cve["cve"])
                found_cves.add(cve["cve"])
            # not found CVEs have 0 status by default, status_text is null
            for cve in in_cve_list:
                if cve not in found_cves:
                    status_to_cves_map.setdefault(0, []).append(cve)
                    status_text_to_cves_map.setdefault(None, []).append(cve)

        return in_inventory_id_list, in_cve_list, status_to_cves_map, status_text_to_cves_map

    @staticmethod
    def _update_divergent_status_count(in_cve_list, rh_account_id):
        """Update cached count how many systems-CVE pairs have different status than CVE-level status is"""

        cve_ids = CveMetadata.select(CveMetadata.id).where(CveMetadata.cve << in_cve_list)
        # pylint: disable=singleton-comparison
        div_counts = (SystemVulnerabilities.select(SystemVulnerabilities.cve_id,
                                                   fn.Count(SystemVulnerabilities.id).alias('systems_status_divergent'))
                      .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                      .where(SystemPlatform.rh_account_id == rh_account_id)
                      .where(SystemPlatform.opt_out == False)  # noqa: E712
                      .where(SystemVulnerabilities.cve_id << cve_ids)
                      .where(SystemVulnerabilities.when_mitigated.is_null(True))
                      .where(SystemVulnerabilities.status_id != fn.COALESCE(
                          (CveAccountData.select(CveAccountData.status_id)
                           .where(CveAccountData.rh_account_id == rh_account_id)
                           .where(CveAccountData.cve_id == SystemVulnerabilities.cve_id)), 0))
                      .group_by(SystemVulnerabilities.cve_id))

        divergent_systems = {}
        for cve_id in cve_ids:
            divergent_systems[cve_id] = 0
        for div_count in div_counts:
            divergent_systems[div_count.cve_id] = div_count.systems_status_divergent

        if divergent_systems:
            values_to_update = ValuesList([(cve_id, systems_status_divergent) for cve_id, systems_status_divergent
                                           in divergent_systems.items()],
                                          columns=('cve_id', 'systems_status_divergent'))
            query = (CveAccountData.update(systems_status_divergent=values_to_update.c.systems_status_divergent)
                     .from_(values_to_update)
                     .where(CveAccountData.cve_id == values_to_update.c.cve_id)
                     .where(CveAccountData.rh_account_id == rh_account_id))
            query.execute()

    @classmethod
    def handle_patch(cls, **kwargs):
        """Update the 'status' field for a system/cve combination"""
        # pylint: disable=singleton-comparison
        data = kwargs['data']
        in_inventory_id_list, in_cve_list, status_to_cves_map, status_text_to_cves_map = cls._prepare_data(data)

        try:
            rh_account = RHAccount.select(RHAccount.id).where(RHAccount.name == connexion.context['user'])
            systems = (SystemPlatform.select(SystemPlatform.id)
                       .where(SystemPlatform.rh_account_id == rh_account[0].id))  # noqa: E712
            if in_inventory_id_list is not None:
                systems = systems.where(SystemPlatform.inventory_id << in_inventory_id_list)
            rows_modified = set()
            # set statuses and their CVE lists
            for status_id, status_cve_list in status_to_cves_map.items():
                status_id_update = (SystemVulnerabilities.update(status_id=status_id)
                                    .from_(systems)
                                    .where((SystemVulnerabilities.system_id << systems) &
                                           (SystemVulnerabilities.cve_id <<
                                            (CveMetadata.select(CveMetadata.id).where(
                                                CveMetadata.cve << status_cve_list))))
                                    .returning(SystemVulnerabilities.id))
                rows_modified.update([row.id for row in status_id_update])

            cls._update_divergent_status_count(in_cve_list, rh_account[0].id)

            for status_text, status_cve_list in status_text_to_cves_map.items():
                status_text_update = (SystemVulnerabilities.update(status_text=status_text)
                                      .from_(systems)
                                      .where((SystemVulnerabilities.system_id << systems) &
                                             (SystemVulnerabilities.cve_id <<
                                              (CveMetadata.select(CveMetadata.id).where(
                                                  CveMetadata.cve << status_cve_list))))
                                      .returning(SystemVulnerabilities.id))
                rows_modified.update([row.id for row in status_text_update])

            updated_details = (SystemVulnerabilities.select(SystemPlatform.inventory_id, CveMetadata.cve)
                               .join(CveMetadata, on=(SystemVulnerabilities.cve_id == CveMetadata.id))
                               .join(SystemPlatform, on=(SystemVulnerabilities.system_id == SystemPlatform.id))
                               .where(SystemVulnerabilities.id << list(rows_modified))
                               .dicts())
            updated = []
            for updated_row in updated_details:
                updated.append({"inventory_id": updated_row["inventory_id"], "cve": updated_row["cve"]})
            if not updated:
                # sysid/cve/acct combination does not exist
                return cls.format_exception('inventory_id/cve must exist and inventory_id must be visible to user', 404)
        except (IntegrityError, psycopg2IntegrityError, DataError) as value_error:
            # usually means bad-status-id
            LOGGER.error(str(value_error))
            DB.rollback()
            return cls.format_exception(f'status_id={list(status_to_cves_map.keys())} is invalid', 400)
        except ValueError as value_error:
            LOGGER.exception('Error during setting status (ValueError):')
            DB.rollback()
            return cls.format_exception(f'status_text or other key value is invalid ({value_error})', 400)
        return {"updated": updated}
