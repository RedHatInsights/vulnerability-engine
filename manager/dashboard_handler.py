"""
Module for /dashboard API
"""
from datetime import datetime
from datetime import timedelta
from datetime import timezone

import connexion
from flask import g
from peewee import fn
from peewee import SQL

from .base import cyndi_join
from .base import edge_feature_arg
from .base import get_account_data
from .base import get_system_count
from .base import GetRequest
from .base import is_not_cacheable_request
from .base import is_valid_cache
from .base import parse_tags
from .base import round_to_100_percent
from .filters import apply_filters
from .filters import filter_types
from .rbac_manager import RbacManager as RBAC
from .rbac_manager import RbacRoutePermissions
from common.config import Config
from common.feature_flags import UNLEASH
from common.logging import get_logger
from common.peewee_conditions import system_has_rule_hit
from common.peewee_conditions import system_is_active
from common.peewee_conditions import system_is_vulnerable
from common.peewee_model import CveAccountCache
from common.peewee_model import CveMetadata
from common.peewee_model import CveRuleMapping
from common.peewee_model import InsightsRule
from common.peewee_model import RuleAccountCache
from common.peewee_model import SystemPlatform
from common.peewee_model import SystemVulnerabilities

LOGGER = get_logger(__name__)
CFG = Config()
FILTERS = [filter_types.SYSTEM_TAGS,
           filter_types.SYSTEM_SAP,
           filter_types.SYSTEM_SAP_SIDS,
           filter_types.SYSTEM_AAP,
           filter_types.SYSTEM_MSSQL, ]


class GetDashboard(GetRequest):
    """Get to /v1/dashboard"""

    _endpoint_name = r"/v1/dashboard"

    @classmethod
    @RBAC.need_permissions(RbacRoutePermissions.VULNERABILITY_RESULTS)
    def handle_get(cls, **kwargs):
        # pylint: disable=singleton-comparison, too-many-branches, too-many-statements
        retval = {
            "cves_total": 0,
            "cves_by_severity": {
                "0to3.9": {
                    "percentage": 0,
                    "count": 0,
                    "known_exploits": 0
                },
                "4to7.9": {
                    "percentage": 0,
                    "count": 0,
                    "known_exploits": 0
                },
                "8to10": {
                    "percentage": 0,
                    "count": 0,
                    "known_exploits": 0
                },
                "na": {
                    "percentage": 0,
                    "count": 0,
                    "known_exploits": 0
                }
            },
            "exploited_cves_count": 0,
            "system_count": 0,
            "recent_cves": {
                "last7days": 0,
                "last30days": 0,
                "last90days": 0
            },
            "recent_rules": [],
            "rules_cves_total": 0,
        }

        args_desc = [
            {"arg_name": "tags", "convert_func": parse_tags},
            {"arg_name": "sap_system", "convert_func": None},
            {"arg_name": "sap_sids", "convert_func": None},
            {"arg_name": "ansible", "convert_func": None},
            {"arg_name": "mssql", "convert_func": None},
        ]
        args = cls._parse_arguments(kwargs, args_desc)
        cyndi_request = is_not_cacheable_request(args)
        account_data = get_account_data(connexion.context["user"])

        # argument for controling host types in system counts
        edge = edge_feature_arg()

        retval["system_count"] = get_system_count(account_data.id, True, FILTERS, args, edge=edge)

        # API using cache, set keepalive for account to enable maintaining cache
        valid_cache = is_valid_cache(account_data, g.group_ids)

        # Use cache if not disabled + systems are not filtered + cache exists
        if UNLEASH.is_enabled("vulnerability.account_cache") and not cyndi_request and valid_cache:
            active_cves_subquery = (CveAccountCache
                                    .select(CveAccountCache.cve_id.alias("cve_id_"))
                                    .where(CveAccountCache.rh_account_id == account_data.id))
        else:
            active_cves_subquery = (SystemVulnerabilities
                                    .select(fn.Distinct(SystemVulnerabilities.cve_id).alias("cve_id_"))
                                    .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                                              system_is_active(rh_account_id=account_data.id, edge=edge)))
                                    .where(SystemVulnerabilities.rh_account_id == account_data.id)
                                    .where(system_is_vulnerable()))
            active_cves_subquery = cyndi_join(active_cves_subquery)
            active_cves_subquery = apply_filters(active_cves_subquery, args, FILTERS, {})

        query = (CveMetadata
                 .select(CveMetadata.cve,
                         fn.COALESCE(CveMetadata.cvss3_score, CveMetadata.cvss2_score).alias("cvss_score"),
                         CveMetadata.public_date,
                         CveMetadata.id,
                         CveMetadata.exploit_data,
                         CveMetadata.advisories_list)
                 .join(active_cves_subquery, on=(CveMetadata.id == active_cves_subquery.c.cve_id_))
                 .dicts())
        if not account_data.cves_without_errata:
            query = query.where(CveMetadata.advisories_list != SQL("'[]'"))

        cve_data = []
        affecting_cves = []
        for cve in query:
            cve_data.append((cve["cvss_score"], cve["public_date"], cve["exploit_data"], cve["advisories_list"]))
            affecting_cves.append(cve["id"])

        retval["cves_total"] = len(cve_data)
        retval["exploited_cves_count"] = len([row[2] for row in cve_data if bool(row[2]) and bool(row[3])])

        today = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)  # offset-aware
        last7 = today - timedelta(days=7)
        last30 = today - timedelta(days=30)
        last90 = today - timedelta(days=90)
        rules_date = today - timedelta(days=CFG.dashboard_rules_age)

        for cvss_score, public_date, exploit_data, advisories_list in cve_data:
            if cvss_score is None:
                retval["cves_by_severity"]["na"]["count"] += 1
                if exploit_data and advisories_list:
                    retval["cves_by_severity"]["na"]["known_exploits"] += 1
            elif cvss_score < 4:
                retval["cves_by_severity"]["0to3.9"]["count"] += 1
                if exploit_data and advisories_list:
                    retval["cves_by_severity"]["0to3.9"]["known_exploits"] += 1
            elif 4 <= cvss_score < 8:
                retval["cves_by_severity"]["4to7.9"]["count"] += 1
                if exploit_data and advisories_list:
                    retval["cves_by_severity"]["4to7.9"]["known_exploits"] += 1
            elif cvss_score >= 8:
                retval["cves_by_severity"]["8to10"]["count"] += 1
                if exploit_data and advisories_list:
                    retval["cves_by_severity"]["8to10"]["known_exploits"] += 1

            if public_date is not None:
                if public_date >= last7:
                    retval["recent_cves"]["last7days"] += 1
                if public_date >= last30:
                    retval["recent_cves"]["last30days"] += 1
                if public_date >= last90:
                    retval["recent_cves"]["last90days"] += 1

        rounded_percentage = round_to_100_percent([v["count"] for v in retval["cves_by_severity"].values()])

        for indx, keys in enumerate(retval["cves_by_severity"]):
            retval["cves_by_severity"][keys]["percentage"] = rounded_percentage[indx]

        if UNLEASH.is_enabled("vulnerability.account_cache") and not cyndi_request and valid_cache:
            rules_breakdown = (CveAccountCache.select(fn.COUNT(fn.Distinct(CveAccountCache.cve_id)).alias("rules_cves_count"))
                               .join(CveRuleMapping, on=(CveAccountCache.cve_id == CveRuleMapping.cve_id))
                               .join(InsightsRule, on=(
                                    (CveRuleMapping.rule_id == InsightsRule.id) & (InsightsRule.active == True)))
                               .where(CveAccountCache.rh_account_id == account_data.id))
        else:
            rules_breakdown = (CveRuleMapping.select(fn.COUNT(fn.Distinct(CveRuleMapping.cve_id)).alias("rules_cves_count"))
                                             .join(InsightsRule, on=((CveRuleMapping.rule_id == InsightsRule.id)
                                                                     & (InsightsRule.active == True)))
                                             .where(CveRuleMapping.cve_id << affecting_cves))
        rules_breakdown = rules_breakdown.first()

        retval["rules_cves_total"] = rules_breakdown.rules_cves_count

        if UNLEASH.is_enabled("vulnerability.account_cache") and not cyndi_request and valid_cache:
            counts_query = (RuleAccountCache.select(RuleAccountCache.rule_id.alias("rule_id_"),
                                                    RuleAccountCache.systems_affected.alias("systems_affected_"))
                            .where(RuleAccountCache.rh_account_id == account_data.id))
        else:
            counts_query = (SystemVulnerabilities
                            .select(SystemVulnerabilities.rule_id.alias("rule_id_"),
                                    fn.Count(fn.Distinct(SystemVulnerabilities.system_id)).alias("systems_affected_"))
                            .join(SystemPlatform, on=((SystemVulnerabilities.system_id == SystemPlatform.id) &
                                                      system_is_active(rh_account_id=account_data.id, edge=edge)))
                            .where(SystemVulnerabilities.rh_account_id == account_data.id)
                            .where(system_has_rule_hit())
                            .group_by(SystemVulnerabilities.rule_id))
            counts_query = cyndi_join(counts_query)
            counts_query = apply_filters(counts_query, args, FILTERS, {})

        recent_rules = (InsightsRule.select(InsightsRule.description_text.alias("name"),
                                            InsightsRule.summary_text.alias("description"),
                                            counts_query.c.systems_affected_.alias("systems_affected"),
                                            InsightsRule.rule_impact.alias("severity"),
                                            InsightsRule.kbase_node_id.alias("node_id"),
                                            fn.ARRAY_AGG(fn.Distinct(CveMetadata.cve)).alias("associated_cves"),
                                            InsightsRule.name.alias("id"),
                                            InsightsRule.publish_date.alias("public_date"))
                        .join(CveRuleMapping, on=(InsightsRule.id == CveRuleMapping.rule_id))
                        .join(counts_query, on=(InsightsRule.id == counts_query.c.rule_id_))
                        .join(CveMetadata, on=(CveRuleMapping.cve_id == CveMetadata.id))
                        .where((InsightsRule.publish_date >= rules_date) & (InsightsRule.active == True) & (InsightsRule.rule_only == False))  # noqa: E712
                        .group_by(InsightsRule.description_text, InsightsRule.publish_date, InsightsRule.rule_impact, InsightsRule.kbase_node_id,
                                  SQL("systems_affected"), InsightsRule.name, InsightsRule.publish_date, InsightsRule.summary_text)
                        .order_by(InsightsRule.publish_date.desc(), InsightsRule.rule_impact, InsightsRule.description_text)
                        .dicts())

        recent_rules = apply_filters(recent_rules, args, [], {"count_subquery": counts_query})

        for rule in recent_rules:
            retval["recent_rules"].append(rule)

        return retval
