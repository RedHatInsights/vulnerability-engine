"""
Module for admin API endpoints
"""
import json
import subprocess
import requests

import connexion
from peewee import DatabaseError

from common.config import Config
from common.logging import get_logger
from common.peewee_model import ContentVersion, DB, InsightsRule, SystemPlatform, Announcement, NotifiedAccounts, SystemVulnerabilities
from .base import DeleteRequest, GetRequest, PutRequest, ApplicationException
from .list_view import ListView

CFG = Config()

LOGGER = get_logger(__name__)


class GetMissingInInventory(GetRequest):
    """GET to /v1/systems/missing_in_inventory"""

    _endpoint_name = r'/v1/systems/missing_in_inventory'

    @classmethod
    def handle_get(cls, **kwargs):  # pylint: disable=unused-argument
        """Get count of systems in system_platform table but missing in inventory."""
        cursor = DB.execute_sql("""
            SELECT COUNT(sp.inventory_id)
            FROM system_platform sp LEFT JOIN
                 inventory.hosts ih ON sp.inventory_id = ih.id
            WHERE ih.id IS NULL
              AND sp.when_deleted IS NULL
        """)
        return cursor.fetchone()[0]


class DeleteMissingInInventory(DeleteRequest):
    """DELETE to /v1/systems/missing_in_inventory"""

    _endpoint_name = r'/v1/systems/missing_in_inventory'

    @classmethod
    def handle_delete(cls, **kwargs):  # pylint: disable=unused-argument
        """Delete systems from system_platform table missing in inventory."""
        DB.execute_sql("""
            UPDATE system_platform sp
               SET opt_out = true, stale = true, when_deleted = now()
            FROM (
                SELECT sp2.inventory_id
                FROM system_platform sp2 LEFT JOIN
                     inventory.hosts ih ON sp2.inventory_id = ih.id
                WHERE ih.id IS NULL
                  AND sp2.when_deleted IS NULL
                ORDER BY sp2.inventory_id
                FOR UPDATE OF sp2
            ) up
            WHERE sp.inventory_id = up.inventory_id
        """)
        return ""


class TaskomaticRun(PutRequest):
    """PUT to /v1/taskomatic/run"""

    _endpoint_name = r'/v1/taskomatic/run'

    @classmethod
    def handle_put(cls, **kwargs):
        """Trigger immediate run of taskomatic job with given name."""
        job_name = kwargs["job_name"]
        response = requests.put(f"{CFG.taskomatic_host}/api/v1/run/{job_name}")
        if response.status_code != 200:
            raise ApplicationException("job_name must exist", 404)


class VmaasSync(PutRequest):
    """PUT to /v1/vmaas/sync"""

    _endpoint_name = r'/v1/vmaas/sync'

    @classmethod
    def handle_put(cls, **kwargs):  # pylint: disable=unused-argument
        """Trigger immediate run of sync in vmaas_sync."""
        requests.put(f"{CFG.vmaas_sync_host}/api/v1/sync")


class VmaasReEvaluate(PutRequest):
    """PUT to /v1/vmaas/re-evaluate"""

    _endpoint_name = r'/v1/vmaas/re-evaluate'

    @classmethod
    def handle_put(cls, **kwargs):  # pylint: disable=unused-argument
        """Trigger immediate run of re-evaluation in vmaas_sync."""
        requests.put(f"{CFG.vmaas_sync_host}/api/v1/re-evaluate")


class DeleteCve(DeleteRequest):
    """DELETE to /cves/{cve_id}"""

    _endpoint_name = r'/cves/{cve_id}'

    @classmethod
    def handle_delete(cls, **kwargs):
        """Delete CVE with given name."""
        cve_id = kwargs["cve_id"]
        requests.delete(f"{CFG.vmaas_sync_host}/api/v1/cves/{cve_id}")


class GetContentVersion(GetRequest):
    """GET to /v1/content_version"""

    _endpoint_name = r'/v1/content_version'

    @classmethod
    def handle_get(cls, **kwargs):
        """Return content versions"""
        data = ContentVersion.select(ContentVersion.insights_content_vulnerability,
                                     ContentVersion.insights_content_vulnerability_repo,
                                     ContentVersion.insights_playbooks,
                                     ContentVersion.insights_playbooks_repo).dicts()
        return data[0]


class GetQueries(GetRequest):
    """GET to /v1/database/queries"""

    _endpoint_name = r'/v1/database/queries'

    @classmethod
    def handle_get(cls, **kwargs):
        threshold = kwargs.get("ms_threshold", 0)
        username = kwargs.get("username", None)
        wait_event_type = kwargs.get("wait_event_type", None)

        result = []

        try:
            cursor = DB.execute_sql("""
                        SELECT pid, datname, usename, application_name,
                               query_start, now() - query_start AS running_time,
                               wait_event_type, wait_event, query
                        FROM pg_stat_activity
                        WHERE EXTRACT(MILLISECONDS FROM now() - query_start) >= %s AND
                              (usename = %s OR %s IS NULL) AND
                              (wait_event_type = %s OR %s IS NULL) AND
                              state = 'active'
                        """, (threshold, username, username, wait_event_type, wait_event_type))
        except DatabaseError as err:
            LOGGER.exception("Internal server error: %s", err)
            return {"queries": result}

        for query in cursor:
            result.append(
                {"pid": query[0],
                 "db_name": query[1],
                 "username": query[2],
                 "app_name": query[3],
                 "query_start": str(query[4]),
                 "running_time": str(query[5]),
                 "wait_event_type": query[6],
                 "wait_event": query[7],
                 "query": query[8]}
            )

        return {"queries": result}


class KillQuery(DeleteRequest):
    """DELETE to /v1/database/query/{pid}"""

    _endpoint_name = r'/v1/database/query/{pid}'

    @classmethod
    def handle_delete(cls, **kwargs):
        pid = kwargs["pid"]
        try:
            LOGGER.info("Killing query with PID %s", pid)
            DB.execute_sql("SELECT pg_terminate_backend(%s)", (pid,))
        except DatabaseError as err:
            LOGGER.exception("Internal server error: %s", err)
            return "Error"
        return "Ok"


class BloatEndpoint:
    """Base class for bloat endpoints"""

    @classmethod
    def format_bloat_result(cls, res):
        """Formats pgstattuple db result"""
        result = {}
        result["table_len"] = res[0]
        result["tuple_count"] = res[1]
        result["tuple_len"] = res[2]
        result["tuple_percent"] = res[3]
        result["dead_tuple_count"] = res[4]
        result["dead_tuple_len"] = res[5]
        result["dead_tuple_percent"] = res[6]
        result["free_space"] = res[7]
        result["free_percent"] = res[8]
        return result


class GetBloat(GetRequest, BloatEndpoint):
    """GET to /v1/database/bloat/table/{table_name}"""

    _endpoint_name = r'/v1/database/bloat/{table_name}'

    @classmethod
    def handle_get(cls, **kwargs):
        table = kwargs["table_name"]
        try:
            res = DB.execute_sql("""SELECT * FROM pgstattuple(%s)""", (table,)).fetchone()
        except DatabaseError as err:
            LOGGER.exception("Internal server error: %s", err)
            return {}

        return cls.format_bloat_result(res)


class GetUserBloat(GetRequest, BloatEndpoint):
    """GET to /v1/database/bloat/user/{rh_account_id}"""

    _endpoint_name = r'/v1/database/bloat/user/{rh_account_id}'

    @classmethod
    def handle_get(cls, **kwargs):
        rh_account_id = kwargs["rh_account_id"]
        result = []
        try:
            tables = DB.execute_sql("""
                        SELECT DISTINCT(tableoid::pg_catalog.regclass)
                        FROM system_vulnerabilities
                        WHERE rh_account_id = %s""", (rh_account_id,))

            for table in tables:
                res = DB.execute_sql("""SELECT * FROM pgstattuple(%s)""", (table[0],)).fetchone()
                res = cls.format_bloat_result(res)
                res["table_name"] = table[0]
                result.append(res)
        except DatabaseError as err:
            LOGGER.exception("Internal server error: %s", err)
        return {"tables": result}


class VacuumTable(GetRequest):
    """GET to /v1/database/vacuum/table/{table_name}"""

    _endpoint_name = r'/v1/database/vacuum/{table_name}'

    @classmethod
    def handle_get(cls, **kwargs):
        table = kwargs["table_name"]
        only_indexes = kwargs.get("only_indexes", False)

        command = ["pg_repack",
                   "-t", table,
                   "-p", str(CFG.db_port), "-d", CFG.db_name,
                   "-h", CFG.db_host, "-U", CFG.db_user, "-k"]

        if only_indexes:
            command.append("-x")

        LOGGER.info("Repacking table %s", table)
        subprocess.Popen(command, env={"PGPASSWORD": CFG.db_pass})

        return "Started"


class VacuumUser(GetRequest):
    """GET to /v1/database/vacuum/user/{rh_account_id}"""

    _endpoint_name = r'/v1/database/vaccum/user/{rh_account_id}'

    @classmethod
    def handle_get(cls, **kwargs):
        rh_account_id = kwargs["rh_account_id"]
        try:
            tables = DB.execute_sql("""
                        SELECT tableoid::pg_catalog.regclass
                        FROM system_vulnerabilities
                        WHERE rh_account_id = %s""", (rh_account_id,))

            if tables.rowcount < 1:
                return "No tables to vacuum"

            command = ["pg_repack",
                       "-p", str(CFG.db_port), "-d", CFG.db_name,
                       "-h", CFG.db_host, "-U", CFG.db_user, "-k"]

            for table in tables:
                command.append("-t")
                command.append(table[0])

            LOGGER.info("Repacking tables %s", tables)
            subprocess.Popen(command, env={"PGPASSWORD": CFG.db_pass})

        except DatabaseError as err:
            LOGGER.exception("Internal server error: %s", err)
            return "Error"
        return "Ok"


class DeleteSystem(DeleteRequest):
    """DELETE to /v1/database/systems/{inventory_id}"""

    _endpoint_name = r"/v1/database/systems/{inventory_id}"

    @classmethod
    def _system_exists(cls, inventory_id):
        system = (SystemPlatform.select()
                  .where((SystemPlatform.inventory_id == inventory_id)))
        if not system.exists():
            raise ApplicationException("inventory_id must exist", 404)

    @classmethod
    def handle_delete(cls, **kwargs):
        """Delete system"""
        inventory_id = kwargs["inventory_id"]
        cls._system_exists(inventory_id)
        DB.execute_sql("SELECT delete_system(%s)", (inventory_id,))
        return ""


class SetAnnouncement(PutRequest):
    """PUT to /v1/announcement"""

    _endpoint_name = r'/v1/announcement'

    @classmethod
    def handle_put(cls, **kwargs):
        """Set new announcement."""
        # pylint: disable=no-value-for-parameter
        Announcement.delete().execute()

        msg = kwargs["data"]["message"]
        record = Announcement.create(message=msg)

        return {'message': record.message,
                'last_updated': record.last_updated}, 200


class DeleteAnnouncement(DeleteRequest):
    """DELETE to /v1/announcement"""

    _endpoint_name = r'/v1/announcement'

    @classmethod
    def handle_delete(cls, **kwargs):
        """Delete Announcement from DB."""
        # pylint: disable=no-value-for-parameter
        Announcement.delete().execute()
        return {'status': 'Deleted successfully.'}, 200


class DeleteNotifications(DeleteRequest):
    """DELETE to /v1/notifications/{rh_account_id}"""

    _endpoint_name = r'/v1/notifications/{rh_account_id}'

    @classmethod
    def handle_delete(cls, **kwargs):
        """Delete saved notifications for given account id"""
        rh_account_id = kwargs["rh_account_id"]
        try:
            (NotifiedAccounts.delete()
                             .where(NotifiedAccounts.rh_account_id == rh_account_id)).execute()
        except DatabaseError as err:
            LOGGER.exception("Internal server error: %s", err)
            return "Error", 500
        requests.put(f"{CFG.notificator_host}/api/v1/cache")
        return "Ok", 200


class RulesView(ListView):
    """Database select for /v1/rule/{rule_id}/reports"""

    def __init__(self, rule_id: int, list_args, uri):
        query = (SystemVulnerabilities.select(SystemVulnerabilities.id, SystemVulnerabilities.rule_hit_details)
                 .where(SystemVulnerabilities.rule_id == rule_id)
                 .dicts())
        super().__init__(query, {}, {}, {}, {}, list_args, {}, uri)


class RuleReports(GetRequest):
    """GET to /v1/rule/{rule_id}/reports"""

    _endpoint_name = r'/v1/rule/{rule_id}/reports'

    @classmethod
    def handle_get(cls, **kwargs):
        """Get the data"""
        rule_id = InsightsRule.select(InsightsRule.id).where(InsightsRule.name == kwargs['rule_id']).where(~InsightsRule.rule_only).dicts()
        if not rule_id:
            raise ApplicationException("not found", 404)

        rules_view = RulesView(rule_id, cls._parse_list_arguments(kwargs), connexion.request.path)

        to_return = []
        for item in rules_view:
            to_return.append({'delta': item['id'], 'details': json.loads(item['rule_hit_details'])})

        meta = rules_view.get_metadata()
        meta['count'] = meta['total_items']  # count is used by Content Preview app

        return {'data': to_return, 'meta': meta, 'links': rules_view.get_pagination_links()}, 200
